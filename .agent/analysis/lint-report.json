
> openapi-zod-client@1.18.3 lint /Users/jim/code/personal/openapi-zod-client/lib
> eslint . --format json

[{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/eslint.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/samples-generator.ts","messages":[{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":17,"column":1,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":25,"endColumn":4,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[349,349],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[349,349],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"sonarjs/no-os-command-from-path","severity":2,"message":"Make sure the \"PATH\" variable only contains fixed, unwriteable directories.","line":20,"column":15,"nodeType":"Literal","messageId":"issue","endLine":20,"endColumn":38}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fg from \"fast-glob\";\n\nimport degit from \"degit\";\nimport { unlinkSync } from \"node:fs\";\nimport { spawnSync } from \"node:child_process\";\n\nconst emitter = degit(\"https://github.com/OAI/OpenAPI-Specification/examples\", {\n    cache: true,\n    force: true,\n    verbose: true,\n});\n\nemitter.on(\"info\", (info) => {\n    console.log(info.message);\n});\n\nemitter.clone(\"./samples\").then(() => {\n    console.log(\"done cloning samples\");\n\n    spawnSync(\"rm -rf ./samples/v2.0\", { shell: true });\n    console.log(\"removed v2.0 swagger samples\");\n\n    const jsonList = fg.sync([String.raw`./samples/v3\\.*/**/*.json`]);\n    jsonList.forEach((jsonPath) => unlinkSync(jsonPath));\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/CodeMeta.test.ts","messages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"CodeMeta\" of template literal expression.","line":250,"column":37,"nodeType":"Identifier","messageId":"invalidType","endLine":250,"endColumn":41}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, expect, it } from \"vitest\";\nimport type { ReferenceObject, SchemaObject } from \"openapi3-ts\";\n\nimport { CodeMeta, type ConversionTypeContext } from \"./CodeMeta.js\";\nimport { makeSchemaResolver } from \"./makeSchemaResolver.js\";\n\ndescribe(\"CodeMeta\", () => {\n    const mockDoc = {\n        openapi: \"3.0.0\" as const,\n        info: { title: \"Test\", version: \"1.0.0\" },\n        paths: {},\n        components: {\n            schemas: {\n                Pet: {\n                    type: \"object\" as const,\n                    properties: {\n                        id: { type: \"integer\" as const },\n                        name: { type: \"string\" as const },\n                    },\n                },\n            },\n        },\n    };\n\n    describe(\"constructor\", () => {\n        it(\"should initialize with schema\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const meta = new CodeMeta(schema);\n\n            expect(meta.schema).toBe(schema);\n            expect(meta.ref).toBeUndefined();\n            expect(meta.meta.referencedBy).toEqual([]);\n        });\n\n        it(\"should extract $ref from ReferenceObject\", () => {\n            const refSchema: ReferenceObject = { $ref: \"#/components/schemas/Pet\" };\n            const meta = new CodeMeta(refSchema);\n\n            expect(meta.ref).toBe(\"#/components/schemas/Pet\");\n            expect(meta.meta.referencedBy).toHaveLength(1);\n            expect(meta.meta.referencedBy[0]).toBe(meta);\n        });\n\n        it(\"should initialize referencedBy array from metadata\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const parentMeta = new CodeMeta(schema);\n            const childMeta = new CodeMeta(schema, undefined, {\n                referencedBy: [parentMeta],\n            });\n\n            expect(childMeta.meta.referencedBy).toHaveLength(1);\n            expect(childMeta.meta.referencedBy[0]).toBe(parentMeta);\n        });\n\n        it(\"should preserve other metadata fields\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const meta = new CodeMeta(schema, undefined, {\n                name: \"testField\",\n                isRequired: true,\n            });\n\n            expect(meta.meta.name).toBe(\"testField\");\n            expect(meta.meta.isRequired).toBe(true);\n        });\n    });\n\n    describe(\"codeString getter\", () => {\n        it(\"should return assigned code when explicitly set\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const meta = new CodeMeta(schema).assign(\"z.string()\");\n\n            expect(meta.codeString).toBe(\"z.string()\");\n        });\n\n        it(\"should return empty string when ref is undefined\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const meta = new CodeMeta(schema);\n\n            expect(meta.codeString).toBe(\"\");\n        });\n\n        it(\"should return ref when no code assigned and no ctx\", () => {\n            const refSchema: ReferenceObject = { $ref: \"#/components/schemas/Pet\" };\n            const meta = new CodeMeta(refSchema);\n\n            expect(meta.codeString).toBe(\"#/components/schemas/Pet\");\n        });\n\n        it(\"should resolve ref through ctx resolver when provided\", () => {\n            const resolver = makeSchemaResolver(mockDoc);\n            resolver.getSchemaByRef(\"#/components/schemas/Pet\");\n\n            const ctx: ConversionTypeContext = {\n                resolver,\n                zodSchemaByName: {},\n                schemaByName: {},\n            };\n\n            const refSchema: ReferenceObject = { $ref: \"#/components/schemas/Pet\" };\n            const meta = new CodeMeta(refSchema, ctx);\n\n            expect(meta.codeString).toBe(\"Pet\");\n        });\n\n        it(\"should prefer assigned code over ref resolution\", () => {\n            const resolver = makeSchemaResolver(mockDoc);\n            resolver.getSchemaByRef(\"#/components/schemas/Pet\");\n\n            const ctx: ConversionTypeContext = {\n                resolver,\n                zodSchemaByName: {},\n                schemaByName: {},\n            };\n\n            const refSchema: ReferenceObject = { $ref: \"#/components/schemas/Pet\" };\n            const meta = new CodeMeta(refSchema, ctx).assign(\"z.object({ custom: true })\");\n\n            expect(meta.codeString).toBe(\"z.object({ custom: true })\");\n        });\n    });\n\n    describe(\"complexity getter\", () => {\n        it(\"should calculate complexity for primitive schemas\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const meta = new CodeMeta(schema);\n\n            expect(meta.complexity).toBe(1);\n        });\n\n        it(\"should calculate complexity for object schemas\", () => {\n            const schema: SchemaObject = {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    age: { type: \"integer\" },\n                },\n            };\n            const meta = new CodeMeta(schema);\n\n            // Object complexity: 2 (object) + 1 (string) + 1 (integer) = 4\n            expect(meta.complexity).toBeGreaterThan(1);\n        });\n\n        it(\"should handle reference objects in complexity calculation\", () => {\n            const refSchema: ReferenceObject = { $ref: \"#/components/schemas/Pet\" };\n            const meta = new CodeMeta(refSchema);\n\n            // Reference adds complexity of 2\n            expect(meta.complexity).toBe(2);\n        });\n    });\n\n    describe(\"assign method\", () => {\n        it(\"should set code and return self for chaining\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const meta = new CodeMeta(schema);\n\n            const result = meta.assign(\"z.string()\");\n\n            expect(result).toBe(meta);\n            expect(meta.codeString).toBe(\"z.string()\");\n        });\n\n        it(\"should overwrite existing code\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const meta = new CodeMeta(schema);\n\n            meta.assign(\"z.string()\");\n            meta.assign(\"z.string().min(1)\");\n\n            expect(meta.codeString).toBe(\"z.string().min(1)\");\n        });\n\n        it(\"should allow chaining with inherit\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const parent = new CodeMeta(schema);\n            const child = new CodeMeta(schema);\n\n            child.assign(\"z.string()\").inherit(parent);\n\n            expect(child.codeString).toBe(\"z.string()\");\n            expect(parent.children).toContain(child);\n        });\n    });\n\n    describe(\"inherit method\", () => {\n        it(\"should add self to parent's children array\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const parent = new CodeMeta(schema);\n            const child = new CodeMeta(schema);\n\n            child.inherit(parent);\n\n            expect(parent.children).toContain(child);\n            expect(parent.children).toHaveLength(1);\n        });\n\n        it(\"should handle undefined parent gracefully\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const meta = new CodeMeta(schema);\n\n            // inherit() accepts optional parent parameter\n            expect(() => meta.inherit()).not.toThrow();\n        });\n\n        it(\"should return self for chaining\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const parent = new CodeMeta(schema);\n            const child = new CodeMeta(schema);\n\n            const result = child.inherit(parent);\n\n            expect(result).toBe(child);\n        });\n\n        it(\"should allow multiple children on same parent\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const parent = new CodeMeta(schema);\n            const child1 = new CodeMeta(schema);\n            const child2 = new CodeMeta(schema);\n\n            child1.inherit(parent);\n            child2.inherit(parent);\n\n            expect(parent.children).toHaveLength(2);\n            expect(parent.children).toContain(child1);\n            expect(parent.children).toContain(child2);\n        });\n    });\n\n    describe(\"toString and toJSON methods\", () => {\n        it(\"should return codeString from toString\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const meta = new CodeMeta(schema).assign(\"z.string()\");\n\n            expect(meta.toString()).toBe(\"z.string()\");\n        });\n\n        it(\"should return codeString from toJSON\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const meta = new CodeMeta(schema).assign(\"z.string()\");\n\n            expect(meta.toJSON()).toBe(\"z.string()\");\n        });\n\n        it(\"should allow implicit string conversion\", () => {\n            const schema: SchemaObject = { type: \"string\" };\n            const meta = new CodeMeta(schema).assign(\"z.string()\");\n\n            const result = `Code: ${meta}`;\n            expect(result).toBe(\"Code: z.string()\");\n        });\n    });\n\n    describe(\"reference tracking\", () => {\n        it(\"should track references through referencedBy array\", () => {\n            const refSchema: ReferenceObject = { $ref: \"#/components/schemas/Pet\" };\n            const meta = new CodeMeta(refSchema);\n\n            // Reference objects add themselves to referencedBy\n            expect(meta.meta.referencedBy).toHaveLength(1);\n            expect(meta.meta.referencedBy[0]!.ref).toBe(\"#/components/schemas/Pet\");\n        });\n\n        it(\"should preserve reference chain through nested metadata\", () => {\n            const refSchema: ReferenceObject = { $ref: \"#/components/schemas/Pet\" };\n            const parent = new CodeMeta(refSchema);\n\n            const childRefSchema: ReferenceObject = { $ref: \"#/components/schemas/Owner\" };\n            const child = new CodeMeta(childRefSchema, undefined, {\n                referencedBy: [...parent.meta.referencedBy],\n            });\n\n            expect(child.meta.referencedBy.length).toBeGreaterThan(0);\n        });\n    });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/CodeMeta.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/cli.ts","messages":[{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":39,"column":24,"nodeType":"TSAsExpression","messageId":"never","endLine":39,"endColumn":79},{"ruleId":"max-statements","severity":2,"message":"Async arrow function has too many statements (31). Maximum allowed is 30.","line":101,"column":13,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":159,"endColumn":6},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":104,"column":28,"nodeType":"TSAsExpression","messageId":"never","endLine":104,"endColumn":91},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":104,"column":28,"nodeType":"TSAsExpression","messageId":"never","endLine":104,"endColumn":74},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":111,"column":31,"nodeType":"TSAsExpression","messageId":"never","endLine":117,"endColumn":24},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":120,"column":39,"nodeType":"TSAsExpression","messageId":"never","endLine":120,"endColumn":109},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":157,"column":44,"nodeType":"TSAsExpression","messageId":"never","endLine":157,"endColumn":112}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { readFileSync } from \"node:fs\";\nimport { resolve } from \"node:path\";\n\nimport SwaggerParser from \"@apidevtools/swagger-parser\";\nimport { Command } from \"commander\";\nimport type { OpenAPIObject } from \"openapi3-ts\";\nimport { resolveConfig } from \"prettier\";\n\nimport { toBoolean } from \"./utils.js\";\nimport { generateZodClientFromOpenAPI } from \"./generateZodClientFromOpenAPI.js\";\n\ninterface CliOptions {\n    output?: string;\n    template?: string;\n    prettier?: string;\n    baseUrl?: string;\n    withAlias?: boolean;\n    apiClientName?: string;\n    errorExpr?: string;\n    successExpr?: string;\n    mediaTypeExpr?: string;\n    exportSchemas?: boolean;\n    exportTypes?: boolean;\n    implicitRequired?: boolean;\n    withDeprecated?: boolean;\n    withDocs?: boolean;\n    withDescription?: boolean;\n    groupStrategy?: string;\n    complexityThreshold?: string;\n    defaultStatus?: string;\n    allReadonly?: boolean;\n    strictObjects?: boolean;\n    additionalPropsDefaultValue?: boolean;\n}\n\nfunction getPackageVersion(): string {\n    try {\n        const packageJsonContent = readFileSync(resolve(__dirname, \"../../package.json\"), \"utf8\");\n        const parsed = JSON.parse(packageJsonContent) as { version?: unknown };\n        return typeof parsed.version === \"string\" ? parsed.version : \"0.0.0\";\n    } catch {\n        return \"0.0.0\";\n    }\n}\n\nconst program = new Command();\n\nprogram\n    .name(\"openapi-zod-client\")\n    .description(\"Generate a Zodios API client from an OpenAPI specification\")\n    .version(getPackageVersion())\n    .argument(\"<input>\", \"path/url to OpenAPI/Swagger document as json/yaml\")\n    .option(\"-o, --output <path>\", \"Output path for the zodios api client ts file (defaults to `<input>.client.ts`)\")\n    .option(\n        \"-t, --template <path>\",\n        \"Template path for the handlebars template that will be used to generate the output\"\n    )\n    .option(\"-p, --prettier <path>\", \"Prettier config path that will be used to format the output client file\")\n    .option(\"-b, --base-url <url>\", \"Base url for the api\")\n    .option(\"--no-with-alias\", \"Disable alias as api client methods\")\n    .option(\"-a, --with-alias\", \"With alias as api client methods\", true)\n    .option(\n        \"--api-client-name <name>\",\n        \"when using the default `template.hbs`, allow customizing the `export const {apiClientName}`\"\n    )\n    .option(\"--error-expr <expr>\", \"Pass an expression to determine if a response status is an error\")\n    .option(\"--success-expr <expr>\", \"Pass an expression to determine which response status is the main success status\")\n    .option(\"--media-type-expr <expr>\", \"Pass an expression to determine which response content should be allowed\")\n    .option(\"--export-schemas\", \"When true, will export all `#/components/schemas`\")\n    .option(\n        \"--implicit-required\",\n        \"When true, will make all properties of an object required by default (rather than the current opposite), unless an explicitly `required` array is set\"\n    )\n    .option(\"--with-deprecated\", \"when true, will keep deprecated endpoints in the api output\")\n    .option(\"--with-description\", \"when true, will add z.describe(xxx)\")\n    .option(\"--with-docs\", \"when true, will add jsdoc comments to generated types\")\n    .option(\n        \"--group-strategy <strategy>\",\n        \"groups endpoints by a given strategy, possible values are: 'none' | 'tag' | 'method' | 'tag-file' | 'method-file'\"\n    )\n    .option(\n        \"--complexity-threshold <number>\",\n        \"schema complexity threshold to determine which one (using less than `<` operator) should be assigned to a variable\"\n    )\n    .option(\n        \"--default-status <behavior>\",\n        \"when defined as `auto-correct`, will automatically use `default` as fallback for `response` when no status code was declared\"\n    )\n    .option(\"--all-readonly\", \"when true, all generated objects and arrays will be readonly\")\n    .option(\"--export-types\", \"When true, will defined types for all object schemas in `#/components/schemas`\")\n    .option(\n        \"--additional-props-default-value [value]\",\n        \"Set default value when additionalProperties is not provided. Default to true.\",\n        true\n    )\n    .option(\n        \"--strict-objects [value]\",\n        \"Use strict validation for objects so we don't allow unknown keys. Defaults to false.\",\n        false\n    )\n    .action(async (input: string, options: CliOptions) => {\n        console.log(\"Retrieving OpenAPI document from\", input);\n        // SwaggerParser uses its own OpenAPI types, cast to openapi3-ts types\n        const openApiDoc = (await SwaggerParser.bundle(input)) as unknown as OpenAPIObject;\n        const prettierConfig = await resolveConfig(options.prettier ?? \"./\");\n        const distPath = options.output ?? input + \".client.ts\";\n        const withAlias = toBoolean(options.withAlias, true);\n        const additionalPropertiesDefaultValue = toBoolean(options.additionalPropsDefaultValue, true);\n\n        // Parse and validate CLI options\n        const groupStrategy = options.groupStrategy as\n            | \"none\"\n            | \"tag\"\n            | \"method\"\n            | \"tag-file\"\n            | \"method-file\"\n            | undefined;\n        const complexityThreshold =\n            options.complexityThreshold !== undefined ? parseInt(options.complexityThreshold, 10) : undefined;\n        const defaultStatusBehavior = options.defaultStatus as \"spec-compliant\" | \"auto-correct\" | undefined;\n\n        // Build generation options (for exactOptionalPropertyTypes: only include defined values)\n        const generationOptions: Record<string, unknown> = {\n            withAlias,\n            additionalPropertiesDefaultValue,\n        };\n\n        if (options.baseUrl) generationOptions[\"baseUrl\"] = options.baseUrl;\n        if (options.apiClientName) generationOptions[\"apiClientName\"] = options.apiClientName;\n        if (options.errorExpr) generationOptions[\"isErrorStatus\"] = options.errorExpr;\n        if (options.successExpr) generationOptions[\"isMainResponseStatus\"] = options.successExpr;\n        if (options.exportSchemas) generationOptions[\"shouldExportAllSchemas\"] = options.exportSchemas;\n        if (options.exportTypes) generationOptions[\"shouldExportAllTypes\"] = options.exportTypes;\n        if (options.mediaTypeExpr) generationOptions[\"isMediaTypeAllowed\"] = options.mediaTypeExpr;\n        if (options.implicitRequired) generationOptions[\"withImplicitRequiredProps\"] = options.implicitRequired;\n        if (options.withDeprecated) generationOptions[\"withDeprecatedEndpoints\"] = options.withDeprecated;\n        if (options.withDocs) generationOptions[\"withDocs\"] = options.withDocs;\n        if (groupStrategy) generationOptions[\"groupStrategy\"] = groupStrategy;\n        if (complexityThreshold !== undefined) generationOptions[\"complexityThreshold\"] = complexityThreshold;\n        if (defaultStatusBehavior) generationOptions[\"defaultStatusBehavior\"] = defaultStatusBehavior;\n        if (options.withDescription) generationOptions[\"withDescription\"] = options.withDescription;\n        if (options.allReadonly) generationOptions[\"allReadonly\"] = options.allReadonly;\n        if (options.strictObjects) generationOptions[\"strictObjects\"] = options.strictObjects;\n\n        // Build generation args (only include defined properties)\n        // Using Record<string, unknown> to dynamically build options from CLI\n        // Type assertion is safe because we're matching the expected structure\n        const generationArgs: Record<string, unknown> = {\n            openApiDoc,\n            distPath,\n            options: generationOptions,\n        };\n\n        if (prettierConfig) generationArgs[\"prettierConfig\"] = prettierConfig;\n        if (options.template) generationArgs[\"templatePath\"] = options.template;\n\n        await generateZodClientFromOpenAPI(generationArgs as Parameters<typeof generateZodClientFromOpenAPI>[0]);\n        console.log(`Done generating <${distPath}> !`);\n    });\n\nprogram.parse();\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/enumHelpers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/enumHelpers.ts","messages":[],"suppressedMessages":[{"ruleId":"sonarjs/function-return-type","severity":2,"message":"Refactor this function to always return the same type.","line":38,"column":17,"nodeType":null,"endLine":38,"endColumn":47,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/generateJSDocArray.ts","messages":[{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":34,"column":29,"nodeType":"TSAsExpression","messageId":"never","endLine":34,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { SchemaObject } from \"openapi3-ts\";\n\ntype MappingValue = string | string[] | undefined;\n\nexport default function generateJSDocArray(schema: SchemaObject, withTypesAndFormat = false): string[] {\n    const comments: string[] = [];\n\n    // Helper to safely add a comment from a schema property\n    const addComment = (key: keyof SchemaObject, formatter: (value: unknown) => MappingValue): void => {\n        const value: unknown = schema[key];\n        if (value !== undefined) {\n            const result = formatter(value);\n            if (Array.isArray(result)) {\n                result.forEach((subResult) => comments.push(subResult));\n            } else if (result) {\n                comments.push(result);\n            }\n        }\n    };\n\n    // Process each schema property\n    addComment(\"description\", (value) => String(value));\n    addComment(\"example\", (value) => `@example ${JSON.stringify(value)}`);\n    addComment(\"examples\", (value) => {\n        if (Array.isArray(value)) {\n            return value.map((example, index) => `@example Example ${index + 1}: ${JSON.stringify(example)}`);\n        }\n        return undefined;\n    });\n    addComment(\"deprecated\", (value) => (value ? \"@deprecated\" : \"\"));\n    addComment(\"default\", (value) => `@default ${JSON.stringify(value)}`);\n    addComment(\"externalDocs\", (value) => {\n        if (value && typeof value === \"object\" && \"url\" in value) {\n            return `@see ${(value as { url: string }).url}`;\n        }\n        return undefined;\n    });\n\n    if (withTypesAndFormat) {\n        addComment(\"type\", (value) => {\n            if (typeof value === \"string\") {\n                return `@type {${value}}`;\n            }\n            if (Array.isArray(value)) {\n                return `@type {${value.join(\"|\")}}`;\n            }\n            return undefined;\n        });\n        addComment(\"format\", (value) => (typeof value === \"string\" ? `@format ${value}` : undefined));\n    }\n\n    addComment(\"minimum\", (value) => `@minimum ${String(value)}`);\n    addComment(\"maximum\", (value) => `@maximum ${String(value)}`);\n    addComment(\"minLength\", (value) => `@minLength ${String(value)}`);\n    addComment(\"maxLength\", (value) => `@maxLength ${String(value)}`);\n    addComment(\"pattern\", (value) => `@pattern ${String(value)}`);\n    addComment(\"enum\", (value) => {\n        if (Array.isArray(value)) {\n            return `@enum ${value.join(\", \")}`;\n        }\n        return undefined;\n    });\n\n    // Add a space line after description if there are other comments\n    if (comments.length > 1 && !!schema.description) {\n        comments.splice(1, 0, \"\");\n    }\n\n    return comments;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/generateZodClientFromOpenAPI.test.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":13,"column":46,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":13,"endColumn":48,"suggestions":[{"messageId":"removeAsync","fix":{"range":[567,573],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"sonarjs/different-types-comparison","severity":2,"message":"Remove this \"!==\" check; it will always be true. Did you mean to use \"!=\"?","line":3472,"column":62,"nodeType":null,"endLine":3472,"endColumn":65,"suggestions":[{"desc":"Replace \"!==\" with \"!=\"","fix":{"range":[111520,111523],"text":"!="}}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":4008,"column":63,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":4008,"endColumn":65,"suggestions":[{"messageId":"removeAsync","fix":{"range":[128900,128906],"text":""},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import SwaggerParser from \"@apidevtools/swagger-parser\";\nimport type { OpenAPIObject, SchemasObject } from \"openapi3-ts\";\nimport { beforeAll, describe, expect, test } from \"vitest\";\nimport { generateZodClientFromOpenAPI } from \"./generateZodClientFromOpenAPI.js\";\nimport { getZodClientTemplateContext } from \"./template-context.js\";\nimport { pathToVariableName } from \"./utils.js\";\n\nlet openApiDoc: OpenAPIObject;\nbeforeAll(async () => {\n    openApiDoc = (await SwaggerParser.parse(\"./tests/petstore.yaml\")) as OpenAPIObject;\n});\n\ntest(\"getZodClientTemplateContext\", async () => {\n    const result = getZodClientTemplateContext(openApiDoc);\n    expect(result).toMatchInlineSnapshot(`\n      {\n          \"circularTypeByName\": {},\n          \"emittedType\": {},\n          \"endpoints\": [\n              {\n                  \"description\": \"Update an existing pet by Id\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Pet not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                      {\n                          \"description\": \"Validation exception\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"put\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Update an existent pet in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"Pet\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/pet\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n              {\n                  \"description\": \"Add a new pet to the store\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid input\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Create a new pet in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"Pet\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/pet\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n              {\n                  \"description\": \"Returns a single pet\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Pet not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid input\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                      {\n                          \"name\": \"name\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                      {\n                          \"name\": \"status\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"delete a pet\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid pet value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"delete\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"api_key\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Header\",\n                      },\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"\",\n                          \"name\": \"body\",\n                          \"schema\": \"z.instanceof(File)\",\n                          \"type\": \"Body\",\n                      },\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                      {\n                          \"name\": \"additionalMetadata\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId/uploadImage\",\n                  \"requestFormat\": \"binary\",\n                  \"response\": \"ApiResponse\",\n              },\n              {\n                  \"description\": \"Multiple status values can be provided with comma separated strings\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid status value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"status\",\n                          \"schema\": \"z.enum([\"available\", \"pending\", \"sold\"]).optional().default(\"available\")\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/findByStatus\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.array(Pet)\",\n              },\n              {\n                  \"description\": \"Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid tag value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"tags\",\n                          \"schema\": \"z.array(z.string()).optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/findByTags\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.array(Pet)\",\n              },\n              {\n                  \"description\": \"Returns a map of status codes to quantities\",\n                  \"errors\": [],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/store/inventory\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.record(z.number().int())\",\n              },\n              {\n                  \"description\": \"Place a new order in the store\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid input\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"\",\n                          \"name\": \"body\",\n                          \"schema\": \"Order\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/store/order\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Order\",\n              },\n              {\n                  \"description\": \"For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Order not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"orderId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/store/order/:orderId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Order\",\n              },\n              {\n                  \"description\": \"For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Order not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"delete\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"orderId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/store/order/:orderId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"This can only be done by the logged in user.\",\n                  \"errors\": [],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Created user object\",\n                          \"name\": \"body\",\n                          \"schema\": \"User\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/user\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid username supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"User not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/user/:username\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"User\",\n              },\n              {\n                  \"description\": \"This can only be done by the logged in user.\",\n                  \"errors\": [],\n                  \"method\": \"put\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Update an existent user in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"User\",\n                          \"type\": \"Body\",\n                      },\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/user/:username\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"This can only be done by the logged in user.\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid username supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"User not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"delete\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/user/:username\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"Creates list of users with given input array\",\n                  \"errors\": [],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"\",\n                          \"name\": \"body\",\n                          \"schema\": \"z.array(User)\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/user/createWithList\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"User\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid username/password supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                      {\n                          \"name\": \"password\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/user/login\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.string()\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/user/logout\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n          ],\n          \"endpointsGroups\": {},\n          \"options\": {\n              \"baseUrl\": \"\",\n              \"withAlias\": false,\n          },\n          \"schemas\": {\n              \"ApiResponse\": \"z.object({ code: z.number().int(), type: z.string(), message: z.string() }).partial().passthrough()\",\n              \"Category\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n              \"Order\": \"z.object({ id: z.number().int(), petId: z.number().int(), quantity: z.number().int(), shipDate: z.string().datetime({ offset: true }), status: z.enum([\"placed\", \"approved\", \"delivered\"]), complete: z.boolean() }).partial().passthrough()\",\n              \"Pet\": \"z.object({ id: z.number().int().optional(), name: z.string(), category: Category.optional(), photoUrls: z.array(z.string()), tags: z.array(Tag).optional(), status: z.enum([\"available\", \"pending\", \"sold\"]).optional() }).passthrough()\",\n              \"Tag\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n              \"User\": \"z.object({ id: z.number().int(), username: z.string(), firstName: z.string(), lastName: z.string(), email: z.string(), password: z.string(), phone: z.string(), userStatus: z.number().int() }).partial().passthrough()\",\n          },\n          \"types\": {},\n      }\n    `);\n});\n\ndescribe(\"generateZodClientFromOpenAPI\", () => {\n    test(\"without options\", async () => {\n        const prettyOutput = await generateZodClientFromOpenAPI({ openApiDoc, disableWriteToFile: true });\n        expect(prettyOutput).toMatchInlineSnapshot(`\n          \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const Category = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Tag = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Pet = z\n            .object({\n              id: z.number().int().optional(),\n              name: z.string(),\n              category: Category.optional(),\n              photoUrls: z.array(z.string()),\n              tags: z.array(Tag).optional(),\n              status: z.enum([\"available\", \"pending\", \"sold\"]).optional(),\n            })\n            .passthrough();\n          const ApiResponse = z\n            .object({ code: z.number().int(), type: z.string(), message: z.string() })\n            .partial()\n            .passthrough();\n          const Order = z\n            .object({\n              id: z.number().int(),\n              petId: z.number().int(),\n              quantity: z.number().int(),\n              shipDate: z.string().datetime({ offset: true }),\n              status: z.enum([\"placed\", \"approved\", \"delivered\"]),\n              complete: z.boolean(),\n            })\n            .partial()\n            .passthrough();\n          const User = z\n            .object({\n              id: z.number().int(),\n              username: z.string(),\n              firstName: z.string(),\n              lastName: z.string(),\n              email: z.string(),\n              password: z.string(),\n              phone: z.string(),\n              userStatus: z.number().int(),\n            })\n            .partial()\n            .passthrough();\n\n          export const schemas = {\n            Category,\n            Tag,\n            Pet,\n            ApiResponse,\n            Order,\n            User,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"put\",\n              path: \"/pet\",\n              description: \\`Update an existing pet by Id\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 405,\n                  description: \\`Validation exception\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet\",\n              description: \\`Add a new pet to the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Create a new pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/:petId\",\n              description: \\`Returns a single pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"name\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/pet/:petId\",\n              description: \\`delete a pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"api_key\",\n                  type: \"Header\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid pet value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId/uploadImage\",\n              requestFormat: \"binary\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.instanceof(File),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"additionalMetadata\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: ApiResponse,\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByStatus\",\n              description: \\`Multiple status values can be provided with comma separated strings\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z\n                    .enum([\"available\", \"pending\", \"sold\"])\n                    .optional()\n                    .default(\"available\"),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid status value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByTags\",\n              description: \\`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"tags\",\n                  type: \"Query\",\n                  schema: z.array(z.string()).optional(),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid tag value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/inventory\",\n              description: \\`Returns a map of status codes to quantities\\`,\n              requestFormat: \"json\",\n              response: z.record(z.number().int()),\n            },\n            {\n              method: \"post\",\n              path: \"/store/order\",\n              description: \\`Place a new order in the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: Order,\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/order/:orderId\",\n              description: \\`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/store/order/:orderId\",\n              description: \\`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Created user object\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"get\",\n              path: \"/user/:username\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: User,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"put\",\n              path: \"/user/:username\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent user in the store\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"delete\",\n              path: \"/user/:username\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user/createWithList\",\n              description: \\`Creates list of users with given input array\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.array(User),\n                },\n              ],\n              response: User,\n            },\n            {\n              method: \"get\",\n              path: \"/user/login\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"password\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.string(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username/password supplied\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/user/logout\",\n              requestFormat: \"json\",\n              response: z.void(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \"\n        `);\n    });\n\n    test(\"withAlias as true\", async () => {\n        const prettyOutput = await generateZodClientFromOpenAPI({\n            openApiDoc,\n            disableWriteToFile: true,\n            options: { withAlias: true },\n        });\n        expect(prettyOutput).toMatchInlineSnapshot(`\n          \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const Category = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Tag = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Pet = z\n            .object({\n              id: z.number().int().optional(),\n              name: z.string(),\n              category: Category.optional(),\n              photoUrls: z.array(z.string()),\n              tags: z.array(Tag).optional(),\n              status: z.enum([\"available\", \"pending\", \"sold\"]).optional(),\n            })\n            .passthrough();\n          const ApiResponse = z\n            .object({ code: z.number().int(), type: z.string(), message: z.string() })\n            .partial()\n            .passthrough();\n          const Order = z\n            .object({\n              id: z.number().int(),\n              petId: z.number().int(),\n              quantity: z.number().int(),\n              shipDate: z.string().datetime({ offset: true }),\n              status: z.enum([\"placed\", \"approved\", \"delivered\"]),\n              complete: z.boolean(),\n            })\n            .partial()\n            .passthrough();\n          const User = z\n            .object({\n              id: z.number().int(),\n              username: z.string(),\n              firstName: z.string(),\n              lastName: z.string(),\n              email: z.string(),\n              password: z.string(),\n              phone: z.string(),\n              userStatus: z.number().int(),\n            })\n            .partial()\n            .passthrough();\n\n          export const schemas = {\n            Category,\n            Tag,\n            Pet,\n            ApiResponse,\n            Order,\n            User,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"put\",\n              path: \"/pet\",\n              alias: \"updatePet\",\n              description: \\`Update an existing pet by Id\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 405,\n                  description: \\`Validation exception\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet\",\n              alias: \"addPet\",\n              description: \\`Add a new pet to the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Create a new pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/:petId\",\n              alias: \"getPetById\",\n              description: \\`Returns a single pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId\",\n              alias: \"updatePetWithForm\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"name\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/pet/:petId\",\n              alias: \"deletePet\",\n              description: \\`delete a pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"api_key\",\n                  type: \"Header\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid pet value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId/uploadImage\",\n              alias: \"uploadFile\",\n              requestFormat: \"binary\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.instanceof(File),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"additionalMetadata\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: ApiResponse,\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByStatus\",\n              alias: \"findPetsByStatus\",\n              description: \\`Multiple status values can be provided with comma separated strings\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z\n                    .enum([\"available\", \"pending\", \"sold\"])\n                    .optional()\n                    .default(\"available\"),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid status value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByTags\",\n              alias: \"findPetsByTags\",\n              description: \\`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"tags\",\n                  type: \"Query\",\n                  schema: z.array(z.string()).optional(),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid tag value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/inventory\",\n              alias: \"getInventory\",\n              description: \\`Returns a map of status codes to quantities\\`,\n              requestFormat: \"json\",\n              response: z.record(z.number().int()),\n            },\n            {\n              method: \"post\",\n              path: \"/store/order\",\n              alias: \"placeOrder\",\n              description: \\`Place a new order in the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: Order,\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/order/:orderId\",\n              alias: \"getOrderById\",\n              description: \\`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/store/order/:orderId\",\n              alias: \"deleteOrder\",\n              description: \\`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user\",\n              alias: \"createUser\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Created user object\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"get\",\n              path: \"/user/:username\",\n              alias: \"getUserByName\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: User,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"put\",\n              path: \"/user/:username\",\n              alias: \"updateUser\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent user in the store\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"delete\",\n              path: \"/user/:username\",\n              alias: \"deleteUser\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user/createWithList\",\n              alias: \"createUsersWithListInput\",\n              description: \\`Creates list of users with given input array\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.array(User),\n                },\n              ],\n              response: User,\n            },\n            {\n              method: \"get\",\n              path: \"/user/login\",\n              alias: \"loginUser\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"password\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.string(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username/password supplied\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/user/logout\",\n              alias: \"logoutUser\",\n              requestFormat: \"json\",\n              response: z.void(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \"\n        `);\n    });\n\n    test(\"withAlias as false\", async () => {\n        const prettyOutput = await generateZodClientFromOpenAPI({\n            openApiDoc,\n            disableWriteToFile: true,\n            options: { withAlias: false },\n        });\n        expect(prettyOutput).toMatchInlineSnapshot(`\n          \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const Category = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Tag = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Pet = z\n            .object({\n              id: z.number().int().optional(),\n              name: z.string(),\n              category: Category.optional(),\n              photoUrls: z.array(z.string()),\n              tags: z.array(Tag).optional(),\n              status: z.enum([\"available\", \"pending\", \"sold\"]).optional(),\n            })\n            .passthrough();\n          const ApiResponse = z\n            .object({ code: z.number().int(), type: z.string(), message: z.string() })\n            .partial()\n            .passthrough();\n          const Order = z\n            .object({\n              id: z.number().int(),\n              petId: z.number().int(),\n              quantity: z.number().int(),\n              shipDate: z.string().datetime({ offset: true }),\n              status: z.enum([\"placed\", \"approved\", \"delivered\"]),\n              complete: z.boolean(),\n            })\n            .partial()\n            .passthrough();\n          const User = z\n            .object({\n              id: z.number().int(),\n              username: z.string(),\n              firstName: z.string(),\n              lastName: z.string(),\n              email: z.string(),\n              password: z.string(),\n              phone: z.string(),\n              userStatus: z.number().int(),\n            })\n            .partial()\n            .passthrough();\n\n          export const schemas = {\n            Category,\n            Tag,\n            Pet,\n            ApiResponse,\n            Order,\n            User,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"put\",\n              path: \"/pet\",\n              description: \\`Update an existing pet by Id\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 405,\n                  description: \\`Validation exception\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet\",\n              description: \\`Add a new pet to the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Create a new pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/:petId\",\n              description: \\`Returns a single pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"name\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/pet/:petId\",\n              description: \\`delete a pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"api_key\",\n                  type: \"Header\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid pet value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId/uploadImage\",\n              requestFormat: \"binary\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.instanceof(File),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"additionalMetadata\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: ApiResponse,\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByStatus\",\n              description: \\`Multiple status values can be provided with comma separated strings\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z\n                    .enum([\"available\", \"pending\", \"sold\"])\n                    .optional()\n                    .default(\"available\"),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid status value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByTags\",\n              description: \\`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"tags\",\n                  type: \"Query\",\n                  schema: z.array(z.string()).optional(),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid tag value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/inventory\",\n              description: \\`Returns a map of status codes to quantities\\`,\n              requestFormat: \"json\",\n              response: z.record(z.number().int()),\n            },\n            {\n              method: \"post\",\n              path: \"/store/order\",\n              description: \\`Place a new order in the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: Order,\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/order/:orderId\",\n              description: \\`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/store/order/:orderId\",\n              description: \\`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Created user object\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"get\",\n              path: \"/user/:username\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: User,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"put\",\n              path: \"/user/:username\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent user in the store\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"delete\",\n              path: \"/user/:username\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user/createWithList\",\n              description: \\`Creates list of users with given input array\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.array(User),\n                },\n              ],\n              response: User,\n            },\n            {\n              method: \"get\",\n              path: \"/user/login\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"password\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.string(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username/password supplied\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/user/logout\",\n              requestFormat: \"json\",\n              response: z.void(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \"\n        `);\n    });\n\n    test(\"withAlias as a custom function\", async () => {\n        const prettyOutput = await generateZodClientFromOpenAPI({\n            openApiDoc,\n            disableWriteToFile: true,\n            options: {\n                withAlias: (path: string, method: string, operation) =>\n                    path === \"/pet\"\n                        ? method + \"CustomPet\"\n                        : (operation?.operationId ?? method + pathToVariableName(path || \"/noPath\")),\n            },\n        });\n        expect(prettyOutput).toMatchInlineSnapshot(`\n          \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const Category = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Tag = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Pet = z\n            .object({\n              id: z.number().int().optional(),\n              name: z.string(),\n              category: Category.optional(),\n              photoUrls: z.array(z.string()),\n              tags: z.array(Tag).optional(),\n              status: z.enum([\"available\", \"pending\", \"sold\"]).optional(),\n            })\n            .passthrough();\n          const ApiResponse = z\n            .object({ code: z.number().int(), type: z.string(), message: z.string() })\n            .partial()\n            .passthrough();\n          const Order = z\n            .object({\n              id: z.number().int(),\n              petId: z.number().int(),\n              quantity: z.number().int(),\n              shipDate: z.string().datetime({ offset: true }),\n              status: z.enum([\"placed\", \"approved\", \"delivered\"]),\n              complete: z.boolean(),\n            })\n            .partial()\n            .passthrough();\n          const User = z\n            .object({\n              id: z.number().int(),\n              username: z.string(),\n              firstName: z.string(),\n              lastName: z.string(),\n              email: z.string(),\n              password: z.string(),\n              phone: z.string(),\n              userStatus: z.number().int(),\n            })\n            .partial()\n            .passthrough();\n\n          export const schemas = {\n            Category,\n            Tag,\n            Pet,\n            ApiResponse,\n            Order,\n            User,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"put\",\n              path: \"/pet\",\n              alias: \"putCustomPet\",\n              description: \\`Update an existing pet by Id\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 405,\n                  description: \\`Validation exception\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet\",\n              alias: \"postCustomPet\",\n              description: \\`Add a new pet to the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Create a new pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/:petId\",\n              alias: \"getPetById\",\n              description: \\`Returns a single pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId\",\n              alias: \"updatePetWithForm\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"name\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/pet/:petId\",\n              alias: \"deletePet\",\n              description: \\`delete a pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"api_key\",\n                  type: \"Header\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid pet value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId/uploadImage\",\n              alias: \"uploadFile\",\n              requestFormat: \"binary\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.instanceof(File),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"additionalMetadata\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: ApiResponse,\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByStatus\",\n              alias: \"findPetsByStatus\",\n              description: \\`Multiple status values can be provided with comma separated strings\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z\n                    .enum([\"available\", \"pending\", \"sold\"])\n                    .optional()\n                    .default(\"available\"),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid status value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByTags\",\n              alias: \"findPetsByTags\",\n              description: \\`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"tags\",\n                  type: \"Query\",\n                  schema: z.array(z.string()).optional(),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid tag value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/inventory\",\n              alias: \"getInventory\",\n              description: \\`Returns a map of status codes to quantities\\`,\n              requestFormat: \"json\",\n              response: z.record(z.number().int()),\n            },\n            {\n              method: \"post\",\n              path: \"/store/order\",\n              alias: \"placeOrder\",\n              description: \\`Place a new order in the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: Order,\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/order/:orderId\",\n              alias: \"getOrderById\",\n              description: \\`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/store/order/:orderId\",\n              alias: \"deleteOrder\",\n              description: \\`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user\",\n              alias: \"createUser\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Created user object\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"get\",\n              path: \"/user/:username\",\n              alias: \"getUserByName\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: User,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"put\",\n              path: \"/user/:username\",\n              alias: \"updateUser\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent user in the store\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"delete\",\n              path: \"/user/:username\",\n              alias: \"deleteUser\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user/createWithList\",\n              alias: \"createUsersWithListInput\",\n              description: \\`Creates list of users with given input array\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.array(User),\n                },\n              ],\n              response: User,\n            },\n            {\n              method: \"get\",\n              path: \"/user/login\",\n              alias: \"loginUser\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"password\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.string(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username/password supplied\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/user/logout\",\n              alias: \"logoutUser\",\n              requestFormat: \"json\",\n              response: z.void(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \"\n        `);\n    });\n\n    test(\"with baseUrl\", async () => {\n        const prettyOutput = await generateZodClientFromOpenAPI({\n            openApiDoc,\n            disableWriteToFile: true,\n            options: {\n                baseUrl: \"http://example.com\",\n            },\n        });\n        expect(prettyOutput).toMatchInlineSnapshot(`\n          \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const Category = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Tag = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Pet = z\n            .object({\n              id: z.number().int().optional(),\n              name: z.string(),\n              category: Category.optional(),\n              photoUrls: z.array(z.string()),\n              tags: z.array(Tag).optional(),\n              status: z.enum([\"available\", \"pending\", \"sold\"]).optional(),\n            })\n            .passthrough();\n          const ApiResponse = z\n            .object({ code: z.number().int(), type: z.string(), message: z.string() })\n            .partial()\n            .passthrough();\n          const Order = z\n            .object({\n              id: z.number().int(),\n              petId: z.number().int(),\n              quantity: z.number().int(),\n              shipDate: z.string().datetime({ offset: true }),\n              status: z.enum([\"placed\", \"approved\", \"delivered\"]),\n              complete: z.boolean(),\n            })\n            .partial()\n            .passthrough();\n          const User = z\n            .object({\n              id: z.number().int(),\n              username: z.string(),\n              firstName: z.string(),\n              lastName: z.string(),\n              email: z.string(),\n              password: z.string(),\n              phone: z.string(),\n              userStatus: z.number().int(),\n            })\n            .partial()\n            .passthrough();\n\n          export const schemas = {\n            Category,\n            Tag,\n            Pet,\n            ApiResponse,\n            Order,\n            User,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"put\",\n              path: \"/pet\",\n              description: \\`Update an existing pet by Id\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 405,\n                  description: \\`Validation exception\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet\",\n              description: \\`Add a new pet to the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Create a new pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/:petId\",\n              description: \\`Returns a single pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"name\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/pet/:petId\",\n              description: \\`delete a pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"api_key\",\n                  type: \"Header\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid pet value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId/uploadImage\",\n              requestFormat: \"binary\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.instanceof(File),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"additionalMetadata\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: ApiResponse,\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByStatus\",\n              description: \\`Multiple status values can be provided with comma separated strings\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z\n                    .enum([\"available\", \"pending\", \"sold\"])\n                    .optional()\n                    .default(\"available\"),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid status value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByTags\",\n              description: \\`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"tags\",\n                  type: \"Query\",\n                  schema: z.array(z.string()).optional(),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid tag value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/inventory\",\n              description: \\`Returns a map of status codes to quantities\\`,\n              requestFormat: \"json\",\n              response: z.record(z.number().int()),\n            },\n            {\n              method: \"post\",\n              path: \"/store/order\",\n              description: \\`Place a new order in the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: Order,\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/order/:orderId\",\n              description: \\`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/store/order/:orderId\",\n              description: \\`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Created user object\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"get\",\n              path: \"/user/:username\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: User,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"put\",\n              path: \"/user/:username\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent user in the store\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"delete\",\n              path: \"/user/:username\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user/createWithList\",\n              description: \\`Creates list of users with given input array\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.array(User),\n                },\n              ],\n              response: User,\n            },\n            {\n              method: \"get\",\n              path: \"/user/login\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"password\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.string(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username/password supplied\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/user/logout\",\n              requestFormat: \"json\",\n              response: z.void(),\n            },\n          ]);\n\n          export const api = new Zodios(\"http://example.com\", endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \"\n        `);\n    });\n\n    test(\"without default values\", async () => {\n        const prettyOutput = await generateZodClientFromOpenAPI({\n            openApiDoc,\n            disableWriteToFile: true,\n            options: {\n                withDefaultValues: false,\n            },\n        });\n        expect(prettyOutput).toMatchInlineSnapshot(`\n          \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const Category = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Tag = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Pet = z\n            .object({\n              id: z.number().int().optional(),\n              name: z.string(),\n              category: Category.optional(),\n              photoUrls: z.array(z.string()),\n              tags: z.array(Tag).optional(),\n              status: z.enum([\"available\", \"pending\", \"sold\"]).optional(),\n            })\n            .passthrough();\n          const ApiResponse = z\n            .object({ code: z.number().int(), type: z.string(), message: z.string() })\n            .partial()\n            .passthrough();\n          const Order = z\n            .object({\n              id: z.number().int(),\n              petId: z.number().int(),\n              quantity: z.number().int(),\n              shipDate: z.string().datetime({ offset: true }),\n              status: z.enum([\"placed\", \"approved\", \"delivered\"]),\n              complete: z.boolean(),\n            })\n            .partial()\n            .passthrough();\n          const User = z\n            .object({\n              id: z.number().int(),\n              username: z.string(),\n              firstName: z.string(),\n              lastName: z.string(),\n              email: z.string(),\n              password: z.string(),\n              phone: z.string(),\n              userStatus: z.number().int(),\n            })\n            .partial()\n            .passthrough();\n\n          export const schemas = {\n            Category,\n            Tag,\n            Pet,\n            ApiResponse,\n            Order,\n            User,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"put\",\n              path: \"/pet\",\n              description: \\`Update an existing pet by Id\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 405,\n                  description: \\`Validation exception\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet\",\n              description: \\`Add a new pet to the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Create a new pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/:petId\",\n              description: \\`Returns a single pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"name\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/pet/:petId\",\n              description: \\`delete a pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"api_key\",\n                  type: \"Header\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid pet value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId/uploadImage\",\n              requestFormat: \"binary\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.instanceof(File),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"additionalMetadata\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: ApiResponse,\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByStatus\",\n              description: \\`Multiple status values can be provided with comma separated strings\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z.enum([\"available\", \"pending\", \"sold\"]).optional(),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid status value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByTags\",\n              description: \\`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"tags\",\n                  type: \"Query\",\n                  schema: z.array(z.string()).optional(),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid tag value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/inventory\",\n              description: \\`Returns a map of status codes to quantities\\`,\n              requestFormat: \"json\",\n              response: z.record(z.number().int()),\n            },\n            {\n              method: \"post\",\n              path: \"/store/order\",\n              description: \\`Place a new order in the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: Order,\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/store/order/:orderId\",\n              description: \\`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Order,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/store/order/:orderId\",\n              description: \\`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"orderId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Order not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Created user object\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"get\",\n              path: \"/user/:username\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: User,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"put\",\n              path: \"/user/:username\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent user in the store\\`,\n                  type: \"Body\",\n                  schema: User,\n                },\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"delete\",\n              path: \"/user/:username\",\n              description: \\`This can only be done by the logged in user.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`User not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/user/createWithList\",\n              description: \\`Creates list of users with given input array\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.array(User),\n                },\n              ],\n              response: User,\n            },\n            {\n              method: \"get\",\n              path: \"/user/login\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"password\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.string(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid username/password supplied\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/user/logout\",\n              requestFormat: \"json\",\n              response: z.void(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \"\n        `);\n    });\n\n    test(\"with tag-file groupStrategy\", async () => {\n        const prettyOutput = await generateZodClientFromOpenAPI({\n            openApiDoc,\n            disableWriteToFile: true,\n            options: { groupStrategy: \"tag-file\" },\n        });\n        if (typeof prettyOutput === \"object\" && prettyOutput !== null) {\n            expect(prettyOutput[\"pet\"]).toMatchInlineSnapshot(`\n          \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const Category = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Tag = z\n            .object({ id: z.number().int(), name: z.string() })\n            .partial()\n            .passthrough();\n          const Pet = z\n            .object({\n              id: z.number().int().optional(),\n              name: z.string(),\n              category: Category.optional(),\n              photoUrls: z.array(z.string()),\n              tags: z.array(Tag).optional(),\n              status: z.enum([\"available\", \"pending\", \"sold\"]).optional(),\n            })\n            .passthrough();\n          const ApiResponse = z\n            .object({ code: z.number().int(), type: z.string(), message: z.string() })\n            .partial()\n            .passthrough();\n\n          export const schemas = {\n            Category,\n            Tag,\n            Pet,\n            ApiResponse,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"put\",\n              path: \"/pet\",\n              description: \\`Update an existing pet by Id\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Update an existent pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 405,\n                  description: \\`Validation exception\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet\",\n              description: \\`Add a new pet to the store\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Create a new pet in the store\\`,\n                  type: \"Body\",\n                  schema: Pet,\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByStatus\",\n              description: \\`Multiple status values can be provided with comma separated strings\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z\n                    .enum([\"available\", \"pending\", \"sold\"])\n                    .optional()\n                    .default(\"available\"),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid status value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/findByTags\",\n              description: \\`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"tags\",\n                  type: \"Query\",\n                  schema: z.array(z.string()).optional(),\n                },\n              ],\n              response: z.array(Pet),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid tag value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"get\",\n              path: \"/pet/:petId\",\n              description: \\`Returns a single pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Pet,\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid ID supplied\\`,\n                  schema: z.void(),\n                },\n                {\n                  status: 404,\n                  description: \\`Pet not found\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"name\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"status\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 405,\n                  description: \\`Invalid input\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"delete\",\n              path: \"/pet/:petId\",\n              description: \\`delete a pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"api_key\",\n                  type: \"Header\",\n                  schema: z.string().optional(),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n              errors: [\n                {\n                  status: 400,\n                  description: \\`Invalid pet value\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/pet/:petId/uploadImage\",\n              requestFormat: \"binary\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: z.instanceof(File),\n                },\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n                {\n                  name: \"additionalMetadata\",\n                  type: \"Query\",\n                  schema: z.string().optional(),\n                },\n              ],\n              response: ApiResponse,\n            },\n          ]);\n\n          export const PetApi = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \"\n        `);\n        }\n    });\n});\n\ntest(\"with optional, partial, all required objects\", async () => {\n    const schemas = {\n        Root2: {\n            type: \"object\",\n            properties: {\n                str: { type: \"string\" },\n                nb: { type: \"number\" },\n                nested: { $ref: \"#/components/schemas/Nested2\" },\n                partial: { $ref: \"#/components/schemas/PartialObject\" },\n                optionalProp: { type: \"string\" },\n            },\n            required: [\"str\", \"nb\", \"nested\"],\n        },\n        Nested2: {\n            type: \"object\",\n            properties: {\n                nested_prop: { type: \"boolean\" },\n                deeplyNested: { $ref: \"#/components/schemas/DeeplyNested\" },\n                circularToRoot: { $ref: \"#/components/schemas/Root2\" },\n                requiredProp: { type: \"string\" },\n            },\n            required: [\"requiredProp\"],\n        },\n        PartialObject: {\n            type: \"object\",\n            properties: {\n                something: { type: \"string\" },\n                another: { type: \"number\" },\n            },\n        },\n        DeeplyNested: {\n            type: \"array\",\n            items: { $ref: \"#/components/schemas/VeryDeeplyNested\" },\n        },\n        VeryDeeplyNested: {\n            type: \"string\",\n            enum: [\"aaa\", \"bbb\", \"ccc\"],\n        },\n    } as SchemasObject;\n    const openApiDoc = {\n        openapi: \"3.0.3\",\n        info: { title: \"Swagger Petstore - OpenAPI 3.0\", version: \"1.0.11\" },\n        paths: {\n            \"/root\": {\n                get: {\n                    operationId: \"getRoot\",\n                    responses: {\n                        \"200\": { description: \"OK\", content: { \"application/json\": { schema: schemas[\"Root2\"] } } },\n                    },\n                },\n            },\n            \"/nested\": {\n                get: {\n                    operationId: \"getNested\",\n                    responses: {\n                        \"200\": { description: \"OK\", content: { \"application/json\": { schema: schemas[\"Nested2\"] } } },\n                    },\n                },\n            },\n            \"/deeplyNested\": {\n                get: {\n                    operationId: \"getDeeplyNested\",\n                    responses: {\n                        \"200\": {\n                            description: \"OK\",\n                            content: { \"application/json\": { schema: schemas[\"DeeplyNested\"] } },\n                        },\n                    },\n                },\n            },\n            \"/veryDeeplyNested\": {\n                get: {\n                    operationId: \"getVeryDeeplyNested\",\n                    responses: {\n                        \"200\": {\n                            description: \"OK\",\n                            content: { \"application/json\": { schema: schemas[\"VeryDeeplyNested\"] } },\n                        },\n                    },\n                },\n            },\n        },\n        components: { schemas },\n    };\n\n    const data = getZodClientTemplateContext(openApiDoc);\n\n    expect(data).toMatchInlineSnapshot(`\n      {\n          \"circularTypeByName\": {\n              \"Nested2\": true,\n              \"Root2\": true,\n          },\n          \"emittedType\": {\n              \"Nested2\": true,\n              \"Root2\": true,\n          },\n          \"endpoints\": [\n              {\n                  \"description\": undefined,\n                  \"errors\": [],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/deeplyNested\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.array(VeryDeeplyNested)\",\n              },\n              {\n                  \"description\": undefined,\n                  \"errors\": [],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/nested\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.object({ nested_prop: z.boolean().optional(), deeplyNested: DeeplyNested.optional(), circularToRoot: Root2.optional(), requiredProp: z.string() }).passthrough()\",\n              },\n              {\n                  \"description\": undefined,\n                  \"errors\": [],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/root\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.object({ str: z.string(), nb: z.number(), nested: Nested2, partial: PartialObject.optional(), optionalProp: z.string().optional() }).passthrough()\",\n              },\n              {\n                  \"description\": undefined,\n                  \"errors\": [],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/veryDeeplyNested\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.enum([\"aaa\", \"bbb\", \"ccc\"])\",\n              },\n          ],\n          \"endpointsGroups\": {},\n          \"options\": {\n              \"baseUrl\": \"\",\n              \"withAlias\": false,\n          },\n          \"schemas\": {\n              \"DeeplyNested\": \"z.array(VeryDeeplyNested)\",\n              \"Nested2\": \"z.lazy(() => z.object({ nested_prop: z.boolean().optional(), deeplyNested: DeeplyNested.optional(), circularToRoot: Root2.optional(), requiredProp: z.string() }).passthrough())\",\n              \"PartialObject\": \"z.object({ something: z.string(), another: z.number() }).partial().passthrough()\",\n              \"Root2\": \"z.lazy(() => z.object({ str: z.string(), nb: z.number(), nested: Nested2, partial: PartialObject.optional(), optionalProp: z.string().optional() }).passthrough())\",\n              \"VeryDeeplyNested\": \"z.enum([\"aaa\", \"bbb\", \"ccc\"])\",\n          },\n          \"types\": {\n              \"DeeplyNested\": \"type DeeplyNested = Array<VeryDeeplyNested>;\",\n              \"Nested2\": \"type Nested2 = {\n          nested_prop?: boolean | undefined;\n          deeplyNested?: DeeplyNested | undefined;\n          circularToRoot?: Root2 | undefined;\n          requiredProp: string;\n      };\",\n              \"PartialObject\": \"type PartialObject = Partial<{\n          something: string;\n          another: number;\n      }>;\",\n              \"Root2\": \"type Root2 = {\n          str: string;\n          nb: number;\n          nested: Nested2;\n          partial?: PartialObject | undefined;\n          optionalProp?: string | undefined;\n      };\",\n              \"VeryDeeplyNested\": \"type VeryDeeplyNested = \"aaa\" | \"bbb\" | \"ccc\";\",\n          },\n      }\n    `);\n\n    const prettyOutput = await generateZodClientFromOpenAPI({ openApiDoc, disableWriteToFile: true });\n    expect(prettyOutput).toMatchInlineSnapshot(`\n      \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n      import { z } from \"zod\";\n\n      type Root2 = {\n        str: string;\n        nb: number;\n        nested: Nested2;\n        partial?: PartialObject | undefined;\n        optionalProp?: string | undefined;\n      };\n      type DeeplyNested = Array<VeryDeeplyNested>;\n      type VeryDeeplyNested = \"aaa\" | \"bbb\" | \"ccc\";\n      type PartialObject = Partial<{\n        something: string;\n        another: number;\n      }>;\n      type Nested2 = {\n        nested_prop?: boolean | undefined;\n        deeplyNested?: DeeplyNested | undefined;\n        circularToRoot?: Root2 | undefined;\n        requiredProp: string;\n      };\n\n      const VeryDeeplyNested = z.enum([\"aaa\", \"bbb\", \"ccc\"]);\n      const DeeplyNested = z.array(VeryDeeplyNested);\n      const PartialObject = z\n        .object({ something: z.string(), another: z.number() })\n        .partial()\n        .passthrough();\n      const Root2: z.ZodType<Root2> = z.lazy(() =>\n        z\n          .object({\n            str: z.string(),\n            nb: z.number(),\n            nested: Nested2,\n            partial: PartialObject.optional(),\n            optionalProp: z.string().optional(),\n          })\n          .passthrough(),\n      );\n      const Nested2: z.ZodType<Nested2> = z.lazy(() =>\n        z\n          .object({\n            nested_prop: z.boolean().optional(),\n            deeplyNested: DeeplyNested.optional(),\n            circularToRoot: Root2.optional(),\n            requiredProp: z.string(),\n          })\n          .passthrough(),\n      );\n\n      export const schemas = {\n        VeryDeeplyNested,\n        DeeplyNested,\n        PartialObject,\n        Root2,\n        Nested2,\n      };\n\n      const endpoints = makeApi([\n        {\n          method: \"get\",\n          path: \"/deeplyNested\",\n          requestFormat: \"json\",\n          response: z.array(VeryDeeplyNested),\n        },\n        {\n          method: \"get\",\n          path: \"/nested\",\n          requestFormat: \"json\",\n          response: z\n            .object({\n              nested_prop: z.boolean().optional(),\n              deeplyNested: DeeplyNested.optional(),\n              circularToRoot: Root2.optional(),\n              requiredProp: z.string(),\n            })\n            .passthrough(),\n        },\n        {\n          method: \"get\",\n          path: \"/root\",\n          requestFormat: \"json\",\n          response: z\n            .object({\n              str: z.string(),\n              nb: z.number(),\n              nested: Nested2,\n              partial: PartialObject.optional(),\n              optionalProp: z.string().optional(),\n            })\n            .passthrough(),\n        },\n        {\n          method: \"get\",\n          path: \"/veryDeeplyNested\",\n          requestFormat: \"json\",\n          response: z.enum([\"aaa\", \"bbb\", \"ccc\"]),\n        },\n      ]);\n\n      export const api = new Zodios(endpoints);\n\n      export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n        return new Zodios(baseUrl, endpoints, options);\n      }\n      \"\n    `);\n});\n\ntest(\"getZodClientTemplateContext with allReadonly\", async () => {\n    const result = getZodClientTemplateContext(openApiDoc, {\n        allReadonly: true,\n    });\n    expect(result).toMatchInlineSnapshot(`\n      {\n          \"circularTypeByName\": {},\n          \"emittedType\": {},\n          \"endpoints\": [\n              {\n                  \"description\": \"Update an existing pet by Id\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Pet not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                      {\n                          \"description\": \"Validation exception\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"put\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Update an existent pet in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"Pet\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/pet\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n              {\n                  \"description\": \"Add a new pet to the store\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid input\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Create a new pet in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"Pet\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/pet\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n              {\n                  \"description\": \"Returns a single pet\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Pet not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid input\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                      {\n                          \"name\": \"name\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                      {\n                          \"name\": \"status\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"delete a pet\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid pet value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"delete\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"api_key\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Header\",\n                      },\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"\",\n                          \"name\": \"body\",\n                          \"schema\": \"z.instanceof(File)\",\n                          \"type\": \"Body\",\n                      },\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                      {\n                          \"name\": \"additionalMetadata\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId/uploadImage\",\n                  \"requestFormat\": \"binary\",\n                  \"response\": \"ApiResponse\",\n              },\n              {\n                  \"description\": \"Multiple status values can be provided with comma separated strings\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid status value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"status\",\n                          \"schema\": \"z.enum([\"available\", \"pending\", \"sold\"]).optional().default(\"available\")\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/findByStatus\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.array(Pet).readonly()\",\n              },\n              {\n                  \"description\": \"Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid tag value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"tags\",\n                          \"schema\": \"z.array(z.string()).readonly().optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/findByTags\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.array(Pet).readonly()\",\n              },\n              {\n                  \"description\": \"Returns a map of status codes to quantities\",\n                  \"errors\": [],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/store/inventory\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.record(z.number().int())\",\n              },\n              {\n                  \"description\": \"Place a new order in the store\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid input\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"\",\n                          \"name\": \"body\",\n                          \"schema\": \"Order\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/store/order\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Order\",\n              },\n              {\n                  \"description\": \"For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Order not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"orderId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/store/order/:orderId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Order\",\n              },\n              {\n                  \"description\": \"For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Order not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"delete\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"orderId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/store/order/:orderId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"This can only be done by the logged in user.\",\n                  \"errors\": [],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Created user object\",\n                          \"name\": \"body\",\n                          \"schema\": \"User\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/user\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid username supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"User not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/user/:username\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"User\",\n              },\n              {\n                  \"description\": \"This can only be done by the logged in user.\",\n                  \"errors\": [],\n                  \"method\": \"put\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Update an existent user in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"User\",\n                          \"type\": \"Body\",\n                      },\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/user/:username\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"This can only be done by the logged in user.\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid username supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"User not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"delete\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/user/:username\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"Creates list of users with given input array\",\n                  \"errors\": [],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"\",\n                          \"name\": \"body\",\n                          \"schema\": \"z.array(User).readonly()\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/user/createWithList\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"User\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid username/password supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                      {\n                          \"name\": \"password\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/user/login\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.string()\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/user/logout\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n          ],\n          \"endpointsGroups\": {},\n          \"options\": {\n              \"baseUrl\": \"\",\n              \"withAlias\": false,\n          },\n          \"schemas\": {\n              \"ApiResponse\": \"z.object({ code: z.number().int(), type: z.string(), message: z.string() }).partial().passthrough().readonly()\",\n              \"Category\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough().readonly()\",\n              \"Order\": \"z.object({ id: z.number().int(), petId: z.number().int(), quantity: z.number().int(), shipDate: z.string().datetime({ offset: true }), status: z.enum([\"placed\", \"approved\", \"delivered\"]), complete: z.boolean() }).partial().passthrough().readonly()\",\n              \"Pet\": \"z.object({ id: z.number().int().optional(), name: z.string(), category: Category.optional(), photoUrls: z.array(z.string()).readonly(), tags: z.array(Tag).readonly().optional(), status: z.enum([\"available\", \"pending\", \"sold\"]).optional() }).passthrough().readonly()\",\n              \"Tag\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough().readonly()\",\n              \"User\": \"z.object({ id: z.number().int(), username: z.string(), firstName: z.string(), lastName: z.string(), email: z.string(), password: z.string(), phone: z.string(), userStatus: z.number().int() }).partial().passthrough().readonly()\",\n          },\n          \"types\": {},\n      }\n    `);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/generateZodClientFromOpenAPI.ts","messages":[{"ruleId":"max-statements","severity":2,"message":"Async arrow function has too many statements (40). Maximum allowed is 30.","line":73,"column":45,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":166,"endColumn":2}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import path from \"node:path\";\nimport fs from \"node:fs/promises\";\n\nimport type { OpenAPIObject } from \"openapi3-ts\";\nimport { capitalize, pick } from \"pastable/server\";\nimport type { Options } from \"prettier\";\nimport { match } from \"ts-pattern\";\n\nimport { getHandlebars } from \"./getHandlebars.js\";\nimport { maybePretty } from \"./maybePretty.js\";\nimport type { TemplateContext } from \"./template-context.js\";\nimport { getZodClientTemplateContext } from \"./template-context.js\";\n\ntype GenerateZodClientFromOpenApiArgs<TOptions extends TemplateContext[\"options\"] = TemplateContext[\"options\"]> = {\n    openApiDoc: OpenAPIObject;\n    templatePath?: string;\n    prettierConfig?: Options | null;\n    options?: TOptions;\n    handlebars?: ReturnType<typeof getHandlebars>;\n} & (\n    | {\n          distPath?: never;\n          /** when true, will only return the result rather than writing it to a file, mostly used for easier testing purpose */\n          disableWriteToFile: true;\n      }\n    | { distPath: string; disableWriteToFile?: false }\n);\n\n/**\n * Generate a Zod client from an OpenAPI specification.\n *\n * @example Basic usage (programmatic)\n * ```typescript\n * import SwaggerParser from \"@apidevtools/swagger-parser\";\n * import { generateZodClientFromOpenAPI } from \"openapi-zod-client\";\n * import { resolveConfig } from \"prettier\";\n *\n * const openApiDoc = await SwaggerParser.parse(\"./openapi.yaml\");\n * const prettierConfig = await resolveConfig(\"./\");\n *\n * const result = await generateZodClientFromOpenAPI({\n *   openApiDoc,\n *   distPath: \"./api-client.ts\",\n *   prettierConfig,\n * });\n * ```\n *\n * @example With options\n * ```typescript\n * const result = await generateZodClientFromOpenAPI({\n *   openApiDoc,\n *   distPath: \"./api-client.ts\",\n *   options: {\n *     withAlias: true,\n *     baseUrl: \"https://api.example.com\",\n *     exportSchemas: true,\n *   },\n * });\n * ```\n *\n * @example With custom template\n * ```typescript\n * const result = await generateZodClientFromOpenAPI({\n *   openApiDoc,\n *   distPath: \"./schemas.ts\",\n *   templatePath: \"./custom-template.hbs\",\n *   options: {\n *     exportSchemas: true,\n *   },\n * });\n * ```\n */\nexport const generateZodClientFromOpenAPI = async <TOptions extends TemplateContext[\"options\"]>({\n    openApiDoc,\n    distPath,\n    templatePath,\n    prettierConfig,\n    options,\n    disableWriteToFile,\n    handlebars,\n}: GenerateZodClientFromOpenApiArgs<TOptions>): Promise<string | Record<string, string>> => {\n    const data = getZodClientTemplateContext(openApiDoc, options);\n    const groupStrategy = options?.groupStrategy ?? \"none\";\n\n    if (!templatePath) {\n        templatePath = match(groupStrategy)\n            .with(\"none\", \"tag-file\", \"method-file\", () => path.join(__dirname, \"../src/templates/default.hbs\"))\n            .with(\"tag\", \"method\", () => path.join(__dirname, \"../src/templates/grouped.hbs\"))\n            .exhaustive();\n    }\n\n    const source = await fs.readFile(templatePath, \"utf8\");\n    const hbs = handlebars ?? getHandlebars();\n    const template = hbs.compile(source);\n    const willWriteToFile = !disableWriteToFile && distPath;\n\n    if (groupStrategy.includes(\"file\")) {\n        const outputByGroupName: Record<string, string> = {};\n\n        if (willWriteToFile) {\n            await fs.mkdir(path.dirname(distPath), { recursive: true });\n        }\n\n        const groupNames = Object.fromEntries(\n            Object.keys(data.endpointsGroups).map((groupName) => [`${capitalize(groupName)}Api`, groupName])\n        );\n\n        const indexSource = await fs.readFile(path.join(__dirname, \"../src/templates/grouped-index.hbs\"), \"utf8\");\n        const indexTemplate = hbs.compile(indexSource);\n        const indexOutput = await maybePretty(indexTemplate({ groupNames }), prettierConfig);\n        outputByGroupName[\"__index\"] = indexOutput;\n\n        if (willWriteToFile) {\n            await fs.writeFile(path.join(distPath, \"index.ts\"), indexOutput);\n        }\n\n        const commonSource = await fs.readFile(path.join(__dirname, \"../src/templates/grouped-common.hbs\"), \"utf8\");\n        const commonTemplate = hbs.compile(commonSource);\n        const commonSchemaNames = [...(data.commonSchemaNames ?? [])];\n\n        if (commonSchemaNames.length > 0) {\n            const commonOutput = await maybePretty(\n                commonTemplate({\n                    schemas: pick(data.schemas, commonSchemaNames),\n                    types: pick(data.types, commonSchemaNames),\n                }),\n                prettierConfig\n            );\n            outputByGroupName[\"__common\"] = commonOutput;\n\n            if (willWriteToFile) {\n                await fs.writeFile(path.join(distPath, \"common.ts\"), commonOutput);\n            }\n        }\n\n        for (const groupName in data.endpointsGroups) {\n            const groupOutput = template({\n                ...data,\n                ...data.endpointsGroups[groupName],\n                options: {\n                    ...options,\n                    groupStrategy: \"none\",\n                    apiClientName: `${capitalize(groupName)}Api`,\n                },\n            });\n            const prettyGroupOutput = await maybePretty(groupOutput, prettierConfig);\n            outputByGroupName[groupName] = prettyGroupOutput;\n\n            if (willWriteToFile) {\n                console.log(\"Writing to\", path.join(distPath, `${groupName}.ts`));\n                await fs.writeFile(path.join(distPath, `${groupName}.ts`), prettyGroupOutput);\n            }\n        }\n\n        return outputByGroupName;\n    }\n\n    const output = template({ ...data, options: { ...options, apiClientName: options?.apiClientName ?? \"api\" } });\n    const prettyOutput = await maybePretty(output, prettierConfig);\n\n    if (willWriteToFile) {\n        await fs.writeFile(distPath, prettyOutput);\n    }\n\n    return prettyOutput;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/getHandlebars.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/getOpenApiDependencyGraph.helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/getOpenApiDependencyGraph.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/getOpenApiDependencyGraph.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/getZodiosEndpointDefinitionList.test.ts","messages":[{"ruleId":"sonarjs/no-clear-text-protocols","severity":2,"message":"Using http protocol is insecure. Use https instead.","line":12,"column":25,"nodeType":"Literal","messageId":"insecureProtocol","endLine":12,"endColumn":51},{"ruleId":"sonarjs/no-clear-text-protocols","severity":2,"message":"Using http protocol is insecure. Use https instead.","line":18,"column":18,"nodeType":"Literal","messageId":"insecureProtocol","endLine":18,"endColumn":67}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import SwaggerParser from \"@apidevtools/swagger-parser\";\nimport type { OpenAPIObject, SchemaObject } from \"openapi3-ts\";\nimport { expect, test } from \"vitest\";\nimport { getZodiosEndpointDefinitionList } from \"./getZodiosEndpointDefinitionList.js\";\n\nconst baseDoc = {\n    openapi: \"3.0.3\",\n    info: {\n        title: \"Swagger Petstore - OpenAPI 3.0\",\n        description:\n            \"This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about\\nSwagger at [https://swagger.io](https://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\\nYou can now help us improve the API whether it's by making changes to the definition itself or to the code.\\nThat way, with time, we can improve the API in general, and expose some of the new features in OAS3.\\n\\n_If you're looking for the Swagger 2.0/OAS 2.0 version of Petstore, then click [here](https://editor.swagger.io/?url=https://petstore.swagger.io/v2/swagger.yaml). Alternatively, you can load via the `Edit > Load Petstore OAS 2.0` menu option!_\\n\\nSome useful links:\\n- [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)\\n- [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)\",\n        termsOfService: \"http://swagger.io/terms/\",\n        contact: {\n            email: \"apiteam@swagger.io\",\n        },\n        license: {\n            name: \"Apache 2.0\",\n            url: \"http://www.apache.org/licenses/LICENSE-2.0.html\",\n        },\n        version: \"1.0.11\",\n    },\n} as OpenAPIObject;\n\nconst schemas = {\n    Order: {\n        type: \"object\",\n        properties: {\n            id: { type: \"integer\", format: \"int64\", example: 10 },\n            petId: { type: \"integer\", format: \"int64\", example: 198_772 },\n            quantity: { type: \"integer\", format: \"int32\", example: 7 },\n            shipDate: { type: \"string\", format: \"date-time\" },\n            status: {\n                type: \"string\",\n                description: \"Order Status\",\n                example: \"approved\",\n                enum: [\"placed\", \"approved\", \"delivered\"],\n            },\n            complete: { type: \"boolean\" },\n        },\n        xml: { name: \"order\" },\n    } as SchemaObject,\n    Pet: {\n        required: [\"name\", \"photoUrls\"],\n        type: \"object\",\n        properties: {\n            id: { type: \"integer\", format: \"int64\", example: 10 },\n            name: { type: \"string\", example: \"doggie\" },\n            category: { $ref: \"#/components/schemas/Category\" },\n            photoUrls: { type: \"array\", xml: { wrapped: true }, items: { type: \"string\", xml: { name: \"photoUrl\" } } },\n            tags: { type: \"array\", xml: { wrapped: true }, items: { $ref: \"#/components/schemas/Tag\" } },\n            status: { type: \"string\", description: \"pet status in the store\", enum: [\"available\", \"pending\", \"sold\"] },\n        },\n        xml: { name: \"pet\" },\n    } as SchemaObject,\n    ReasonDetails: {\n        required: [\"details\"],\n        type: \"object\",\n        properties: {\n            details: { type: \"string\", example: \"found an owner\" },\n        },\n        xml: { name: \"reasonDetails\" },\n    } as SchemaObject,\n    Reason: {\n        required: [\"reason\"],\n        type: \"object\",\n        properties: {\n            reason: { $ref: \"#/components/schemas/ReasonDetails\" },\n        },\n        xml: { name: \"reason\" },\n    } as SchemaObject,\n    Category: {\n        type: \"object\",\n        properties: { id: { type: \"integer\", format: \"int64\", example: 1 }, name: { type: \"string\", example: \"Dogs\" } },\n        xml: { name: \"category\" },\n    } as SchemaObject,\n    Tag: {\n        type: \"object\",\n        properties: { id: { type: \"integer\", format: \"int64\" }, name: { type: \"string\" } },\n        xml: { name: \"tag\" },\n    } as SchemaObject,\n} as const;\n\ntest(\"getZodiosEndpointDefinitionList /store/order\", () => {\n    expect(\n        getZodiosEndpointDefinitionList({\n            ...baseDoc,\n            components: { schemas: { Order: schemas.Order } },\n            paths: {\n                \"/store/order\": {\n                    post: {\n                        tags: [\"store\"],\n                        summary: \"Place an order for a pet\",\n                        description: \"Place a new order in the store\",\n                        operationId: \"placeOrder\",\n                        requestBody: {\n                            content: {\n                                \"application/json\": { schema: { $ref: \"#/components/schemas/Order\" } },\n                                \"application/xml\": { schema: { $ref: \"#/components/schemas/Order\" } },\n                                \"application/x-www-form-urlencoded\": { schema: { $ref: \"#/components/schemas/Order\" } },\n                            },\n                        },\n                        responses: {\n                            \"200\": {\n                                description: \"successful operation\",\n                                content: { \"application/json\": { schema: { $ref: \"#/components/schemas/Order\" } } },\n                            },\n                            \"405\": { description: \"Invalid input\" },\n                        },\n                    },\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(`\n      {\n          \"deepDependencyGraph\": {},\n          \"endpoints\": [\n              {\n                  \"description\": \"Place a new order in the store\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid input\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"\",\n                          \"name\": \"body\",\n                          \"schema\": \"Order\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/store/order\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Order\",\n              },\n          ],\n          \"issues\": {\n              \"ignoredFallbackResponse\": [],\n              \"ignoredGenericError\": [],\n          },\n          \"refsDependencyGraph\": {},\n          \"resolver\": {\n              \"getSchemaByRef\": [Function],\n              \"resolveRef\": [Function],\n              \"resolveSchemaName\": [Function],\n          },\n          \"schemaByName\": {},\n          \"zodSchemaByName\": {\n              \"Order\": \"z.object({ id: z.number().int(), petId: z.number().int(), quantity: z.number().int(), shipDate: z.string().datetime({ offset: true }), status: z.enum([\"placed\", \"approved\", \"delivered\"]), complete: z.boolean() }).partial().passthrough()\",\n          },\n      }\n    `);\n});\n\ntest(\"getZodiosEndpointDefinitionList /pet\", () => {\n    expect(\n        getZodiosEndpointDefinitionList({\n            ...baseDoc,\n            components: { schemas: { Pet: schemas.Pet, Category: schemas.Category, Tag: schemas.Tag } },\n            paths: {\n                \"/pet\": {\n                    put: {\n                        tags: [\"pet\"],\n                        summary: \"Update an existing pet\",\n                        description: \"Update an existing pet by Id\",\n                        operationId: \"updatePet\",\n                        requestBody: {\n                            description: \"Update an existent pet in the store\",\n                            content: {\n                                \"application/json\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                                \"application/xml\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                                \"application/x-www-form-urlencoded\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                            },\n                            required: true,\n                        },\n                        responses: {\n                            \"200\": {\n                                description: \"Successful operation\",\n                                content: {\n                                    \"application/json\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                                    \"application/xml\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                                },\n                            },\n                            \"400\": { description: \"Invalid ID supplied\" },\n                            \"404\": { description: \"Pet not found\" },\n                            \"405\": { description: \"Validation exception\" },\n                        },\n                        security: [{ petstore_auth: [\"write:pets\", \"read:pets\"] }],\n                    },\n                    post: {\n                        tags: [\"pet\"],\n                        summary: \"Add a new pet to the store\",\n                        description: \"Add a new pet to the store\",\n                        operationId: \"addPet\",\n                        requestBody: {\n                            description: \"Create a new pet in the store\",\n                            content: {\n                                \"application/json\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                                \"application/xml\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                                \"application/x-www-form-urlencoded\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                            },\n                            required: true,\n                        },\n                        responses: {\n                            \"200\": {\n                                description: \"Successful operation\",\n                                content: {\n                                    \"application/json\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                                    \"application/xml\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                                },\n                            },\n                            \"405\": { description: \"Invalid input\" },\n                        },\n                        security: [{ petstore_auth: [\"write:pets\", \"read:pets\"] }],\n                    },\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(`\n      {\n          \"deepDependencyGraph\": {\n              \"#/components/schemas/Pet\": Set {\n                  \"#/components/schemas/Category\",\n                  \"#/components/schemas/Tag\",\n              },\n          },\n          \"endpoints\": [\n              {\n                  \"description\": \"Update an existing pet by Id\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Pet not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                      {\n                          \"description\": \"Validation exception\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"put\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Update an existent pet in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"Pet\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/pet\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n              {\n                  \"description\": \"Add a new pet to the store\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid input\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Create a new pet in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"Pet\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/pet\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n          ],\n          \"issues\": {\n              \"ignoredFallbackResponse\": [],\n              \"ignoredGenericError\": [],\n          },\n          \"refsDependencyGraph\": {\n              \"#/components/schemas/Pet\": Set {\n                  \"#/components/schemas/Category\",\n                  \"#/components/schemas/Tag\",\n              },\n          },\n          \"resolver\": {\n              \"getSchemaByRef\": [Function],\n              \"resolveRef\": [Function],\n              \"resolveSchemaName\": [Function],\n          },\n          \"schemaByName\": {},\n          \"zodSchemaByName\": {\n              \"Category\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n              \"Pet\": \"z.object({ id: z.number().int().optional(), name: z.string(), category: Category.optional(), photoUrls: z.array(z.string()), tags: z.array(Tag).optional(), status: z.enum([\"available\", \"pending\", \"sold\"]).optional() }).passthrough()\",\n              \"Tag\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n          },\n      }\n    `);\n});\n\ntest(\"getZodiosEndpointDefinitionList /pet without schema ref\", () => {\n    expect(\n        getZodiosEndpointDefinitionList({\n            ...baseDoc,\n            components: {\n                schemas: {\n                    Pet: schemas.Pet,\n                    Category: schemas.Category,\n                    Tag: schemas.Tag,\n                    Reason: schemas.Reason,\n                    ReasonDetails: schemas.ReasonDetails,\n                },\n            },\n            paths: {\n                \"/pet\": {\n                    put: {\n                        tags: [\"pet\"],\n                        summary: \"Update an existing pet\",\n                        description: \"Update an existing pet by Id\",\n                        operationId: \"updatePet\",\n                        requestBody: {\n                            description: \"Update an existent pet in the store\",\n                            content: {\n                                \"application/json\": {\n                                    schema: {\n                                        allOf: [\n                                            { $ref: \"#/components/schemas/Pet\" },\n                                            { $ref: \"#/components/schemas/Reason\" },\n                                        ],\n                                    },\n                                },\n                                \"application/xml\": {\n                                    schema: {\n                                        allOf: [\n                                            { $ref: \"#/components/schemas/Pet\" },\n                                            { $ref: \"#/components/schemas/Reason\" },\n                                        ],\n                                    },\n                                    \"application/x-www-form-urlencoded\": {\n                                        schema: {\n                                            allOf: [\n                                                { $ref: \"#/components/schemas/Pet\" },\n                                                { $ref: \"#/components/schemas/Reason\" },\n                                            ],\n                                        },\n                                    },\n                                },\n                            },\n                            required: true,\n                        },\n                        responses: {\n                            \"200\": {\n                                description: \"Successful operation\",\n                                content: {\n                                    \"application/json\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                                    \"application/xml\": { schema: { $ref: \"#/components/schemas/Pet\" } },\n                                },\n                            },\n                            \"400\": { description: \"Invalid ID supplied\" },\n                            \"404\": { description: \"Pet not found\" },\n                            \"405\": { description: \"Validation exception\" },\n                        },\n                        security: [{ petstore_auth: [\"write:pets\", \"read:pets\"] }],\n                    },\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(`\n      {\n          \"deepDependencyGraph\": {\n              \"#/components/schemas/Pet\": Set {\n                  \"#/components/schemas/Category\",\n                  \"#/components/schemas/Tag\",\n              },\n              \"#/components/schemas/Reason\": Set {\n                  \"#/components/schemas/ReasonDetails\",\n              },\n          },\n          \"endpoints\": [\n              {\n                  \"description\": \"Update an existing pet by Id\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Pet not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                      {\n                          \"description\": \"Validation exception\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"put\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Update an existent pet in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"updatePet_Body\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/pet\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n          ],\n          \"issues\": {\n              \"ignoredFallbackResponse\": [],\n              \"ignoredGenericError\": [],\n          },\n          \"refsDependencyGraph\": {\n              \"#/components/schemas/Pet\": Set {\n                  \"#/components/schemas/Category\",\n                  \"#/components/schemas/Tag\",\n              },\n              \"#/components/schemas/Reason\": Set {\n                  \"#/components/schemas/ReasonDetails\",\n              },\n          },\n          \"resolver\": {\n              \"getSchemaByRef\": [Function],\n              \"resolveRef\": [Function],\n              \"resolveSchemaName\": [Function],\n          },\n          \"schemaByName\": {\n              \"Pet.and(Reason)\": \"updatePet_Body\",\n          },\n          \"zodSchemaByName\": {\n              \"Category\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n              \"Pet\": \"z.object({ id: z.number().int().optional(), name: z.string(), category: Category.optional(), photoUrls: z.array(z.string()), tags: z.array(Tag).optional(), status: z.enum([\"available\", \"pending\", \"sold\"]).optional() }).passthrough()\",\n              \"Reason\": \"z.object({ reason: ReasonDetails }).passthrough()\",\n              \"ReasonDetails\": \"z.object({ details: z.string() }).passthrough()\",\n              \"Tag\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n              \"updatePet_Body\": \"Pet.and(Reason)\",\n          },\n      }\n    `);\n});\n\ntest(\"getZodiosEndpointDefinitionList /pet/findXXX\", () => {\n    expect(\n        getZodiosEndpointDefinitionList({\n            ...baseDoc,\n            components: { schemas: { Pet: schemas.Pet, Category: schemas.Category, Tag: schemas.Tag } },\n            paths: {\n                \"/pet/findByStatus\": {\n                    get: {\n                        tags: [\"pet\"],\n                        summary: \"Finds Pets by status\",\n                        description: \"Multiple status values can be provided with comma separated strings\",\n                        operationId: \"findPetsByStatus\",\n                        parameters: [\n                            {\n                                name: \"status\",\n                                in: \"query\",\n                                description: \"Status values that need to be considered for filter\",\n                                required: false,\n                                explode: true,\n                                schema: {\n                                    type: \"string\",\n                                    default: \"available\",\n                                    enum: [\"available\", \"pending\", \"sold\"],\n                                },\n                            },\n                        ],\n                        responses: {\n                            \"200\": {\n                                description: \"successful operation\",\n                                content: {\n                                    \"application/json\": {\n                                        schema: {\n                                            type: \"array\",\n                                            items: {\n                                                $ref: \"#/components/schemas/Pet\",\n                                            },\n                                        },\n                                    },\n                                    \"application/xml\": {\n                                        schema: {\n                                            type: \"array\",\n                                            items: {\n                                                $ref: \"#/components/schemas/Pet\",\n                                            },\n                                        },\n                                    },\n                                },\n                            },\n                            \"400\": {\n                                description: \"Invalid status value\",\n                            },\n                        },\n                        security: [\n                            {\n                                petstore_auth: [\"write:pets\", \"read:pets\"],\n                            },\n                        ],\n                    },\n                },\n                \"/pet/findByTags\": {\n                    get: {\n                        tags: [\"pet\"],\n                        summary: \"Finds Pets by tags\",\n                        description:\n                            \"Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\",\n                        operationId: \"findPetsByTags\",\n                        parameters: [\n                            {\n                                name: \"tags\",\n                                in: \"query\",\n                                description: \"Tags to filter by\",\n                                required: false,\n                                explode: true,\n                                schema: {\n                                    type: \"array\",\n                                    items: {\n                                        type: \"string\",\n                                    },\n                                },\n                            },\n                        ],\n                        responses: {\n                            \"200\": {\n                                description: \"successful operation\",\n                                content: {\n                                    \"application/json\": {\n                                        schema: {\n                                            type: \"array\",\n                                            items: {\n                                                $ref: \"#/components/schemas/Pet\",\n                                            },\n                                        },\n                                    },\n                                    \"application/xml\": {\n                                        schema: {\n                                            type: \"array\",\n                                            items: {\n                                                $ref: \"#/components/schemas/Pet\",\n                                            },\n                                        },\n                                    },\n                                },\n                            },\n                            \"400\": {\n                                description: \"Invalid tag value\",\n                            },\n                        },\n                        security: [\n                            {\n                                petstore_auth: [\"write:pets\", \"read:pets\"],\n                            },\n                        ],\n                    },\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(`\n      {\n          \"deepDependencyGraph\": {\n              \"#/components/schemas/Pet\": Set {\n                  \"#/components/schemas/Category\",\n                  \"#/components/schemas/Tag\",\n              },\n          },\n          \"endpoints\": [\n              {\n                  \"description\": \"Multiple status values can be provided with comma separated strings\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid status value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"status\",\n                          \"schema\": \"z.enum([\"available\", \"pending\", \"sold\"]).optional().default(\"available\")\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/findByStatus\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.array(Pet)\",\n              },\n              {\n                  \"description\": \"Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid tag value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"tags\",\n                          \"schema\": \"z.array(z.string()).optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/findByTags\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.array(Pet)\",\n              },\n          ],\n          \"issues\": {\n              \"ignoredFallbackResponse\": [],\n              \"ignoredGenericError\": [],\n          },\n          \"refsDependencyGraph\": {\n              \"#/components/schemas/Pet\": Set {\n                  \"#/components/schemas/Category\",\n                  \"#/components/schemas/Tag\",\n              },\n          },\n          \"resolver\": {\n              \"getSchemaByRef\": [Function],\n              \"resolveRef\": [Function],\n              \"resolveSchemaName\": [Function],\n          },\n          \"schemaByName\": {},\n          \"zodSchemaByName\": {\n              \"Category\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n              \"Pet\": \"z.object({ id: z.number().int().optional(), name: z.string(), category: Category.optional(), photoUrls: z.array(z.string()), tags: z.array(Tag).optional(), status: z.enum([\"available\", \"pending\", \"sold\"]).optional() }).passthrough()\",\n              \"Tag\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n          },\n      }\n    `);\n});\n\ntest(\"petstore.yaml\", async () => {\n    const openApiDoc = (await SwaggerParser.parse(\"./tests/petstore.yaml\")) as OpenAPIObject;\n    const result = getZodiosEndpointDefinitionList(openApiDoc);\n    expect(result).toMatchInlineSnapshot(`\n      {\n          \"deepDependencyGraph\": {\n              \"#/components/schemas/Customer\": Set {\n                  \"#/components/schemas/Address\",\n              },\n              \"#/components/schemas/Pet\": Set {\n                  \"#/components/schemas/Category\",\n                  \"#/components/schemas/Tag\",\n              },\n          },\n          \"endpoints\": [\n              {\n                  \"description\": \"Update an existing pet by Id\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Pet not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                      {\n                          \"description\": \"Validation exception\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"put\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Update an existent pet in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"Pet\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/pet\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n              {\n                  \"description\": \"Add a new pet to the store\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid input\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Create a new pet in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"Pet\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/pet\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n              {\n                  \"description\": \"Multiple status values can be provided with comma separated strings\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid status value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"status\",\n                          \"schema\": \"z.enum([\"available\", \"pending\", \"sold\"]).optional().default(\"available\")\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/findByStatus\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.array(Pet)\",\n              },\n              {\n                  \"description\": \"Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid tag value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"tags\",\n                          \"schema\": \"z.array(z.string()).optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/findByTags\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.array(Pet)\",\n              },\n              {\n                  \"description\": \"Returns a single pet\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Pet not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Pet\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid input\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                      {\n                          \"name\": \"name\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                      {\n                          \"name\": \"status\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"delete a pet\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid pet value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"delete\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"api_key\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Header\",\n                      },\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"\",\n                          \"name\": \"body\",\n                          \"schema\": \"z.instanceof(File)\",\n                          \"type\": \"Body\",\n                      },\n                      {\n                          \"name\": \"petId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                      {\n                          \"name\": \"additionalMetadata\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/pet/:petId/uploadImage\",\n                  \"requestFormat\": \"binary\",\n                  \"response\": \"ApiResponse\",\n              },\n              {\n                  \"description\": \"Returns a map of status codes to quantities\",\n                  \"errors\": [],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/store/inventory\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.record(z.number().int())\",\n              },\n              {\n                  \"description\": \"Place a new order in the store\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid input\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 405,\n                      },\n                  ],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"\",\n                          \"name\": \"body\",\n                          \"schema\": \"Order\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/store/order\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Order\",\n              },\n              {\n                  \"description\": \"For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Order not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"orderId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/store/order/:orderId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"Order\",\n              },\n              {\n                  \"description\": \"For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid ID supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Order not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"delete\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"orderId\",\n                          \"schema\": \"z.number().int()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/store/order/:orderId\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"This can only be done by the logged in user.\",\n                  \"errors\": [],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Created user object\",\n                          \"name\": \"body\",\n                          \"schema\": \"User\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/user\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"Creates list of users with given input array\",\n                  \"errors\": [],\n                  \"method\": \"post\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"\",\n                          \"name\": \"body\",\n                          \"schema\": \"z.array(User)\",\n                          \"type\": \"Body\",\n                      },\n                  ],\n                  \"path\": \"/user/createWithList\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"User\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid username/password supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                      {\n                          \"name\": \"password\",\n                          \"schema\": \"z.string().optional()\",\n                          \"type\": \"Query\",\n                      },\n                  ],\n                  \"path\": \"/user/login\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.string()\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/user/logout\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid username supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"User not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/user/:username\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"User\",\n              },\n              {\n                  \"description\": \"This can only be done by the logged in user.\",\n                  \"errors\": [],\n                  \"method\": \"put\",\n                  \"parameters\": [\n                      {\n                          \"description\": \"Update an existent user in the store\",\n                          \"name\": \"body\",\n                          \"schema\": \"User\",\n                          \"type\": \"Body\",\n                      },\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/user/:username\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n              {\n                  \"description\": \"This can only be done by the logged in user.\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid username supplied\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"User not found\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 404,\n                      },\n                  ],\n                  \"method\": \"delete\",\n                  \"parameters\": [\n                      {\n                          \"name\": \"username\",\n                          \"schema\": \"z.string()\",\n                          \"type\": \"Path\",\n                      },\n                  ],\n                  \"path\": \"/user/:username\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.void()\",\n              },\n          ],\n          \"issues\": {\n              \"ignoredFallbackResponse\": [\n                  \"createUsersWithListInput\",\n              ],\n              \"ignoredGenericError\": [\n                  \"createUser\",\n                  \"logoutUser\",\n                  \"updateUser\",\n              ],\n          },\n          \"refsDependencyGraph\": {\n              \"#/components/schemas/Customer\": Set {\n                  \"#/components/schemas/Address\",\n              },\n              \"#/components/schemas/Pet\": Set {\n                  \"#/components/schemas/Category\",\n                  \"#/components/schemas/Tag\",\n              },\n          },\n          \"resolver\": {\n              \"getSchemaByRef\": [Function],\n              \"resolveRef\": [Function],\n              \"resolveSchemaName\": [Function],\n          },\n          \"schemaByName\": {},\n          \"zodSchemaByName\": {\n              \"ApiResponse\": \"z.object({ code: z.number().int(), type: z.string(), message: z.string() }).partial().passthrough()\",\n              \"Category\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n              \"Order\": \"z.object({ id: z.number().int(), petId: z.number().int(), quantity: z.number().int(), shipDate: z.string().datetime({ offset: true }), status: z.enum([\"placed\", \"approved\", \"delivered\"]), complete: z.boolean() }).partial().passthrough()\",\n              \"Pet\": \"z.object({ id: z.number().int().optional(), name: z.string(), category: Category.optional(), photoUrls: z.array(z.string()), tags: z.array(Tag).optional(), status: z.enum([\"available\", \"pending\", \"sold\"]).optional() }).passthrough()\",\n              \"Tag\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n              \"User\": \"z.object({ id: z.number().int(), username: z.string(), firstName: z.string(), lastName: z.string(), email: z.string(), password: z.string(), phone: z.string(), userStatus: z.number().int() }).partial().passthrough()\",\n          },\n      }\n    `);\n});\n\ntest(\"getZodiosEndpointDefinitionList should return responses if options.withAllResponses is true\", () => {\n    expect(\n        getZodiosEndpointDefinitionList(\n            {\n                ...baseDoc,\n                components: { schemas: { Pet: schemas.Pet, Category: schemas.Category, Tag: schemas.Tag } },\n                paths: {\n                    \"/pet/findByStatus\": {\n                        get: {\n                            tags: [\"pet\"],\n                            summary: \"Finds Pets by status\",\n                            description: \"Multiple status values can be provided with comma separated strings\",\n                            operationId: \"findPetsByStatus\",\n                            responses: {\n                                \"200\": {\n                                    description: \"successful operation\",\n                                    content: {\n                                        \"application/json\": {\n                                            schema: {\n                                                type: \"array\",\n                                                items: {\n                                                    $ref: \"#/components/schemas/Pet\",\n                                                },\n                                            },\n                                        },\n                                    },\n                                },\n                                \"400\": {\n                                    description: \"Invalid status value\",\n                                    content: {\n                                        \"application/json\": {\n                                            schema: {\n                                                type: \"string\",\n                                            },\n                                        },\n                                    },\n                                },\n                                \"500\": {\n                                    description: \"Network error\",\n                                },\n                            },\n                        },\n                    },\n                    \"/pet/findByTags\": {\n                        get: {\n                            tags: [\"pet\"],\n                            summary: \"Finds Pets by tags\",\n                            description:\n                                \"Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\",\n                            operationId: \"findPetsByTags\",\n                            responses: {\n                                \"200\": {\n                                    description: \"successful operation\",\n                                    content: {\n                                        \"application/json\": {\n                                            schema: {\n                                                type: \"array\",\n                                                items: {\n                                                    $ref: \"#/components/schemas/Pet\",\n                                                },\n                                            },\n                                        },\n                                    },\n                                },\n                                \"400\": {\n                                    description: \"Invalid tag value\",\n                                },\n                            },\n                        },\n                    },\n                },\n            },\n            { withAllResponses: true }\n        )\n    ).toMatchInlineSnapshot(`\n      {\n          \"deepDependencyGraph\": {\n              \"#/components/schemas/Pet\": Set {\n                  \"#/components/schemas/Category\",\n                  \"#/components/schemas/Tag\",\n              },\n          },\n          \"endpoints\": [\n              {\n                  \"description\": \"Multiple status values can be provided with comma separated strings\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid status value\",\n                          \"schema\": \"z.string()\",\n                          \"status\": 400,\n                      },\n                      {\n                          \"description\": \"Network error\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 500,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/pet/findByStatus\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.array(Pet)\",\n                  \"responses\": [\n                      {\n                          \"description\": \"successful operation\",\n                          \"schema\": \"z.array(Pet)\",\n                          \"statusCode\": \"200\",\n                      },\n                      {\n                          \"description\": \"Invalid status value\",\n                          \"schema\": \"z.string()\",\n                          \"statusCode\": \"400\",\n                      },\n                      {\n                          \"description\": \"Network error\",\n                          \"schema\": \"z.void()\",\n                          \"statusCode\": \"500\",\n                      },\n                  ],\n              },\n              {\n                  \"description\": \"Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\",\n                  \"errors\": [\n                      {\n                          \"description\": \"Invalid tag value\",\n                          \"schema\": \"z.void()\",\n                          \"status\": 400,\n                      },\n                  ],\n                  \"method\": \"get\",\n                  \"parameters\": [],\n                  \"path\": \"/pet/findByTags\",\n                  \"requestFormat\": \"json\",\n                  \"response\": \"z.array(Pet)\",\n                  \"responses\": [\n                      {\n                          \"description\": \"successful operation\",\n                          \"schema\": \"z.array(Pet)\",\n                          \"statusCode\": \"200\",\n                      },\n                      {\n                          \"description\": \"Invalid tag value\",\n                          \"schema\": \"z.void()\",\n                          \"statusCode\": \"400\",\n                      },\n                  ],\n              },\n          ],\n          \"issues\": {\n              \"ignoredFallbackResponse\": [],\n              \"ignoredGenericError\": [],\n          },\n          \"refsDependencyGraph\": {\n              \"#/components/schemas/Pet\": Set {\n                  \"#/components/schemas/Category\",\n                  \"#/components/schemas/Tag\",\n              },\n          },\n          \"resolver\": {\n              \"getSchemaByRef\": [Function],\n              \"resolveRef\": [Function],\n              \"resolveSchemaName\": [Function],\n          },\n          \"schemaByName\": {},\n          \"zodSchemaByName\": {\n              \"Category\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n              \"Pet\": \"z.object({ id: z.number().int().optional(), name: z.string(), category: Category.optional(), photoUrls: z.array(z.string()), tags: z.array(Tag).optional(), status: z.enum([\"available\", \"pending\", \"sold\"]).optional() }).passthrough()\",\n              \"Tag\": \"z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()\",\n          },\n      }\n    `);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/getZodiosEndpointDefinitionList.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Arrow function has too many lines (108). Maximum allowed is 100.","line":53,"column":48,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":160,"endColumn":2},{"ruleId":"max-statements","severity":2,"message":"Arrow function has too many statements (34). Maximum allowed is 30.","line":53,"column":48,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":160,"endColumn":2},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":90,"column":37,"nodeType":"TSAsExpression","messageId":"never","endLine":90,"endColumn":51},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":91,"column":33,"nodeType":"TSAsExpression","messageId":"never","endLine":91,"endColumn":47},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":94,"column":29,"nodeType":"TSAsExpression","messageId":"never","endLine":94,"endColumn":62},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":99,"column":40,"nodeType":"TSAsExpression","messageId":"never","endLine":99,"endColumn":71},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":152,"column":13,"nodeType":"TSAsExpression","messageId":"never","endLine":152,"endColumn":51},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":183,"column":20,"nodeType":"TSAsExpression","messageId":"never","endLine":183,"endColumn":36},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":186,"column":29,"nodeType":"TSAsExpression","messageId":"never","endLine":186,"endColumn":37},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":187,"column":16,"nodeType":"TSAsExpression","messageId":"never","endLine":187,"endColumn":24},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":187,"column":32,"nodeType":"TSAsExpression","messageId":"never","endLine":187,"endColumn":40}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ZodiosEndpointDefinition } from \"@zodios/core\";\nimport type { OpenAPIObject, OperationObject, PathItemObject } from \"openapi3-ts\";\nimport { isReferenceObject } from \"openapi3-ts\";\nimport type { ObjectLiteral } from \"pastable\";\nimport { match, P } from \"ts-pattern\";\n\nimport type { CodeMeta, ConversionTypeContext } from \"./CodeMeta.js\";\nimport { getOpenApiDependencyGraph } from \"./getOpenApiDependencyGraph.js\";\nimport { makeSchemaResolver } from \"./makeSchemaResolver.js\";\nimport type { TemplateContext } from \"./template-context.js\";\nimport { getSchemaVarName } from \"./zodiosEndpoint.helpers.js\";\nimport { processOperation } from \"./zodiosEndpoint.path.helpers.js\";\nimport { asComponentSchema, pathToVariableName } from \"./utils.js\";\n\n/**\n * Extract endpoint definitions with runtime Zod schemas from an OpenAPI specification.\n *\n * This function returns an array of endpoint definitions where each endpoint includes:\n * - Method, path, and description\n * - Parameters with runtime Zod schemas\n * - Response and error schemas\n *\n * **Note:** This is the primary function for extracting runtime validation schemas.\n *\n * @example Basic usage\n * ```typescript\n * import SwaggerParser from \"@apidevtools/swagger-parser\";\n * import { getZodiosEndpointDefinitionList } from \"openapi-zod-client\";\n *\n * const openApiDoc = await SwaggerParser.parse(\"./openapi.yaml\");\n * const endpoints = getZodiosEndpointDefinitionList(openApiDoc);\n *\n * // Each endpoint contains runtime Zod schemas:\n * endpoints.forEach(endpoint => {\n *   console.log(endpoint.method, endpoint.path);\n *   endpoint.parameters?.forEach(param => {\n *     // param.schema is a runtime Zod schema object\n *     const validated = param.schema.parse(inputData);\n *   });\n * });\n * ```\n *\n * @example With options\n * ```typescript\n * const endpoints = getZodiosEndpointDefinitionList(openApiDoc, {\n *   withAlias: true,\n *   exportSchemas: true,\n *   complexityThreshold: 3,\n * });\n * ```\n */\n \nexport const getZodiosEndpointDefinitionList = (doc: OpenAPIObject, options?: TemplateContext[\"options\"]) => {\n    const resolver = makeSchemaResolver(doc);\n    const graphs = getOpenApiDependencyGraph(\n        Object.keys(doc.components?.schemas ?? {}).map((name) => asComponentSchema(name)),\n        resolver.getSchemaByRef\n    );\n\n    const endpoints = [];\n\n    const getOperationAlias = match(options?.withAlias)\n        .with(\n            P.boolean,\n            P.nullish,\n            () => (path: string, method: string, operation: OperationObject) =>\n                operation.operationId ?? method + pathToVariableName(path)\n        )\n        .otherwise((fn) => fn);\n\n    const ctx: ConversionTypeContext = { resolver, zodSchemaByName: {}, schemaByName: {} };\n    if (options?.exportAllNamedSchemas) {\n        ctx.schemasByName = {};\n    }\n\n    const complexityThreshold = options?.complexityThreshold ?? 4;\n    const getZodVarName = (input: CodeMeta, fallbackName?: string) =>\n        getSchemaVarName(\n            input,\n            ctx,\n            complexityThreshold,\n            fallbackName,\n            options?.exportAllNamedSchemas !== undefined\n                ? { exportAllNamedSchemas: options.exportAllNamedSchemas }\n                : undefined\n        );\n\n    const defaultStatusBehavior = options?.defaultStatusBehavior ?? \"spec-compliant\";\n\n    const ignoredFallbackResponse = [] as string[];\n    const ignoredGenericError = [] as string[];\n\n    for (const path in doc.paths) {\n        const pathItemObj = doc.paths[path] as PathItemObject;\n        const pathItem = pick(pathItemObj, [\"get\", \"put\", \"post\", \"delete\", \"options\", \"head\", \"patch\", \"trace\"]);\n        const parametersMap = getParametersMap(pathItemObj.parameters ?? []);\n\n        for (const method in pathItem) {\n            const operation = pathItem[method as keyof typeof pathItem];\n            if (!operation) continue;\n            if (options?.withDeprecatedEndpoints ? false : operation.deprecated) continue;\n\n            const parameters = Object.values({\n                ...parametersMap,\n                ...getParametersMap(operation.parameters ?? []),\n            });\n            const operationName = getOperationAlias(path, method, operation);\n\n            const result = processOperation({\n                path,\n                method,\n                operation,\n                operationName,\n                parameters,\n                ctx,\n                getZodVarName,\n                defaultStatusBehavior,\n                options,\n            });\n\n            endpoints.push(result.endpoint);\n\n            if (result.ignoredFallback) {\n                ignoredFallbackResponse.push(result.ignoredFallback);\n            }\n\n            if (result.ignoredGeneric) {\n                ignoredGenericError.push(result.ignoredGeneric);\n            }\n        }\n    }\n\n    if (options?.willSuppressWarnings !== true) {\n        if (ignoredFallbackResponse.length > 0) {\n            console.warn(\n                `The following endpoints have no status code other than \\`default\\` and were ignored as the OpenAPI spec recommends. However they could be added by setting \\`defaultStatusBehavior\\` to \\`auto-correct\\`: ${ignoredGenericError.join(\n                    \", \"\n                )}`\n            );\n        }\n\n        if (ignoredGenericError.length > 0) {\n            console.warn(\n                `The following endpoints could have had a generic error response added by setting \\`defaultStatusBehavior\\` to \\`auto-correct\\` ${ignoredGenericError.join(\n                    \", \"\n                )}`\n            );\n        }\n    }\n\n    return {\n        ...(ctx as Required<ConversionTypeContext>),\n        ...graphs,\n        endpoints,\n        issues: {\n            ignoredFallbackResponse,\n            ignoredGenericError,\n        },\n    };\n};\n\nconst getParametersMap = (parameters: NonNullable<PathItemObject[\"parameters\"]>) => {\n    return Object.fromEntries(\n        (parameters ?? []).map((param) => [isReferenceObject(param) ? param.$ref : param.name, param] as const)\n    );\n};\n\nexport type EndpointDefinitionWithRefs = Omit<\n    ZodiosEndpointDefinition<unknown>,\n    \"response\" | \"parameters\" | \"errors\" | \"description\"\n> & {\n    response: string;\n    description?: string | undefined;\n    parameters: Array<\n        Omit<Required<ZodiosEndpointDefinition<unknown>>[\"parameters\"][number], \"schema\"> & { schema: string }\n    >;\n    errors: Array<Omit<Required<ZodiosEndpointDefinition<unknown>>[\"errors\"][number], \"schema\"> & { schema: string }>;\n    responses?: Array<{ statusCode: string; schema: string; description?: string }>;\n};\n\n/** Pick given properties in object */\nfunction pick<T extends ObjectLiteral, K extends keyof T>(obj: T, paths: K[]): Pick<T, K> {\n    const result = {} as Pick<T, K>;\n\n    Object.keys(obj).forEach((key) => {\n        if (!paths.includes(key as K)) return;\n        result[key as K] = obj[key as K];\n    });\n\n    return result;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/inferRequiredOnly.ts","messages":[{"ruleId":"sonarjs/prefer-single-boolean-return","severity":2,"message":"Replace this if-then-else flow by a single return statement.","line":5,"column":5,"nodeType":"IfStatement","messageId":"replaceIfThenElseByReturn","endLine":15,"endColumn":6,"suggestions":[{"messageId":"suggestCast","fix":{"range":[252,490],"text":"return !!(!isReferenceObject(item) &&\n        !!item.required &&\n        !item.type &&\n        !item.properties &&\n        !item?.allOf &&\n        !item?.anyOf &&\n        !item.oneOf);"},"desc":"Replace with single return statement using \"!!\" cast"},{"messageId":"suggestBoolean","fix":{"range":[252,490],"text":"return !isReferenceObject(item) &&\n        !!item.required &&\n        !item.type &&\n        !item.properties &&\n        !item?.allOf &&\n        !item?.anyOf &&\n        !item.oneOf;"},"desc":"Replace with single return statement without cast (condition should be boolean!)"}]},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":35,"column":9,"nodeType":"TSAsExpression","messageId":"never","endLine":35,"endColumn":67},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":41,"column":28,"nodeType":"TSAsExpression","messageId":"never","endLine":43,"endColumn":34},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":46,"column":13,"nodeType":"TSAsExpression","messageId":"never","endLine":48,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type SchemaObject, type ReferenceObject, isReferenceObject } from \"openapi3-ts\";\nimport type { DocumentResolver } from \"./makeSchemaResolver.js\";\n\nconst isBrokenAllOfItem = (item: SchemaObject | ReferenceObject): item is SchemaObject => {\n    if (\n        !isReferenceObject(item) &&\n        !!item.required &&\n        !item.type &&\n        !item.properties &&\n        !item?.allOf &&\n        !item?.anyOf &&\n        !item.oneOf\n    ) {\n        return true;\n    }\n    return false;\n};\n\nexport function inferRequiredSchema(schema: SchemaObject) {\n    if (!schema.allOf) {\n        throw new Error(\n            \"function inferRequiredSchema is specialized to handle item with required only in an allOf array.\"\n        );\n    }\n    const [standaloneRequisites, noRequiredOnlyAllof] = schema.allOf.reduce(\n        (acc, cur) => {\n            if (isBrokenAllOfItem(cur)) {\n                const required = cur.required;\n                acc[0].push(...(required ?? []));\n            } else {\n                acc[1].push(cur);\n            }\n            return acc;\n        },\n        [[], []] as [string[], (SchemaObject | ReferenceObject)[]]\n    );\n\n    const composedRequiredSchema = {\n        properties: standaloneRequisites.reduce(\n            (acc, cur) => {\n                acc[cur] = {\n                    // type: \"unknown\" as SchemaObject[\"type\"],\n                } as SchemaObject;\n                return acc;\n            },\n            {} as {\n                [propertyName: string]: SchemaObject | ReferenceObject;\n            }\n        ),\n        type: \"object\" as const,\n        required: standaloneRequisites,\n    };\n\n    return {\n        noRequiredOnlyAllof,\n        composedRequiredSchema,\n        patchRequiredSchemaInLoop: (prop: SchemaObject | ReferenceObject, resolver: DocumentResolver) => {\n            if (isReferenceObject(prop)) {\n                const refType = resolver.getSchemaByRef(prop.$ref);\n                if (refType) {\n                    composedRequiredSchema.required.forEach((required) => {\n                        composedRequiredSchema.properties[required] = refType?.properties?.[required] ?? {};\n                    });\n                }\n            } else {\n                const properties = prop[\"properties\"] ?? {};\n                composedRequiredSchema.required.forEach((required) => {\n                    if (properties[required]) {\n                        composedRequiredSchema.properties[required] = properties[required] ?? {};\n                    }\n                });\n            }\n        },\n    };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/makeSchemaResolver.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/makeSchemaResolver.ts","messages":[{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":33,"column":59,"nodeType":"TSAsExpression","messageId":"never","endLine":33,"endColumn":100}],"suppressedMessages":[{"ruleId":"sonarjs/no-unused-collection","severity":2,"message":"Either use this collection's contents or remove the collection.","line":17,"column":11,"nodeType":"Identifier","messageId":"unusedCollection","endLine":17,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/no-unused-collection","severity":2,"message":"Either use this collection's contents or remove the collection.","line":19,"column":11,"nodeType":"Identifier","messageId":"unusedCollection","endLine":19,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { OpenAPIObject, SchemaObject } from \"openapi3-ts\";\nimport { get } from \"pastable/server\";\n\nimport { normalizeString } from \"./utils.js\";\n\nconst autocorrectRef = (ref: string) => (ref[1] === \"/\" ? ref : \"#/\" + ref.slice(1));\n\ntype RefInfo = {\n    ref: string;\n    name: string;\n    normalized: string;\n};\n\nexport const makeSchemaResolver = (doc: OpenAPIObject) => {\n    // both used for debugging purpose\n    // eslint-disable-next-line sonarjs/no-unused-collection\n    const nameByRef = new Map<string, string>();\n    // eslint-disable-next-line sonarjs/no-unused-collection\n    const refByName = new Map<string, string>();\n\n    const byRef = new Map<string, RefInfo>();\n    const byNormalized = new Map<string, RefInfo>();\n\n    const getSchemaByRef = (ref: string) => {\n        // #components -> #/components\n        const correctRef = autocorrectRef(ref);\n        const split = correctRef.split(\"/\");\n\n        // \"#/components/schemas/Something.jsonld\" -> #/components/schemas\n        const path = split.slice(1, -1).join(\"/\");\n        const retrieved = get(doc, path.replace(\"#/\", \"\").replace(\"#\", \"\").replaceAll(\"/\", \".\"));\n        const map: Record<string, SchemaObject> =\n            retrieved && typeof retrieved === \"object\" ? (retrieved as Record<string, SchemaObject>) : {};\n\n        // \"#/components/schemas/Something.jsonld\" -> \"Something.jsonld\"\n        const name = split.at(-1);\n        if (!name) {\n            throw new Error(`Invalid $ref: ${ref} (no name found in split path)`);\n        }\n        const normalized = normalizeString(name);\n\n        nameByRef.set(correctRef, normalized);\n        refByName.set(normalized, correctRef);\n\n        const infos = { ref: correctRef, name, normalized };\n        byRef.set(infos.ref, infos);\n        byNormalized.set(infos.normalized, infos);\n\n        // doc.components.schemas[\"Something.jsonld\"]\n        const schema = map[name];\n        if (!schema) {\n            throw new Error(`Schema not found for $ref: ${ref}`);\n        }\n        return schema;\n    };\n\n    return {\n        getSchemaByRef,\n        resolveRef: (ref: string) => {\n            const resolved = byRef.get(autocorrectRef(ref));\n            if (!resolved) {\n                throw new Error(`Unable to resolve $ref: ${ref}`);\n            }\n            return resolved;\n        },\n        resolveSchemaName: (normalized: string) => {\n            const resolved = byNormalized.get(normalized);\n            if (!resolved) {\n                throw new Error(`Unable to resolve schema name: ${normalized}`);\n            }\n            return resolved;\n        },\n    };\n};\n\nexport type DocumentResolver = ReturnType<typeof makeSchemaResolver>;\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/maybePretty.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/openApiToTypescript.helpers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/openApiToTypescript.helpers.ts","messages":[{"ruleId":"sonarjs/function-return-type","severity":2,"message":"Refactor this function to always return the same type.","line":45,"column":17,"nodeType":null,"endLine":45,"endColumn":38},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any[]` assigned to a parameter of type `TypeDefinition[]`.","line":93,"column":24,"nodeType":"ArrayExpression","messageId":"unsafeArgument","endLine":93,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe spread of an `any` value in an array.","line":93,"column":25,"nodeType":"SpreadElement","messageId":"unsafeArraySpread","endLine":93,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-argument","severity":2,"message":"Unsafe argument of type `any[]` assigned to a parameter of type `TypeDefinition[]`.","line":95,"column":20,"nodeType":"Identifier","messageId":"unsafeArgument","endLine":95,"endColumn":31},{"ruleId":"sonarjs/no-selector-parameter","severity":2,"message":"Provide multiple methods instead of using \"shouldBeReadonly\" to determine which action to take.","line":119,"column":12,"nodeType":null,"endLine":119,"endColumn":28},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":119,"column":42,"nodeType":"TSAsExpression","messageId":"never","endLine":119,"endColumn":66},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":147,"column":13,"nodeType":"TSAsExpression","messageId":"never","endLine":147,"endColumn":52},{"ruleId":"sonarjs/function-return-type","severity":2,"message":"Refactor this function to always return the same type.","line":156,"column":17,"nodeType":null,"endLine":156,"endColumn":48},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":172,"column":16,"nodeType":"TSAsExpression","messageId":"never","endLine":172,"endColumn":81},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":193,"column":12,"nodeType":"TSAsExpression","messageId":"never","endLine":193,"endColumn":30},{"ruleId":"sonarjs/no-selector-parameter","severity":2,"message":"Provide multiple methods instead of using \"isNullable\" to determine which action to take.","line":214,"column":12,"nodeType":null,"endLine":214,"endColumn":22},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":214,"column":34,"nodeType":"TSAsExpression","messageId":"never","endLine":214,"endColumn":58},{"ruleId":"sonarjs/function-return-type","severity":2,"message":"Refactor this function to always return the same type.","line":221,"column":17,"nodeType":null,"endLine":221,"endColumn":36},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":231,"column":12,"nodeType":"TSAsExpression","messageId":"never","endLine":231,"endColumn":50},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":251,"column":66,"nodeType":"TSAsExpression","messageId":"never","endLine":251,"endColumn":94},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":252,"column":51,"nodeType":"TSAsExpression","messageId":"never","endLine":252,"endColumn":80},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":275,"column":52,"nodeType":"TSAsExpression","messageId":"never","endLine":275,"endColumn":83},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":276,"column":39,"nodeType":"TSAsExpression","messageId":"never","endLine":276,"endColumn":71},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":289,"column":68,"nodeType":"TSAsExpression","messageId":"never","endLine":289,"endColumn":112},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":293,"column":30,"nodeType":"TSAsExpression","messageId":"never","endLine":293,"endColumn":66},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":305,"column":61,"nodeType":"TSAsExpression","messageId":"never","endLine":305,"endColumn":90},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":315,"column":25,"nodeType":"TSAsExpression","messageId":"never","endLine":315,"endColumn":56},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":328,"column":16,"nodeType":"TSAsExpression","messageId":"never","endLine":328,"endColumn":53},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":328,"column":30,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":328,"endColumn":41},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":333,"column":24,"nodeType":"TSAsExpression","messageId":"never","endLine":333,"endColumn":77},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":335,"column":20,"nodeType":"TSAsExpression","messageId":"never","endLine":335,"endColumn":47},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":349,"column":16,"nodeType":"TSAsExpression","messageId":"never","endLine":349,"endColumn":53},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":349,"column":30,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":349,"endColumn":41},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (384). Maximum allowed is 350.","line":351,"column":1,"nodeType":null,"messageId":"exceed","endLine":385,"endColumn":1},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":353,"column":27,"nodeType":"TSAsExpression","messageId":"never","endLine":353,"endColumn":54},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":356,"column":52,"nodeType":"TSAsExpression","messageId":"never","endLine":356,"endColumn":84},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":374,"column":16,"nodeType":"TSAsExpression","messageId":"never","endLine":374,"endColumn":88},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":374,"column":30,"nodeType":"TSAsExpression","messageId":"never","endLine":374,"endColumn":76},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":374,"column":49,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":374,"endColumn":58},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":377,"column":45,"nodeType":"TSAsExpression","messageId":"never","endLine":377,"endColumn":82},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":381,"column":24,"nodeType":"TSAsExpression","messageId":"never","endLine":381,"endColumn":80},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":383,"column":20,"nodeType":"TSAsExpression","messageId":"never","endLine":383,"endColumn":50}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Pure helper functions for converting OpenAPI schemas to TypeScript types\n * Extracted from openApiToTypescript.ts to reduce cognitive complexity\n *\n * Each function has a single responsibility and is < 50 lines\n */\n\nimport { type ReferenceObject, type SchemaObject } from \"openapi3-ts\";\nimport { t, ts } from \"tanu\";\n\nimport type { TsConversionContext } from \"./openApiToTypescript.js\";\nimport { wrapWithQuotesIfNeeded } from \"./utils.js\";\n\n/**\n * Primitive schema types (subset of SchemaObjectType from openapi3-ts)\n * Domain concept: types that map to simple TypeScript primitives\n *\n * Tied to library type per RULES.md 5: Defer Type Definitions to Source Libraries\n */\ntype SchemaObjectType = SchemaObject[\"type\"];\n\n/**\n * Literal array tied to library type - compiler enforces correctness\n */\nconst PRIMITIVE_SCHEMA_TYPES = [\"string\", \"number\", \"integer\", \"boolean\", \"null\"] as const satisfies SchemaObjectType[];\n\ntype PrimitiveSchemaType = (typeof PRIMITIVE_SCHEMA_TYPES)[number];\n\n/**\n * Type predicate to narrow unknown values to primitive schema types\n * Useful for runtime validation and public API\n *\n * Pattern: literals tied to library types per RULES.md 5\n */\nexport function isPrimitiveSchemaType(value: unknown): value is PrimitiveSchemaType {\n    if (typeof value !== \"string\") return false;\n    const typeStrings: readonly string[] = PRIMITIVE_SCHEMA_TYPES;\n    return typeStrings.includes(value);\n}\n\n/**\n * Handles reference objects ($ref) by resolving them to schema names\n * Returns a type reference to the resolved schema name\n */\nexport function handleReferenceObject(\n    schema: ReferenceObject,\n    ctx: TsConversionContext | undefined,\n    resolveRecursively: (schema: SchemaObject) => unknown\n): ts.Node | string {\n    if (!ctx?.visitedRefs || !ctx?.resolver) {\n        throw new Error(\"Context is required for OpenAPI $ref\");\n    }\n\n    // Check if we're in a circular reference\n    const schemaName = ctx.resolver.resolveRef(schema.$ref)?.normalized;\n    if (ctx.visitedRefs[schema.$ref]) {\n        return t.reference(schemaName);\n    }\n\n    // Resolve the actual schema if not yet resolved\n    const result = ctx.nodeByRef[schema.$ref];\n    if (!result) {\n        const actualSchema = ctx.resolver.getSchemaByRef(schema.$ref);\n        if (!actualSchema) {\n            throw new Error(`Schema ${schema.$ref} not found`);\n        }\n\n        ctx.visitedRefs[schema.$ref] = true;\n        resolveRecursively(actualSchema);\n    }\n\n    return t.reference(schemaName);\n}\n\n/**\n * Handles primitive type enums, returning union types\n * Rejects invalid enums (non-string type with string values)\n */\nexport function handlePrimitiveEnum(schema: SchemaObject, schemaType: PrimitiveSchemaType): ts.Node | null {\n    if (!schema.enum) return null;\n\n    // Invalid: non-string type with string enum values\n    if (schemaType !== \"string\" && schema.enum.some((e) => typeof e === \"string\")) {\n        return schema.nullable ? t.union([t.never(), t.reference(\"null\")]) : t.never();\n    }\n\n    // Separate null values from other values\n    const enumValues = schema?.enum;\n    const hasNull = enumValues?.includes(null);\n    const withoutNull = enumValues?.filter((f) => f !== null);\n\n    if (schema.nullable || hasNull) {\n        return t.union([...withoutNull, t.reference(\"null\")]);\n    }\n    return t.union(withoutNull);\n}\n\n/**\n * Handles basic primitive types (string, number, boolean)\n * Returns the appropriate TypeScript type, with null union if nullable\n */\nexport function handleBasicPrimitive(schemaType: PrimitiveSchemaType, isNullable: boolean): ts.Node {\n    let baseType: t.TypeDefinition;\n\n    if (schemaType === \"string\") baseType = t.string();\n    else if (schemaType === \"boolean\") baseType = t.boolean();\n    else baseType = t.number(); // number or integer\n\n    return isNullable ? t.union([baseType, t.reference(\"null\")]) : baseType;\n}\n\n/**\n * Wraps a type in readonly if the option is enabled\n */\nexport function maybeWrapReadonly(\n    type: ts.Node | t.TypeDefinitionObject,\n    shouldBeReadonly: boolean\n): ts.Node | t.TypeDefinitionObject {\n    return shouldBeReadonly ? t.readonly(type as t.TypeDefinition) : type;\n}\n\n/**\n * Determines if a property is required in an object schema\n */\nexport function isPropertyRequired(propName: string, schema: SchemaObject, isPartial: boolean): boolean {\n    return Boolean(isPartial ? true : schema.required?.includes(propName));\n}\n\n/**\n * Creates an additionalProperties index signature for TypeScript\n */\nexport function createAdditionalPropertiesSignature(\n    additionalPropertiesType: t.TypeDefinition | ts.TypeNode\n): ts.TypeLiteralNode {\n    return ts.factory.createTypeLiteralNode([\n        ts.factory.createIndexSignature(\n            undefined,\n            [\n                ts.factory.createParameterDeclaration(\n                    undefined,\n                    undefined,\n                    ts.factory.createIdentifier(\"key\"),\n                    undefined,\n                    ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword)\n                ),\n            ],\n            additionalPropertiesType as ts.TypeNode\n        ),\n    ]);\n}\n\n/**\n * Determines the type for additionalProperties\n * Returns undefined if no additional properties are allowed\n */\nexport function resolveAdditionalPropertiesType(\n    additionalProperties: SchemaObject[\"additionalProperties\"],\n    convertSchema: (schema: SchemaObject | ReferenceObject) => unknown\n): ts.Node | t.TypeDefinition | undefined {\n    if (!additionalProperties) return undefined;\n\n    // Boolean true or empty object means any type\n    if (\n        (typeof additionalProperties === \"boolean\" && additionalProperties) ||\n        (typeof additionalProperties === \"object\" && Object.keys(additionalProperties).length === 0)\n    ) {\n        return t.any();\n    }\n\n    // Specific schema for additional properties\n    if (typeof additionalProperties === \"object\") {\n        return convertSchema(additionalProperties) as ts.Node | t.TypeDefinition;\n    }\n\n    return undefined;\n}\n\n/**\n * Wraps a type definition as a type alias or returns inline\n */\nexport function wrapTypeIfNeeded(\n    isInline: boolean,\n    name: string | undefined,\n    typeDef: t.TypeDefinition\n): t.TypeDefinitionObject | ts.Node {\n    if (!isInline) {\n        if (!name) {\n            throw new Error(\"Name is required to convert a schema to a type reference\");\n        }\n        return t.type(name, typeDef);\n    }\n\n    return typeDef as ts.Node;\n}\n\n/**\n * Converts an array of schemas to TypeScript types\n * Used by oneOf, anyOf, allOf composition handlers\n */\nexport function convertSchemasToTypes<T>(\n    schemas: ReadonlyArray<SchemaObject | ReferenceObject>,\n    convertFn: (schema: SchemaObject | ReferenceObject) => T\n): T[] {\n    return schemas.map((schema) => convertFn(schema));\n}\n\n/**\n * Adds null to a union type if nullable flag is true\n */\nexport function addNullToUnionIfNeeded(\n    type: ts.Node | t.TypeDefinitionObject,\n    isNullable: boolean\n): ts.Node | t.TypeDefinitionObject {\n    return isNullable ? t.union([type as t.TypeDefinition, t.reference(\"null\")]) : type;\n}\n\n/**\n * Converts a single property schema to a TypeScript type\n * Handles circular references by converting string types to references\n */\nexport function convertPropertyType(\n    propType: unknown,\n    ctx: { resolver?: unknown } | undefined\n): ts.Node | t.TypeDefinition {\n    if (typeof propType === \"string\") {\n        if (!ctx) {\n            throw new Error(\"Context is required for circular $ref (recursive schemas)\");\n        }\n        return t.reference(propType);\n    }\n    return propType as ts.Node | t.TypeDefinition;\n}\n\n/**\n * Converts object properties to TypeScript property definitions\n * Returns an object mapping property names to their types\n */\nexport function convertObjectProperties(\n    properties: Record<string, SchemaObject | ReferenceObject>,\n    schema: SchemaObject,\n    isPartial: boolean,\n    convertSchema: (schema: SchemaObject | ReferenceObject) => unknown,\n    ctx: { resolver?: unknown } | undefined\n): Record<string, t.TypeDefinition> {\n    return Object.fromEntries(\n        Object.entries(properties).map(([prop, propSchema]) => {\n            const rawPropType = convertSchema(propSchema);\n            const propType = convertPropertyType(rawPropType, ctx);\n            const isRequired = isPropertyRequired(prop, schema, isPartial);\n            // Cast to t.TypeDefinition since t.optional requires it\n            const finalType = isRequired ? propType : t.optional(propType as t.TypeDefinition);\n            return [wrapWithQuotesIfNeeded(prop), finalType as t.TypeDefinition];\n        })\n    );\n}\n\n/**\n * Handles array schema conversion with proper readonly wrapping\n */\nexport function handleArraySchema(\n    schema: SchemaObject,\n    shouldWrapReadonly: boolean,\n    convertSchema: (schema: SchemaObject | ReferenceObject) => unknown,\n    ctx: { resolver?: unknown } | undefined\n): ts.Node | t.TypeDefinitionObject {\n    let arrayOfType: ts.Node | t.TypeDefinition;\n\n    if (schema.items) {\n        const rawType = convertSchema(schema.items);\n        arrayOfType = convertPropertyType(rawType, ctx);\n    } else {\n        arrayOfType = t.any();\n    }\n\n    const wrappedArray = maybeWrapReadonly(t.array(arrayOfType as t.TypeDefinition), shouldWrapReadonly);\n    return schema.nullable ? t.union([wrappedArray as t.TypeDefinition, t.reference(\"null\")]) : wrappedArray;\n}\n\n/**\n * Builds the final object type by combining properties and additional properties\n */\nexport function buildObjectType(\n    props: Record<string, t.TypeDefinition>,\n    additionalPropertiesType: ts.Node | t.TypeDefinition | undefined,\n    shouldWrapReadonly: boolean\n): ts.Node | t.TypeDefinitionObject {\n    let additionalProperties;\n    if (additionalPropertiesType) {\n        additionalProperties = createAdditionalPropertiesSignature(additionalPropertiesType as t.TypeDefinition);\n    }\n\n    const objectType = additionalProperties ? t.intersection([props, additionalProperties]) : props;\n    return maybeWrapReadonly(objectType as t.TypeDefinitionObject, shouldWrapReadonly);\n}\n\n/**\n * Wraps an object type as Partial if needed, handling both inline and named types\n */\nexport function wrapObjectTypeForOutput(\n    finalType: ts.Node | t.TypeDefinitionObject,\n    isPartial: boolean,\n    isInline: boolean,\n    name: string | undefined\n): ts.Node | t.TypeDefinitionObject {\n    const wrappedType = isPartial ? t.reference(\"Partial\", [finalType as t.TypeDefinition]) : finalType;\n\n    if (isInline) {\n        return wrappedType;\n    }\n\n    if (!name) {\n        throw new Error(\"Name is required to convert an object schema to a type reference\");\n    }\n\n    return t.type(name, wrappedType as t.TypeDefinition);\n}\n\n/**\n * Handles oneOf composition by creating a union type\n * Returns single schema directly if only one item\n */\nexport function handleOneOf(\n    schemas: ReadonlyArray<SchemaObject | ReferenceObject>,\n    isNullable: boolean,\n    convertSchema: (schema: SchemaObject | ReferenceObject) => ts.Node | t.TypeDefinition\n): ts.Node {\n    if (schemas.length === 1) {\n        return convertSchema(schemas[0]!) as ts.Node;\n    }\n\n    const types: (ts.Node | t.TypeDefinition)[] = convertSchemasToTypes(schemas, convertSchema);\n    if (isNullable) {\n        return t.union([...types, t.reference(\"null\")] as t.TypeDefinition[]);\n    }\n    return t.union(types as t.TypeDefinition[]);\n}\n\n/**\n * Handles anyOf composition by creating union of value OR array\n * Special OpenAPI semantic: T | T[]\n */\nexport function handleAnyOf(\n    schemas: ReadonlyArray<SchemaObject | ReferenceObject>,\n    isNullable: boolean,\n    shouldWrapReadonly: boolean,\n    convertSchema: (schema: SchemaObject | ReferenceObject) => ts.Node | t.TypeDefinition\n): ts.Node {\n    if (schemas.length === 1) {\n        return convertSchema(schemas[0]!) as ts.Node;\n    }\n\n    const types: (ts.Node | t.TypeDefinition)[] = convertSchemasToTypes(schemas, convertSchema);\n    const oneOf = t.union(types as t.TypeDefinition[]);\n    const arrayOfOneOf = maybeWrapReadonly(t.array(oneOf), shouldWrapReadonly);\n\n    const unionParts: t.TypeDefinition[] = [oneOf, arrayOfOneOf as t.TypeDefinition];\n    if (isNullable) {\n        unionParts.push(t.reference(\"null\"));\n    }\n\n    return t.union(unionParts);\n}\n\n/**\n * Handles array of types (OpenAPI 3.1 feature) by creating a union\n */\nexport function handleTypeArray(\n    types: ReadonlyArray<string>,\n    schema: SchemaObject,\n    isNullable: boolean,\n    convertSchema: (schema: SchemaObject | ReferenceObject) => ts.Node | t.TypeDefinition\n): ts.Node {\n    if (types.length === 1) {\n        return convertSchema({ ...schema, type: types[0]! } as SchemaObject) as ts.Node;\n    }\n\n    const typeSchemas = types.map((type) => ({ ...schema, type }) as SchemaObject);\n    const typeDefs: (ts.Node | t.TypeDefinition)[] = convertSchemasToTypes(typeSchemas, convertSchema);\n\n    if (isNullable) {\n        return t.union([...typeDefs, t.reference(\"null\")] as t.TypeDefinition[]);\n    }\n    return t.union(typeDefs as t.TypeDefinition[]);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/openApiToTypescript.test.ts","messages":[{"ruleId":"max-statements","severity":2,"message":"Arrow function has too many statements (43). Maximum allowed is 30.","line":19,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":332,"endColumn":2},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":413,"column":50,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":413,"endColumn":52,"suggestions":[{"messageId":"removeAsync","fix":{"range":[14579,14585],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":458,"column":55,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":458,"endColumn":57,"suggestions":[{"messageId":"removeAsync","fix":{"range":[16123,16129],"text":""},"desc":"Remove 'async'."}]},{"ruleId":"max-statements","severity":2,"message":"Arrow function has too many statements (44). Maximum allowed is 30.","line":599,"column":43,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":948,"endColumn":2}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getTypescriptFromOpenApi, type TsConversionContext } from \"./openApiToTypescript.js\";\n\nimport type { SchemaObject, SchemasObject } from \"openapi3-ts\";\nimport { ts } from \"tanu\";\nimport { describe, expect, test } from \"vitest\";\nimport { makeSchemaResolver } from \"./makeSchemaResolver.js\";\nimport { asComponentSchema } from \"./utils.js\";\nimport type { TemplateContext } from \"./template-context.js\";\nimport type { OpenAPIV3 } from \"openapi-types\";\n\nconst makeSchema = (schema: SchemaObject | OpenAPIV3.SchemaObject) => schema as SchemaObject;\nconst getSchemaAsTsString = (schema: SchemaObject, meta?: { name: string }, options?: TemplateContext[\"options\"]) =>\n    printTs(getTypescriptFromOpenApi({ schema: makeSchema(schema), meta, options }) as ts.Node);\n\nconst file = ts.createSourceFile(\"\", \"\", ts.ScriptTarget.ESNext, true);\nconst printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\nconst printTs = (node: ts.Node) => printer.printNode(ts.EmitHint.Unspecified, node, file);\n\ntest(\"getSchemaAsTsString\", () => {\n    expect(getSchemaAsTsString({ type: \"null\" })).toMatchInlineSnapshot('\"null\"');\n    expect(getSchemaAsTsString({ type: \"boolean\" })).toMatchInlineSnapshot('\"boolean\"');\n    expect(getSchemaAsTsString({ type: \"string\" })).toMatchInlineSnapshot('\"string\"');\n    expect(getSchemaAsTsString({ type: \"number\" })).toMatchInlineSnapshot('\"number\"');\n    expect(getSchemaAsTsString({ type: \"integer\" })).toMatchInlineSnapshot('\"number\"');\n    expect(getSchemaAsTsString({})).toMatchInlineSnapshot('\"unknown\"');\n\n    expect(getSchemaAsTsString({ type: \"null\" }, { name: \"nullType\" })).toMatchInlineSnapshot(\n        '\"export type nullType = null;\"'\n    );\n    expect(getSchemaAsTsString({ type: \"boolean\" }, { name: \"booleanType\" })).toMatchInlineSnapshot(\n        '\"export type booleanType = boolean;\"'\n    );\n    expect(getSchemaAsTsString({ type: \"string\" }, { name: \"stringType\" })).toMatchInlineSnapshot(\n        '\"export type stringType = string;\"'\n    );\n    expect(getSchemaAsTsString({ type: \"number\" }, { name: \"numberType\" })).toMatchInlineSnapshot(\n        '\"export type numberType = number;\"'\n    );\n    expect(getSchemaAsTsString({ type: \"integer\" }, { name: \"integerType\" })).toMatchInlineSnapshot(\n        '\"export type integerType = number;\"'\n    );\n    expect(getSchemaAsTsString({}, { name: \"unknownType\" })).toMatchInlineSnapshot(\n        '\"export type unknownType = unknown;\"'\n    );\n\n    expect(getSchemaAsTsString({ type: \"array\", items: { type: \"string\" } })).toMatchInlineSnapshot('\"Array<string>\"');\n    expect(getSchemaAsTsString({ type: \"object\" }, { name: \"EmptyObject\" })).toMatchInlineSnapshot(\n        '\"export type EmptyObject = {};\"'\n    );\n    expect(getSchemaAsTsString({ type: \"object\", properties: { str: { type: \"string\" } } }, { name: \"BasicObject\" }))\n        .toMatchInlineSnapshot(`\n          \"export type BasicObject = Partial<{\n              str: string;\n          }>;\"\n        `);\n    expect(\n        getSchemaAsTsString(\n            { type: \"object\", properties: { str: { type: \"string\" }, nb: { type: \"number\" } } },\n            { name: \"BasicObject2\" }\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type BasicObject2 = Partial<{\n          str: string;\n          nb: number;\n      }>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: { str: { type: \"string\" }, nb: { type: \"number\" } },\n                required: [\"str\", \"nb\"],\n            },\n            { name: \"AllPropertiesRequired\" }\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type AllPropertiesRequired = {\n          str: string;\n          nb: number;\n      };\"\n    `);\n    expect(\n        getSchemaAsTsString(\n            { type: \"object\", properties: { str: { type: \"string\" }, nb: { type: \"number\" } }, required: [\"str\"] },\n            { name: \"SomeOptionalProps\" }\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type SomeOptionalProps = {\n          str: string;\n          nb?: number | undefined;\n      };\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: {\n                    str: { type: \"string\" },\n                    nb: { type: \"number\" },\n                    nested: {\n                        type: \"object\",\n                        properties: {\n                            nested_prop: { type: \"boolean\" },\n                        },\n                    },\n                },\n            },\n            { name: \"ObjectWithNestedProp\" }\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithNestedProp = Partial<{\n          str: string;\n          nb: number;\n          nested: Partial<{\n              nested_prop: boolean;\n          }>;\n      }>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            { type: \"object\", properties: { str: { type: \"string\" } }, additionalProperties: { type: \"number\" } },\n            { name: \"ObjectWithAdditionalPropsNb\" }\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithAdditionalPropsNb = Partial<{\n          str: string;\n      } & {\n          [key: string]: number;\n      }>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: { str: { type: \"string\" } },\n                additionalProperties: { type: \"object\", properties: { prop: { type: \"boolean\" } } },\n            },\n            { name: \"ObjectWithNestedRecordBoolean\" }\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithNestedRecordBoolean = Partial<{\n          str: string;\n      } & {\n          [key: string]: Partial<{\n              prop: boolean;\n          }>;\n      }>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString({\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    str: { type: \"string\" },\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(`\n      \"Array<Partial<{\n          str: string;\n      }>>\"\n    `);\n\n    expect(\n        getSchemaAsTsString({\n            type: \"array\",\n            items: {\n                type: \"array\",\n                items: {\n                    type: \"string\",\n                },\n            },\n        })\n    ).toMatchInlineSnapshot('\"Array<Array<string>>\"');\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: {\n                    enumprop: { type: \"string\", enum: [\"aaa\", \"bbb\", \"ccc\"] },\n                },\n            },\n            { name: \"ObjectWithEnum\" }\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithEnum = Partial<{\n          enumprop: \"aaa\" | \"bbb\" | \"ccc\";\n      }>;\"\n    `);\n\n    expect(getSchemaAsTsString({ type: \"string\", enum: [\"aaa\", \"bbb\", \"ccc\"] })).toMatchInlineSnapshot(\n        '\"\"aaa\" | \"bbb\" | \"ccc\"\"'\n    );\n    expect(\n        getSchemaAsTsString({ type: \"string\", enum: [\"aaa\", \"bbb\", \"ccc\"] }, { name: \"StringENum\" })\n    ).toMatchInlineSnapshot('\"export type StringENum = \"aaa\" | \"bbb\" | \"ccc\";\"');\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: {\n                    union: { oneOf: [{ type: \"string\" }, { type: \"number\" }] },\n                },\n            },\n            { name: \"ObjectWithUnion\" }\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithUnion = Partial<{\n          union: string | number;\n      }>;\"\n    `);\n    expect(getSchemaAsTsString({ oneOf: [{ type: \"string\" }, { type: \"number\" }] })).toMatchInlineSnapshot(\n        '\"string | number\"'\n    );\n    expect(\n        getSchemaAsTsString({ oneOf: [{ type: \"string\" }, { type: \"number\" }] }, { name: \"StringOrNumber\" })\n    ).toMatchInlineSnapshot('\"export type StringOrNumber = string | number;\"');\n\n    expect(getSchemaAsTsString({ allOf: [{ type: \"string\" }, { type: \"number\" }] })).toMatchInlineSnapshot(\n        '\"string & number\"'\n    );\n    expect(\n        getSchemaAsTsString({ allOf: [{ type: \"string\" }, { type: \"number\" }] }, { name: \"StringAndNumber\" })\n    ).toMatchInlineSnapshot('\"export type StringAndNumber = string & number;\"');\n\n    expect(\n        getSchemaAsTsString({ nullable: true, anyOf: [{ type: \"string\" }, { type: \"number\" }] })\n    ).toMatchInlineSnapshot('\"(string | number) | Array<string | number> | null\"');\n    expect(\n        getSchemaAsTsString({ nullable: true, oneOf: [{ type: \"string\" }, { type: \"number\" }] })\n    ).toMatchInlineSnapshot(`\"string | number | null\"`);\n    expect(\n        getSchemaAsTsString(\n            { nullable: true, oneOf: [{ type: \"string\" }, { type: \"number\" }] },\n            { name: \"StringOrNumber\" }\n        )\n    ).toMatchInlineSnapshot(`\"export type StringOrNumber = string | number | null;\"`);\n\n    expect(\n        getSchemaAsTsString({ nullable: true, allOf: [{ type: \"string\" }, { type: \"number\" }] })\n    ).toMatchInlineSnapshot('\"(string & number) | null\"');\n    expect(\n        getSchemaAsTsString(\n            { nullable: true, allOf: [{ type: \"string\" }, { type: \"number\" }] },\n            { name: \"StringAndNumber\" }\n        )\n    ).toMatchInlineSnapshot('\"export type StringAndNumber = (string & number) | null;\"');\n    expect(\n        getSchemaAsTsString({ nullable: true, anyOf: [{ type: \"string\" }, { type: \"number\" }] })\n    ).toMatchInlineSnapshot('\"(string | number) | Array<string | number> | null\"');\n    expect(\n        getSchemaAsTsString(\n            { anyOf: [{ type: \"string\" }, { type: \"number\" }] },\n            { name: \"StringAndNumberMaybeMultiple\" }\n        )\n    ).toMatchInlineSnapshot('\"export type StringAndNumberMaybeMultiple = (string | number) | Array<string | number>;\"');\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: {\n                    unionOrArrayOfUnion: { anyOf: [{ type: \"string\" }, { type: \"number\" }] },\n                },\n            },\n            { name: \"ObjectWithArrayUnion\" }\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithArrayUnion = Partial<{\n          unionOrArrayOfUnion: (string | number) | Array<string | number>;\n      }>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: {\n                    intersection: { allOf: [{ type: \"string\" }, { type: \"number\" }] },\n                },\n            },\n            { name: \"ObjectWithIntersection\" }\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithIntersection = Partial<{\n          intersection: string & number;\n      }>;\"\n    `);\n\n    expect(getSchemaAsTsString({ type: \"string\", enum: [\"aaa\", \"bbb\", \"ccc\"] })).toMatchInlineSnapshot(\n        '\"\"aaa\" | \"bbb\" | \"ccc\"\"'\n    );\n    expect(getSchemaAsTsString({ type: \"number\", enum: [1, 2, 3] })).toMatchInlineSnapshot('\"1 | 2 | 3\"');\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                required: [\"propNumber\", \"propString\", \"propBoolean\"],\n                properties: {\n                    propNumber: {\n                        type: [\"number\"],\n                        nullable: true,\n                    },\n                    propString: {\n                        type: [\"string\"],\n                        nullable: true,\n                    },\n                    propBoolean: {\n                        type: [\"boolean\"],\n                        nullable: true,\n                    },\n                },\n            },\n            { name: \"Category\" }\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type Category = {\n          propNumber: number | null;\n          propString: string | null;\n          propBoolean: boolean | null;\n      };\"\n    `);\n});\n\ndescribe(\"getSchemaAsTsString with context\", () => {\n    test(\"with ref\", () => {\n        const schemas = {\n            Root: {\n                type: \"object\",\n                properties: {\n                    str: { type: \"string\" },\n                    nb: { type: \"number\" },\n                    nested: { $ref: \"#/components/schemas/Nested\" },\n                },\n            },\n            Nested: {\n                type: \"object\",\n                properties: {\n                    nested_prop: { type: \"boolean\" },\n                },\n            },\n        } as SchemasObject;\n\n        const ctx: TsConversionContext = {\n            nodeByRef: {},\n            visitedRefs: {},\n            resolver: makeSchemaResolver({ components: { schemas } } as any),\n        };\n        Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n        expect(printTs(getTypescriptFromOpenApi({ schema: schemas[\"Root\"]!, meta: { name: \"Root\" }, ctx }) as ts.Node))\n            .toMatchInlineSnapshot(`\n              \"export type Root = Partial<{\n                  str: string;\n                  nb: number;\n                  nested: Nested;\n              }>;\"\n            `);\n    });\n\n    test(\"with multiple nested refs\", () => {\n        const schemas = {\n            Root2: {\n                type: \"object\",\n                properties: {\n                    str: { type: \"string\" },\n                    nb: { type: \"number\" },\n                    nested: { $ref: \"#/components/schemas/Nested2\" },\n                },\n            },\n            Nested2: {\n                type: \"object\",\n                properties: {\n                    nested_prop: { type: \"boolean\" },\n                    deeplyNested: { $ref: \"#/components/schemas/DeeplyNested\" },\n                },\n            },\n            DeeplyNested: {\n                type: \"array\",\n                items: { $ref: \"#/components/schemas/VeryDeeplyNested\" },\n            },\n            VeryDeeplyNested: {\n                type: \"string\",\n                enum: [\"aaa\", \"bbb\", \"ccc\"],\n            },\n        } as SchemasObject;\n\n        const ctx: TsConversionContext = {\n            nodeByRef: {},\n            visitedRefs: {},\n            resolver: makeSchemaResolver({ components: { schemas } } as any),\n        };\n        Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n        expect(\n            printTs(getTypescriptFromOpenApi({ schema: schemas[\"Root2\"]!, meta: { name: \"Root2\" }, ctx }) as ts.Node)\n        ).toMatchInlineSnapshot(`\n          \"export type Root2 = Partial<{\n              str: string;\n              nb: number;\n              nested: Nested2;\n          }>;\"\n        `);\n    });\n\n    test(\"with indirect recursive ref\", async () => {\n        const schemas = {\n            Root3: {\n                type: \"object\",\n                properties: {\n                    str: { type: \"string\" },\n                    nb: { type: \"number\" },\n                    nested: { $ref: \"#/components/schemas/Nested3\" },\n                    arrayOfNested: { type: \"array\", items: { $ref: \"#/components/schemas/Nested3\" } },\n                },\n            },\n            Nested3: {\n                type: \"object\",\n                properties: {\n                    nested_prop: { type: \"boolean\" },\n                    backToRoot: { $ref: \"#/components/schemas/Root3\" },\n                },\n            },\n        } as SchemasObject;\n\n        const ctx: TsConversionContext = {\n            nodeByRef: {},\n            visitedRefs: {},\n            resolver: makeSchemaResolver({ components: { schemas } } as any),\n        };\n        Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n\n        expect(\n            printTs(\n                getTypescriptFromOpenApi({\n                    schema: schemas[\"Root3\"]!,\n                    meta: { name: \"Root3\", $ref: \"#/components/schemas/Root3\" },\n                    ctx,\n                }) as ts.Node\n            )\n        ).toMatchInlineSnapshot(`\n          \"export type Root3 = Partial<{\n              str: string;\n              nb: number;\n              nested: Nested3;\n              arrayOfNested: Array<Nested3>;\n          }>;\"\n        `);\n    });\n\n    test(\"with direct (self) recursive ref\", async () => {\n        const schemas = {\n            Root4: {\n                type: \"object\",\n                properties: {\n                    str: { type: \"string\" },\n                    nb: { type: \"number\" },\n                    self: { $ref: \"#/components/schemas/Root4\" },\n                    nested: { $ref: \"#/components/schemas/Nested4\" },\n                    arrayOfSelf: { type: \"array\", items: { $ref: \"#/components/schemas/Root4\" } },\n                },\n            },\n            Nested4: {\n                type: \"object\",\n                properties: {\n                    nested_prop: { type: \"boolean\" },\n                    backToRoot: { $ref: \"#/components/schemas/Root4\" },\n                },\n            },\n        } as SchemasObject;\n\n        const ctx: TsConversionContext = {\n            nodeByRef: {},\n            visitedRefs: {},\n            resolver: makeSchemaResolver({ components: { schemas } } as any),\n        };\n        Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n        const result = getTypescriptFromOpenApi({\n            schema: schemas[\"Root4\"]!,\n            meta: { name: \"Root4\", $ref: \"#/components/schemas/Root4\" },\n            ctx,\n        }) as ts.Node;\n\n        expect(printTs(result)).toMatchInlineSnapshot(`\n          \"export type Root4 = Partial<{\n              str: string;\n              nb: number;\n              self: Root4;\n              nested: Nested4;\n              arrayOfSelf: Array<Root4>;\n          }>;\"\n        `);\n    });\n\n    test(\"same schemas as openApiToZod\", () => {\n        const schemas = {\n            User: {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    middle: { $ref: \"#/components/schemas/Middle\" },\n                },\n            },\n            Middle: {\n                type: \"object\",\n                properties: {\n                    user: { $ref: \"#/components/schemas/User\" },\n                },\n            },\n            Root: {\n                type: \"object\",\n                properties: {\n                    recursive: {\n                        $ref: \"#/components/schemas/User\",\n                    },\n                    basic: { type: \"number\" },\n                },\n            },\n        } as SchemasObject;\n\n        const ctx: TsConversionContext = {\n            nodeByRef: {},\n            visitedRefs: {},\n            resolver: makeSchemaResolver({ components: { schemas } } as any),\n        };\n        Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n        const result = getTypescriptFromOpenApi({\n            schema: schemas[\"Root\"]!,\n            meta: { name: \"Root\", $ref: \"#/components/schemas/Root\" },\n            ctx,\n        }) as ts.Node;\n\n        expect(printTs(result)).toMatchInlineSnapshot(`\n          \"export type Root = Partial<{\n              recursive: User;\n              basic: number;\n          }>;\"\n        `);\n    });\n\n    test(\"anyOf with refs\", () => {\n        const schemas = {\n            User: {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                },\n            },\n            Member: {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                },\n            },\n            Root: {\n                type: \"object\",\n                properties: {\n                    user: { oneOf: [{ $ref: \"#/components/schemas/User\" }, { $ref: \"#/components/schemas/Member\" }] },\n                    users: {\n                        type: \"array\",\n                        items: {\n                            anyOf: [{ $ref: \"#/components/schemas/User\" }, { $ref: \"#/components/schemas/Member\" }],\n                        },\n                    },\n                    basic: { type: \"number\" },\n                },\n            },\n        } as SchemasObject;\n\n        const ctx: TsConversionContext = {\n            nodeByRef: {},\n            visitedRefs: {},\n            resolver: makeSchemaResolver({ components: { schemas } } as any),\n        };\n        Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n        const result = getTypescriptFromOpenApi({\n            schema: schemas[\"Root\"]!,\n            meta: { name: \"Root\", $ref: \"#/components/schemas/Root\" },\n            ctx,\n        }) as ts.Node;\n\n        expect(printTs(result)).toMatchInlineSnapshot(`\n          \"export type Root = Partial<{\n              user: User | Member;\n              users: Array<(User | Member) | Array<User | Member>>;\n              basic: number;\n          }>;\"\n        `);\n    });\n});\n\ntest(\"getSchemaAsTsString with readonly\", () => {\n    const options: TemplateContext[\"options\"] = {\n        allReadonly: true,\n    };\n    expect(getSchemaAsTsString({ type: \"null\" }, undefined, options)).toMatchInlineSnapshot('\"null\"');\n    expect(getSchemaAsTsString({ type: \"boolean\" }, undefined, options)).toMatchInlineSnapshot('\"boolean\"');\n    expect(getSchemaAsTsString({ type: \"string\" }, undefined, options)).toMatchInlineSnapshot('\"string\"');\n    expect(getSchemaAsTsString({ type: \"number\" }, undefined, options)).toMatchInlineSnapshot('\"number\"');\n    expect(getSchemaAsTsString({ type: \"integer\" }, undefined, options)).toMatchInlineSnapshot('\"number\"');\n    expect(getSchemaAsTsString({}, undefined, options)).toMatchInlineSnapshot('\"unknown\"');\n\n    expect(getSchemaAsTsString({ type: \"null\" }, { name: \"nullType\" }, options)).toMatchInlineSnapshot(\n        '\"export type nullType = null;\"'\n    );\n    expect(getSchemaAsTsString({ type: \"boolean\" }, { name: \"booleanType\" }, options)).toMatchInlineSnapshot(\n        '\"export type booleanType = boolean;\"'\n    );\n    expect(getSchemaAsTsString({ type: \"string\" }, { name: \"stringType\" }, options)).toMatchInlineSnapshot(\n        '\"export type stringType = string;\"'\n    );\n    expect(getSchemaAsTsString({ type: \"number\" }, { name: \"numberType\" }, options)).toMatchInlineSnapshot(\n        '\"export type numberType = number;\"'\n    );\n    expect(getSchemaAsTsString({ type: \"integer\" }, { name: \"integerType\" }, options)).toMatchInlineSnapshot(\n        '\"export type integerType = number;\"'\n    );\n    expect(getSchemaAsTsString({}, { name: \"unknownType\" }, options)).toMatchInlineSnapshot(\n        '\"export type unknownType = unknown;\"'\n    );\n\n    expect(getSchemaAsTsString({ type: \"array\", items: { type: \"string\" } }, undefined, options)).toMatchInlineSnapshot(\n        '\"Readonly<Array<string>>\"'\n    );\n    expect(getSchemaAsTsString({ type: \"object\" }, { name: \"EmptyObject\" }, options)).toMatchInlineSnapshot(\n        '\"export type EmptyObject = {};\"'\n    );\n    expect(\n        getSchemaAsTsString(\n            { type: \"object\", properties: { str: { type: \"string\" } } },\n            { name: \"BasicObject\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type BasicObject = Partial<Readonly<{\n          str: string;\n      }>>;\"\n    `);\n    expect(\n        getSchemaAsTsString(\n            { type: \"object\", properties: { str: { type: \"string\" }, nb: { type: \"number\" } } },\n            { name: \"BasicObject2\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type BasicObject2 = Partial<Readonly<{\n          str: string;\n          nb: number;\n      }>>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: { str: { type: \"string\" }, nb: { type: \"number\" } },\n                required: [\"str\", \"nb\"],\n            },\n            { name: \"AllPropertiesRequired\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type AllPropertiesRequired = Readonly<{\n          str: string;\n          nb: number;\n      }>;\"\n    `);\n    expect(\n        getSchemaAsTsString(\n            { type: \"object\", properties: { str: { type: \"string\" }, nb: { type: \"number\" } }, required: [\"str\"] },\n            { name: \"SomeOptionalProps\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type SomeOptionalProps = Readonly<{\n          str: string;\n          nb?: number | undefined;\n      }>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: {\n                    str: { type: \"string\" },\n                    nb: { type: \"number\" },\n                    nested: {\n                        type: \"object\",\n                        properties: {\n                            nested_prop: { type: \"boolean\" },\n                        },\n                    },\n                },\n            },\n            { name: \"ObjectWithNestedProp\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithNestedProp = Partial<Readonly<{\n          str: string;\n          nb: number;\n          nested: Partial<Readonly<{\n              nested_prop: boolean;\n          }>>;\n      }>>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            { type: \"object\", properties: { str: { type: \"string\" } }, additionalProperties: { type: \"number\" } },\n            { name: \"ObjectWithAdditionalPropsNb\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithAdditionalPropsNb = Partial<Readonly<{\n          str: string;\n      } & {\n          [key: string]: number;\n      }>>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: { str: { type: \"string\" } },\n                additionalProperties: { type: \"object\", properties: { prop: { type: \"boolean\" } } },\n            },\n            { name: \"ObjectWithNestedRecordBoolean\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithNestedRecordBoolean = Partial<Readonly<{\n          str: string;\n      } & {\n          [key: string]: Partial<Readonly<{\n              prop: boolean;\n          }>>;\n      }>>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"array\",\n                items: {\n                    type: \"object\",\n                    properties: {\n                        str: { type: \"string\" },\n                    },\n                },\n            },\n            undefined,\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"Readonly<Array<Partial<Readonly<{\n          str: string;\n      }>>>>\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"array\",\n                items: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\",\n                    },\n                },\n            },\n            undefined,\n            options\n        )\n    ).toMatchInlineSnapshot('\"Readonly<Array<Readonly<Array<string>>>>\"');\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: {\n                    enumprop: { type: \"string\", enum: [\"aaa\", \"bbb\", \"ccc\"] },\n                },\n            },\n            { name: \"ObjectWithEnum\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithEnum = Partial<Readonly<{\n          enumprop: \"aaa\" | \"bbb\" | \"ccc\";\n      }>>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString({ type: \"string\", enum: [\"aaa\", \"bbb\", \"ccc\"] }, undefined, options)\n    ).toMatchInlineSnapshot('\"\"aaa\" | \"bbb\" | \"ccc\"\"');\n    expect(\n        getSchemaAsTsString({ type: \"string\", enum: [\"aaa\", \"bbb\", \"ccc\"] }, { name: \"StringENum\" }, options)\n    ).toMatchInlineSnapshot('\"export type StringENum = \"aaa\" | \"bbb\" | \"ccc\";\"');\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: {\n                    union: { oneOf: [{ type: \"string\" }, { type: \"number\" }] },\n                },\n            },\n            { name: \"ObjectWithUnion\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithUnion = Partial<Readonly<{\n          union: string | number;\n      }>>;\"\n    `);\n    expect(\n        getSchemaAsTsString({ oneOf: [{ type: \"string\" }, { type: \"number\" }] }, undefined, options)\n    ).toMatchInlineSnapshot('\"string | number\"');\n    expect(\n        getSchemaAsTsString({ oneOf: [{ type: \"string\" }, { type: \"number\" }] }, { name: \"StringOrNumber\" }, options)\n    ).toMatchInlineSnapshot('\"export type StringOrNumber = string | number;\"');\n\n    expect(\n        getSchemaAsTsString({ allOf: [{ type: \"string\" }, { type: \"number\" }] }, undefined, options)\n    ).toMatchInlineSnapshot('\"string & number\"');\n    expect(\n        getSchemaAsTsString({ allOf: [{ type: \"string\" }, { type: \"number\" }] }, { name: \"StringAndNumber\" }, options)\n    ).toMatchInlineSnapshot('\"export type StringAndNumber = string & number;\"');\n\n    expect(\n        getSchemaAsTsString({ nullable: true, anyOf: [{ type: \"string\" }, { type: \"number\" }] }, undefined, options)\n    ).toMatchInlineSnapshot('\"(string | number) | Readonly<Array<string | number>> | null\"');\n    expect(\n        getSchemaAsTsString({ nullable: true, oneOf: [{ type: \"string\" }, { type: \"number\" }] }, undefined, options)\n    ).toMatchInlineSnapshot(`\"string | number | null\"`);\n    expect(\n        getSchemaAsTsString(\n            { nullable: true, oneOf: [{ type: \"string\" }, { type: \"number\" }] },\n            { name: \"StringOrNumber\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\"export type StringOrNumber = string | number | null;\"`);\n\n    expect(\n        getSchemaAsTsString({ nullable: true, allOf: [{ type: \"string\" }, { type: \"number\" }] }, undefined, options)\n    ).toMatchInlineSnapshot('\"(string & number) | null\"');\n    expect(\n        getSchemaAsTsString(\n            { nullable: true, allOf: [{ type: \"string\" }, { type: \"number\" }] },\n            { name: \"StringAndNumber\" },\n            options\n        )\n    ).toMatchInlineSnapshot('\"export type StringAndNumber = (string & number) | null;\"');\n    expect(\n        getSchemaAsTsString({ nullable: true, anyOf: [{ type: \"string\" }, { type: \"number\" }] }, undefined, options)\n    ).toMatchInlineSnapshot('\"(string | number) | Readonly<Array<string | number>> | null\"');\n    expect(\n        getSchemaAsTsString(\n            { anyOf: [{ type: \"string\" }, { type: \"number\" }] },\n            { name: \"StringAndNumberMaybeMultiple\" },\n            options\n        )\n    ).toMatchInlineSnapshot(\n        '\"export type StringAndNumberMaybeMultiple = (string | number) | Readonly<Array<string | number>>;\"'\n    );\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: {\n                    unionOrArrayOfUnion: { anyOf: [{ type: \"string\" }, { type: \"number\" }] },\n                },\n            },\n            { name: \"ObjectWithArrayUnion\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithArrayUnion = Partial<Readonly<{\n          unionOrArrayOfUnion: (string | number) | Readonly<Array<string | number>>;\n      }>>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                properties: {\n                    intersection: { allOf: [{ type: \"string\" }, { type: \"number\" }] },\n                },\n            },\n            { name: \"ObjectWithIntersection\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type ObjectWithIntersection = Partial<Readonly<{\n          intersection: string & number;\n      }>>;\"\n    `);\n\n    expect(\n        getSchemaAsTsString({ type: \"string\", enum: [\"aaa\", \"bbb\", \"ccc\"] }, undefined, options)\n    ).toMatchInlineSnapshot('\"\"aaa\" | \"bbb\" | \"ccc\"\"');\n    expect(getSchemaAsTsString({ type: \"number\", enum: [1, 2, 3] }, undefined, options)).toMatchInlineSnapshot(\n        '\"1 | 2 | 3\"'\n    );\n\n    expect(\n        getSchemaAsTsString(\n            {\n                type: \"object\",\n                required: [\"propNumber\", \"propString\", \"propBoolean\"],\n                properties: {\n                    propNumber: {\n                        type: [\"number\"],\n                        nullable: true,\n                    },\n                    propString: {\n                        type: [\"string\"],\n                        nullable: true,\n                    },\n                    propBoolean: {\n                        type: [\"boolean\"],\n                        nullable: true,\n                    },\n                },\n            },\n            { name: \"Category\" },\n            options\n        )\n    ).toMatchInlineSnapshot(`\n      \"export type Category = Readonly<{\n          propNumber: number | null;\n          propString: string | null;\n          propBoolean: boolean | null;\n      }>;\"\n    `);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/openApiToTypescript.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Arrow function has too many lines (156). Maximum allowed is 100.","line":40,"column":41,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":195,"endColumn":2},{"ruleId":"sonarjs/function-return-type","severity":2,"message":"Refactor this function to always return the same type.","line":45,"column":65,"nodeType":null,"endLine":45,"endColumn":67},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":46,"column":18,"nodeType":"TSAsExpression","messageId":"never","endLine":46,"endColumn":48},{"ruleId":"max-lines-per-function","severity":2,"message":"Arrow function has too many lines (119). Maximum allowed is 100.","line":59,"column":19,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":177,"endColumn":6},{"ruleId":"max-statements","severity":2,"message":"Arrow function has too many statements (38). Maximum allowed is 30.","line":59,"column":19,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":177,"endColumn":6},{"ruleId":"sonarjs/function-return-type","severity":2,"message":"Refactor this function to always return the same type.","line":59,"column":65,"nodeType":null,"endLine":59,"endColumn":67},{"ruleId":"complexity","severity":2,"message":"Arrow function has a complexity of 31. Maximum allowed is 29.","line":59,"column":65,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":59,"endColumn":67},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":71,"column":24,"nodeType":"TSAsExpression","messageId":"never","endLine":71,"endColumn":103},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":83,"column":24,"nodeType":"TSAsExpression","messageId":"never","endLine":83,"endColumn":103},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":93,"column":24,"nodeType":"TSAsExpression","messageId":"never","endLine":93,"endColumn":103},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":99,"column":59,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":99,"endColumn":75},{"ruleId":"sonarjs/function-return-type","severity":2,"message":"Refactor this function to always return the same type.","line":105,"column":77,"nodeType":null,"endLine":105,"endColumn":79},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":106,"column":30,"nodeType":"TSAsExpression","messageId":"never","endLine":106,"endColumn":112},{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":107,"column":17,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":107,"endColumn":80},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":113,"column":21,"nodeType":"TSAsExpression","messageId":"never","endLine":118,"endColumn":43},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":194,"column":75,"nodeType":"TSAsExpression","messageId":"never","endLine":194,"endColumn":103}],"suppressedMessages":[{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"never\" of template literal expression.","line":176,"column":53,"nodeType":"Identifier","messageId":"invalidType","endLine":176,"endColumn":63,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":9,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ReferenceObject, SchemaObject } from \"openapi3-ts\";\nimport { isReferenceObject } from \"openapi3-ts\";\nimport { t, ts } from \"tanu\";\n\nimport type { DocumentResolver } from \"./makeSchemaResolver.js\";\nimport type { TemplateContext } from \"./template-context.js\";\nimport { inferRequiredSchema } from \"./inferRequiredOnly.js\";\nimport generateJSDocArray from \"./generateJSDocArray.js\";\nimport {\n    buildObjectType,\n    convertObjectProperties,\n    convertSchemasToTypes,\n    handleAnyOf,\n    handleArraySchema,\n    handleBasicPrimitive,\n    handleOneOf,\n    handlePrimitiveEnum,\n    handleReferenceObject,\n    handleTypeArray,\n    isPrimitiveSchemaType,\n    resolveAdditionalPropertiesType,\n    wrapObjectTypeForOutput,\n    wrapTypeIfNeeded,\n} from \"./openApiToTypescript.helpers.js\";\n\ntype TsConversionArgs = {\n    schema: SchemaObject | ReferenceObject;\n    ctx?: TsConversionContext | undefined;\n    meta?: { name?: string; $ref?: string; isInline?: boolean } | undefined;\n    options?: TemplateContext[\"options\"];\n};\n\nexport type TsConversionContext = {\n    nodeByRef: Record<string, ts.Node>;\n    resolver: DocumentResolver;\n    rootRef?: string;\n    visitedRefs?: Record<string, boolean>;\n};\n\nexport const getTypescriptFromOpenApi = ({\n    schema,\n    meta: inheritedMeta,\n    ctx,\n    options,\n}: TsConversionArgs): ts.Node | t.TypeDefinitionObject | string => {\n    const meta = {} as TsConversionArgs[\"meta\"];\n    const isInline = !inheritedMeta?.name;\n\n    if (ctx?.visitedRefs && inheritedMeta?.$ref) {\n        ctx.rootRef = inheritedMeta.$ref;\n        ctx.visitedRefs[inheritedMeta.$ref] = true;\n    }\n\n    if (!schema) {\n        throw new Error(\"Schema is required\");\n    }\n\n    let canBeWrapped = !isInline;\n    const getTs = (): ts.Node | t.TypeDefinitionObject | string => {\n        if (isReferenceObject(schema)) {\n            return handleReferenceObject(schema, ctx, (actualSchema) =>\n                getTypescriptFromOpenApi({ schema: actualSchema, meta, ctx, options })\n            );\n        }\n\n        if (Array.isArray(schema.type)) {\n            return handleTypeArray(\n                schema.type,\n                schema,\n                schema.nullable ?? false,\n                (s) => getTypescriptFromOpenApi({ schema: s, ctx, meta, options }) as t.TypeDefinition\n            );\n        }\n\n        if (schema.type === \"null\") {\n            return t.reference(\"null\");\n        }\n\n        if (schema.oneOf) {\n            return handleOneOf(\n                schema.oneOf,\n                schema.nullable ?? false,\n                (s) => getTypescriptFromOpenApi({ schema: s, ctx, meta, options }) as t.TypeDefinition\n            );\n        }\n\n        // anyOf = oneOf but with 1 or more = `T extends oneOf ? T | T[] : never`\n        if (schema.anyOf) {\n            return handleAnyOf(\n                schema.anyOf,\n                schema.nullable ?? false,\n                options?.allReadonly ?? false,\n                (s) => getTypescriptFromOpenApi({ schema: s, ctx, meta, options }) as t.TypeDefinition\n            );\n        }\n\n        if (schema.allOf) {\n            if (schema.allOf.length === 1) {\n                return getTypescriptFromOpenApi({ schema: schema.allOf[0]!, ctx, meta, options });\n            }\n\n            const { patchRequiredSchemaInLoop, noRequiredOnlyAllof, composedRequiredSchema } =\n                inferRequiredSchema(schema);\n\n            const types = convertSchemasToTypes(noRequiredOnlyAllof, (prop) => {\n                const type = getTypescriptFromOpenApi({ schema: prop, ctx, meta, options }) as t.TypeDefinition;\n                ctx?.resolver && patchRequiredSchemaInLoop(prop, ctx.resolver);\n                return type;\n            });\n\n            if (Object.keys(composedRequiredSchema.properties).length > 0) {\n                types.push(\n                    getTypescriptFromOpenApi({\n                        schema: composedRequiredSchema,\n                        ctx,\n                        meta,\n                        options,\n                    }) as t.TypeDefinition\n                );\n            }\n\n            const intersection = t.intersection(types);\n            return schema.nullable ? t.union([intersection, t.reference(\"null\")]) : intersection;\n        }\n\n        // Handle primitive types (string, number, integer, boolean, null)\n        const schemaType = schema.type;\n        if (schemaType && isPrimitiveSchemaType(schemaType)) {\n            // Try to handle as enum first\n            const enumResult = handlePrimitiveEnum(schema, schemaType);\n            if (enumResult) return enumResult;\n\n            // Handle basic primitive types\n            return handleBasicPrimitive(schemaType, schema.nullable ?? false);\n        }\n\n        if (schemaType === \"array\") {\n            return handleArraySchema(\n                schema,\n                options?.allReadonly ?? false,\n                (items) => getTypescriptFromOpenApi({ schema: items, ctx, meta, options }),\n                ctx\n            );\n        }\n\n        if (schemaType === \"object\" || schema.properties || schema.additionalProperties) {\n            if (!schema.properties) {\n                return {};\n            }\n\n            canBeWrapped = false;\n\n            const isPartial = !schema.required?.length;\n            const shouldWrapReadonly = options?.allReadonly ?? false;\n\n            const additionalPropertiesType = resolveAdditionalPropertiesType(\n                schema.additionalProperties,\n                (additionalSchema) => getTypescriptFromOpenApi({ schema: additionalSchema, ctx, meta, options })\n            );\n\n            const props = convertObjectProperties(\n                schema.properties,\n                schema,\n                isPartial,\n                (propSchema) => getTypescriptFromOpenApi({ schema: propSchema, ctx, meta, options }),\n                ctx\n            );\n\n            const finalType = buildObjectType(props, additionalPropertiesType, shouldWrapReadonly);\n\n            return wrapObjectTypeForOutput(finalType, isPartial, isInline, inheritedMeta?.name);\n        }\n\n        if (!schemaType) return t.unknown();\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        throw new Error(`Unsupported schema type: ${schemaType}`);\n    };\n\n    let tsResult = getTs();\n\n    // Add JSDoc comments\n    if (options?.withDocs && !isReferenceObject(schema)) {\n        const jsDocComments = generateJSDocArray(schema);\n\n        if (\n            jsDocComments.length > 0 &&\n            typeof tsResult === \"object\" &&\n            tsResult.kind !== ts.SyntaxKind.TypeAliasDeclaration\n        ) {\n            tsResult = t.comment(tsResult, jsDocComments);\n        }\n    }\n\n    return canBeWrapped ? wrapTypeIfNeeded(isInline, inheritedMeta?.name, tsResult as t.TypeDefinition) : tsResult;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/openApiToZod.test.ts","messages":[{"ruleId":"sonarjs/no-commented-code","severity":2,"message":"Remove this commented out code.","line":19,"column":5,"nodeType":null,"messageId":"commentedCode","endLine":20,"endColumn":141,"suggestions":[{"messageId":"commentedCodeFix","fix":{"range":[1140,1403],"text":""},"desc":"Remove this commented out code"}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { SchemaObject } from \"openapi3-ts\";\nimport { expect, test } from \"vitest\";\nimport { getZodSchema } from \"./openApiToZod.js\";\nimport type { CodeMetaData, ConversionTypeContext } from \"./CodeMeta.js\";\nimport { makeSchemaResolver } from \"./makeSchemaResolver.js\";\nimport { asComponentSchema } from \"./utils.js\";\n\nconst makeSchema = (schema: SchemaObject) => schema;\nconst getSchemaAsZodString = (schema: SchemaObject, meta?: CodeMetaData) =>\n    getZodSchema({ schema: makeSchema(schema), meta }).toString();\n\ntest(\"getSchemaAsZodString\", () => {\n    expect(getSchemaAsZodString({ type: \"null\" })).toMatchInlineSnapshot('\"z.null()\"');\n    expect(getSchemaAsZodString({ type: \"null\", enum: [\"Dogs\", \"Cats\", \"Mice\"] })).toMatchInlineSnapshot('\"z.null()\"');\n    expect(getSchemaAsZodString({ type: \"boolean\" })).toMatchInlineSnapshot('\"z.boolean()\"');\n    expect(getSchemaAsZodString({ type: \"string\" })).toMatchInlineSnapshot('\"z.string()\"');\n    expect(getSchemaAsZodString({ type: \"number\" })).toMatchInlineSnapshot('\"z.number()\"');\n    expect(getSchemaAsZodString({ type: \"integer\" })).toMatchInlineSnapshot('\"z.number()\"');\n    // expect(getSchemaAsZodString({ type: \"string\", format: \"date-time\" })).toMatchInlineSnapshot('\"z.string().datetime()\"');\n    // expect(getSchemaAsZodString({ type: \"number\", nullable: true, minimum: 0 })).toMatchInlineSnapshot('\"z.number().nullable().gte(0)\"');\n\n    expect(getSchemaAsZodString({ type: \"array\", items: { type: \"string\" } })).toMatchInlineSnapshot(\n        '\"z.array(z.string())\"'\n    );\n    expect(getSchemaAsZodString({ type: \"object\" })).toMatchInlineSnapshot('\"z.object({}).partial().passthrough()\"');\n    expect(getSchemaAsZodString({ type: \"object\", properties: { str: { type: \"string\" } } })).toMatchInlineSnapshot(\n        '\"z.object({ str: z.string() }).partial().passthrough()\"'\n    );\n\n    expect(getSchemaAsZodString({ type: \"object\", properties: { str: { type: \"string\" } } })).toMatchInlineSnapshot(\n        '\"z.object({ str: z.string() }).partial().passthrough()\"'\n    );\n\n    expect(getSchemaAsZodString({ type: \"object\", properties: { nb: { type: \"integer\" } } })).toMatchInlineSnapshot(\n        '\"z.object({ nb: z.number().int() }).partial().passthrough()\"'\n    );\n\n    expect(\n        getSchemaAsZodString({ type: \"object\", properties: { pa: { type: \"number\", minimum: 0 } } })\n    ).toMatchInlineSnapshot('\"z.object({ pa: z.number().gte(0) }).partial().passthrough()\"');\n\n    expect(\n        getSchemaAsZodString({ type: \"object\", properties: { pa: { type: \"number\", minimum: 0, maximum: 100 } } })\n    ).toMatchInlineSnapshot('\"z.object({ pa: z.number().gte(0).lte(100) }).partial().passthrough()\"');\n\n    expect(\n        getSchemaAsZodString({ type: \"object\", properties: { ml: { type: \"string\", minLength: 0 } } })\n    ).toMatchInlineSnapshot('\"z.object({ ml: z.string().min(0) }).partial().passthrough()\"');\n\n    expect(\n        getSchemaAsZodString({ type: \"object\", properties: { dt: { type: \"string\", format: \"date-time\" } } })\n    ).toMatchInlineSnapshot('\"z.object({ dt: z.string().datetime({ offset: true }) }).partial().passthrough()\"');\n\n    expect(\n        getSchemaAsZodString({\n            type: \"object\",\n            properties: {\n                str: { type: \"string\" },\n                nb: { type: \"number\" },\n                nested: {\n                    type: \"object\",\n                    properties: {\n                        nested_prop: { type: \"boolean\" },\n                    },\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\n        '\"z.object({ str: z.string(), nb: z.number(), nested: z.object({ nested_prop: z.boolean() }).partial().passthrough() }).partial().passthrough()\"'\n    );\n\n    expect(\n        getSchemaAsZodString({\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    str: { type: \"string\" },\n                },\n            },\n        })\n    ).toMatchInlineSnapshot('\"z.array(z.object({ str: z.string() }).partial().passthrough())\"');\n\n    expect(\n        getSchemaAsZodString({\n            type: \"array\",\n            items: {\n                type: \"array\",\n                items: {\n                    type: \"string\",\n                },\n            },\n        })\n    ).toMatchInlineSnapshot('\"z.array(z.array(z.string()))\"');\n\n    expect(\n        getSchemaAsZodString({\n            type: \"object\",\n            properties: {\n                union: { oneOf: [{ type: \"string\" }, { type: \"number\" }] },\n            },\n        })\n    ).toMatchInlineSnapshot('\"z.object({ union: z.union([z.string(), z.number()]) }).partial().passthrough()\"');\n\n    expect(\n        getSchemaAsZodString({\n            type: \"object\",\n            oneOf: [\n                {\n                    type: \"object\",\n                    required: [\"type\", \"a\"],\n                    properties: {\n                        type: {\n                            type: \"string\",\n                            enum: [\"a\"],\n                        },\n                        a: {\n                            type: \"string\",\n                        },\n                    },\n                },\n                {\n                    type: \"object\",\n                    required: [\"type\", \"b\"],\n                    properties: {\n                        type: {\n                            type: \"string\",\n                            enum: [\"b\"],\n                        },\n                        b: {\n                            type: \"string\",\n                        },\n                    },\n                },\n            ],\n            discriminator: { propertyName: \"type\" },\n        })\n    ).toMatchInlineSnapshot(`\n      \"\n                      z.discriminatedUnion(\"type\", [z.object({ type: z.literal(\"a\"), a: z.string() }).passthrough(), z.object({ type: z.literal(\"b\"), b: z.string() }).passthrough()])\n                  \"\n    `);\n\n    // returns z.discriminatedUnion, when allOf has single object\n    expect(\n        getSchemaAsZodString({\n            type: \"object\",\n            oneOf: [\n                {\n                    type: \"object\",\n                    allOf: [\n                        {\n                            type: \"object\",\n                            required: [\"type\", \"a\"],\n                            properties: {\n                                type: {\n                                    type: \"string\",\n                                    enum: [\"a\"],\n                                },\n                                a: {\n                                    type: \"string\",\n                                },\n                            },\n                        },\n                    ],\n                },\n                {\n                    type: \"object\",\n                    allOf: [\n                        {\n                            type: \"object\",\n                            required: [\"type\", \"b\"],\n                            properties: {\n                                type: {\n                                    type: \"string\",\n                                    enum: [\"b\"],\n                                },\n                                b: {\n                                    type: \"string\",\n                                },\n                            },\n                        },\n                    ],\n                },\n            ],\n            discriminator: { propertyName: \"type\" },\n        })\n    ).toMatchInlineSnapshot(`\n      \"\n                      z.discriminatedUnion(\"type\", [z.object({ type: z.literal(\"a\"), a: z.string() }).passthrough(), z.object({ type: z.literal(\"b\"), b: z.string() }).passthrough()])\n                  \"\n    `);\n\n    // returns z.union, when allOf has multiple objects\n    expect(\n        getSchemaAsZodString({\n            type: \"object\",\n            oneOf: [\n                {\n                    type: \"object\",\n                    allOf: [\n                        {\n                            type: \"object\",\n                            required: [\"type\", \"a\"],\n                            properties: {\n                                type: {\n                                    type: \"string\",\n                                    enum: [\"a\"],\n                                },\n                                a: {\n                                    type: \"string\",\n                                },\n                            },\n                        },\n                        {\n                            type: \"object\",\n                            required: [\"type\", \"c\"],\n                            properties: {\n                                type: {\n                                    type: \"string\",\n                                    enum: [\"c\"],\n                                },\n                                c: {\n                                    type: \"string\",\n                                },\n                            },\n                        },\n                    ],\n                },\n                {\n                    type: \"object\",\n                    allOf: [\n                        {\n                            type: \"object\",\n                            required: [\"type\", \"b\"],\n                            properties: {\n                                type: {\n                                    type: \"string\",\n                                    enum: [\"b\"],\n                                },\n                                b: {\n                                    type: \"string\",\n                                },\n                            },\n                        },\n                        {\n                            type: \"object\",\n                            required: [\"type\", \"d\"],\n                            properties: {\n                                type: {\n                                    type: \"string\",\n                                    enum: [\"d\"],\n                                },\n                                d: {\n                                    type: \"string\",\n                                },\n                            },\n                        },\n                    ],\n                },\n            ],\n            discriminator: { propertyName: \"type\" },\n        })\n    ).toMatchInlineSnapshot(\n        '\"z.union([z.object({ type: z.literal(\"a\"), a: z.string() }).passthrough().and(z.object({ type: z.literal(\"c\"), c: z.string() }).passthrough()), z.object({ type: z.literal(\"b\"), b: z.string() }).passthrough().and(z.object({ type: z.literal(\"d\"), d: z.string() }).passthrough())])\"'\n    );\n\n    expect(\n        getSchemaAsZodString({\n            type: \"object\",\n            properties: {\n                anyOfExample: { anyOf: [{ type: \"string\" }, { type: \"number\" }] },\n            },\n        })\n    ).toMatchInlineSnapshot('\"z.object({ anyOfExample: z.union([z.string(), z.number()]) }).partial().passthrough()\"');\n\n    expect(\n        getSchemaAsZodString({\n            type: \"object\",\n            properties: {\n                intersection: { allOf: [{ type: \"string\" }, { type: \"number\" }] },\n            },\n        })\n    ).toMatchInlineSnapshot('\"z.object({ intersection: z.string().and(z.number()) }).partial().passthrough()\"');\n\n    expect(getSchemaAsZodString({ type: \"string\", enum: [\"aaa\", \"bbb\", \"ccc\"] })).toMatchInlineSnapshot(\n        '\"z.enum([\"aaa\", \"bbb\", \"ccc\"])\"'\n    );\n    expect(getSchemaAsZodString({ type: \"number\", enum: [1, 2, 3, null] })).toMatchInlineSnapshot(\n        '\"z.union([z.literal(1), z.literal(2), z.literal(3), z.literal(null)])\"'\n    );\n    expect(getSchemaAsZodString({ type: \"number\", enum: [1] })).toMatchInlineSnapshot('\"z.literal(1)\"');\n    expect(getSchemaAsZodString({ type: \"string\", enum: [\"aString\"] })).toMatchInlineSnapshot('\"z.literal(\"aString\")\"');\n});\n\ntest(\"getSchemaWithChainableAsZodString\", () => {\n    expect(getSchemaAsZodString({ type: \"string\", nullable: true })).toMatchInlineSnapshot('\"z.string()\"');\n    expect(getSchemaAsZodString({ type: \"string\", nullable: false })).toMatchInlineSnapshot('\"z.string()\"');\n\n    expect(getSchemaAsZodString({ type: \"string\", nullable: false }, { isRequired: true })).toMatchInlineSnapshot(\n        '\"z.string()\"'\n    );\n    expect(getSchemaAsZodString({ type: \"string\", nullable: true }, { isRequired: true })).toMatchInlineSnapshot(\n        '\"z.string()\"'\n    );\n});\n\ntest(\"CodeMeta with missing ref\", () => {\n    const ctx: ConversionTypeContext = {\n        resolver: makeSchemaResolver({ components: { schemas: {} } } as any),\n        zodSchemaByName: {},\n        schemaByName: {},\n    };\n\n    expect(() =>\n        getZodSchema({\n            schema: makeSchema({\n                type: \"object\",\n                properties: {\n                    str: { type: \"string\" },\n                    reference: {\n                        $ref: \"Example\",\n                    },\n                    inline: {\n                        type: \"object\",\n                        properties: {\n                            nested_prop: { type: \"boolean\" },\n                        },\n                    },\n                },\n            }),\n            ctx,\n        })\n    ).toThrowErrorMatchingInlineSnapshot(`[Error: Schema not found for $ref: Example]`);\n});\n\ntest(\"CodeMeta with ref\", () => {\n    const schemas = {\n        Example: {\n            type: \"object\",\n            properties: {\n                exampleProp: { type: \"string\" },\n                another: { type: \"number\" },\n            },\n        },\n    } as Record<string, SchemaObject>;\n    const ctx: ConversionTypeContext = {\n        resolver: makeSchemaResolver({ components: { schemas } } as any),\n        zodSchemaByName: {},\n        schemaByName: {},\n    };\n    Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n\n    const code = getZodSchema({\n        schema: makeSchema({\n            type: \"object\",\n            properties: {\n                str: { type: \"string\" },\n                reference: {\n                    $ref: \"#/components/schemas/Example\",\n                },\n                inline: {\n                    type: \"object\",\n                    properties: {\n                        nested_prop: { type: \"boolean\" },\n                    },\n                },\n            },\n        }),\n        ctx,\n    });\n    expect(code.toString()).toMatchInlineSnapshot(\n        '\"z.object({ str: z.string(), reference: Example, inline: z.object({ nested_prop: z.boolean() }).partial().passthrough() }).partial().passthrough()\"'\n    );\n    expect(code.children).toMatchInlineSnapshot(`\n      [\n          \"z.string()\",\n          \"Example\",\n          \"z.object({ nested_prop: z.boolean() }).partial().passthrough()\",\n      ]\n    `);\n});\n\ntest(\"CodeMeta with nested refs\", () => {\n    const schemas = {\n        Basic: { type: \"object\", properties: { prop: { type: \"string\" }, second: { type: \"number\" } } },\n        WithNested: {\n            type: \"object\",\n            properties: { nested: { type: \"string\" }, nestedRef: { $ref: \"#/components/schemas/DeepNested\" } },\n        },\n        ObjectWithArrayOfRef: {\n            type: \"object\",\n            properties: {\n                exampleProp: { type: \"string\" },\n                another: { type: \"number\" },\n                link: { type: \"array\", items: { $ref: \"#/components/schemas/WithNested\" } },\n                someReference: { $ref: \"#/components/schemas/Basic\" },\n            },\n        },\n        DeepNested: { type: \"object\", properties: { deep: { type: \"boolean\" } } },\n    } as Record<string, SchemaObject>;\n    const ctx: ConversionTypeContext = {\n        resolver: makeSchemaResolver({ components: { schemas } } as any),\n        zodSchemaByName: {},\n        schemaByName: {},\n    };\n    Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n\n    const code = getZodSchema({\n        schema: makeSchema({\n            type: \"object\",\n            properties: {\n                str: { type: \"string\" },\n                reference: {\n                    $ref: \"#/components/schemas/ObjectWithArrayOfRef\",\n                },\n                inline: {\n                    type: \"object\",\n                    properties: {\n                        nested_prop: { type: \"boolean\" },\n                    },\n                },\n                another: { $ref: \"#components/schemas/WithNested\" },\n                basic: { $ref: \"#/components/schemas/Basic\" },\n                differentPropSameRef: { $ref: \"#/components/schemas/Basic\" },\n            },\n        }),\n        ctx,\n    });\n    expect(code.toString()).toMatchInlineSnapshot(\n        '\"z.object({ str: z.string(), reference: ObjectWithArrayOfRef, inline: z.object({ nested_prop: z.boolean() }).partial().passthrough(), another: WithNested, basic: Basic, differentPropSameRef: Basic }).partial().passthrough()\"'\n    );\n    expect(code.children).toMatchInlineSnapshot(`\n      [\n          \"z.string()\",\n          \"ObjectWithArrayOfRef\",\n          \"z.object({ nested_prop: z.boolean() }).partial().passthrough()\",\n          \"WithNested\",\n          \"Basic\",\n          \"Basic\",\n      ]\n    `);\n    expect(ctx).toMatchInlineSnapshot(`\n      {\n          \"resolver\": {\n              \"getSchemaByRef\": [Function],\n              \"resolveRef\": [Function],\n              \"resolveSchemaName\": [Function],\n          },\n          \"schemaByName\": {},\n          \"zodSchemaByName\": {\n              \"Basic\": \"z.object({ prop: z.string(), second: z.number() }).partial().passthrough()\",\n              \"DeepNested\": \"z.object({ deep: z.boolean() }).partial().passthrough()\",\n              \"ObjectWithArrayOfRef\": \"z.object({ exampleProp: z.string(), another: z.number(), link: z.array(WithNested), someReference: Basic }).partial().passthrough()\",\n              \"WithNested\": \"z.object({ nested: z.string(), nestedRef: DeepNested }).partial().passthrough()\",\n          },\n      }\n    `);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/openApiToZod.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Function 'getZodSchema' has too many lines (285). Maximum allowed is 100.","line":29,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":313,"endColumn":2},{"ruleId":"max-statements","severity":2,"message":"Function 'getZodSchema' has too many statements (95). Maximum allowed is 30.","line":29,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":313,"endColumn":2},{"ruleId":"complexity","severity":2,"message":"Function 'getZodSchema' has a complexity of 62. Maximum allowed is 29.","line":29,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":29,"endColumn":29},{"ruleId":"sonarjs/cognitive-complexity","severity":2,"message":"Refactor this function to reduce its Cognitive Complexity from 83 to the 29 allowed.","line":29,"column":17,"nodeType":null,"messageId":"refactorFunction","endLine":29,"endColumn":29},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":187,"column":39,"nodeType":"TSAsExpression","messageId":"never","endLine":187,"endColumn":99},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":222,"column":29,"nodeType":"TSAsExpression","messageId":"never","endLine":222,"endColumn":57},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":243,"column":25,"nodeType":"TSAsExpression","messageId":"never","endLine":243,"endColumn":68},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":286,"column":29,"nodeType":"TSAsExpression","messageId":"never","endLine":286,"endColumn":61},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (481). Maximum allowed is 350.","line":351,"column":1,"nodeType":null,"messageId":"exceed","endLine":482,"endColumn":1},{"ruleId":"sonarjs/function-return-type","severity":2,"message":"Refactor this function to always return the same type.","line":374,"column":60,"nodeType":null,"endLine":374,"endColumn":62}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":67,"column":32,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":67,"endColumn":63,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":67,"column":52,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":67,"endColumn":61,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"never\" of template literal expression.","line":312,"column":49,"nodeType":"Identifier","messageId":"invalidType","endLine":312,"endColumn":59,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/function-return-type","severity":2,"message":"Refactor this function to always return the same type.","line":362,"column":72,"nodeType":null,"endLine":362,"endColumn":74,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":6,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isSchemaObject, isReferenceObject, type ReferenceObject, type SchemaObject } from \"openapi3-ts\";\n\nimport { match } from \"ts-pattern\";\n\nimport type { CodeMetaData, ConversionTypeContext } from \"./CodeMeta.js\";\nimport { CodeMeta } from \"./CodeMeta.js\";\nimport { generateNonStringEnumZodCode, generateStringEnumZodCode, shouldEnumBeNever } from \"./enumHelpers.js\";\nimport type { TemplateContext } from \"./template-context.js\";\nimport { escapeControlCharacters, isPrimitiveSchemaType, wrapWithQuotesIfNeeded } from \"./utils.js\";\nimport { inferRequiredSchema } from \"./inferRequiredOnly.js\";\n\ntype ConversionArgs = {\n    schema: SchemaObject | ReferenceObject;\n    ctx?: ConversionTypeContext | undefined;\n    meta?: CodeMetaData | undefined;\n    options?: TemplateContext[\"options\"] | undefined;\n};\n\n/**\n * @see https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#schemaObject\n * @see https://github.com/colinhacks/zod\n */\n/**\n * Convert an OpenAPI Schema to a Zod schema\n *\n * Per OAS 3.0+ spec: A Schema is always an object (possibly empty), never null.\n * The 'nullable' property indicates the VALUE can be null, not the schema itself.\n */\nexport function getZodSchema({ schema: $schema, ctx, meta: inheritedMeta, options }: ConversionArgs): CodeMeta {\n    // Per OpenAPI spec: Schema is always an object, never null\n    // Empty schema {} is valid and represents \"any value\" (z.unknown())\n    if (!$schema) {\n        throw new Error(\n            $schema === null\n                ? \"Invalid OpenAPI specification: Schema cannot be null. Use 'nullable: true' to indicate null values.\"\n                : \"Schema is required\"\n        );\n    }\n\n    const schema = options?.schemaRefiner?.($schema, inheritedMeta) ?? $schema;\n    const code = new CodeMeta(schema, ctx, inheritedMeta);\n    const meta = {\n        parent: code.inherit(inheritedMeta?.parent),\n        referencedBy: [...code.meta.referencedBy],\n    };\n\n    const refsPath = code.meta.referencedBy\n        .slice(0, -1)\n        .map((prev) => {\n            if (!prev.ref) return \"\";\n            if (!ctx) return prev.ref;\n            const resolved = ctx.resolver.resolveRef(prev.ref);\n            return resolved?.normalized ?? prev.ref;\n        })\n        .filter(Boolean);\n\n    if (isReferenceObject(schema)) {\n        if (!ctx) throw new Error(\"Context is required\");\n\n        const schemaName = ctx.resolver.resolveRef(schema.$ref)?.normalized;\n\n        // circular(=recursive) reference\n        if (refsPath.length > 1 && refsPath.includes(schemaName)) {\n            // In circular references, code.ref and the schema must exist\n            // The non-null assertions are safe here because we're inside a reference object check\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return code.assign(ctx.zodSchemaByName[code.ref!]!);\n        }\n\n        let result = ctx.zodSchemaByName[schema.$ref];\n        if (!result) {\n            const actualSchema = ctx.resolver.getSchemaByRef(schema.$ref);\n            if (!actualSchema) {\n                throw new Error(`Schema ${schema.$ref} not found`);\n            }\n\n            result = getZodSchema({ schema: actualSchema, ctx, meta, options }).toString();\n        }\n\n        if (ctx.zodSchemaByName[schemaName]) {\n            return code;\n        }\n\n        ctx.zodSchemaByName[schemaName] = result;\n\n        return code;\n    }\n\n    if (Array.isArray(schema.type)) {\n        if (schema.type.length === 1) {\n            const firstType = schema.type[0];\n            if (!firstType) throw new Error(\"Schema type array has invalid first element\");\n            return getZodSchema({ schema: { ...schema, type: firstType }, ctx, meta, options });\n        }\n\n        return code.assign(\n            `z.union([${schema.type\n                .map((prop) => getZodSchema({ schema: { ...schema, type: prop }, ctx, meta, options }))\n                .join(\", \")}])`\n        );\n    }\n\n    if (schema.type === \"null\") {\n        return code.assign(\"z.null()\");\n    }\n\n    if (schema.oneOf) {\n        if (schema.oneOf.length === 1) {\n            const firstSchema = schema.oneOf[0];\n            if (!firstSchema) throw new Error(\"oneOf array has invalid first element\");\n            const type = getZodSchema({ schema: firstSchema, ctx, meta, options });\n            return code.assign(type.toString());\n        }\n\n        /* when there are multiple allOf we are unable to use a discriminatedUnion as this library adds an\n         *   'z.and' to the schema that it creates which breaks type inference */\n        const hasMultipleAllOf = schema.oneOf?.some((obj) => isSchemaObject(obj) && (obj?.allOf || []).length > 1);\n        if (schema.discriminator && !hasMultipleAllOf) {\n            const propertyName = schema.discriminator.propertyName;\n\n            return code.assign(`\n                z.discriminatedUnion(\"${propertyName}\", [${schema.oneOf\n                    .map((prop) => getZodSchema({ schema: prop, ctx, meta, options }))\n                    .join(\", \")}])\n            `);\n        }\n\n        return code.assign(\n            `z.union([${schema.oneOf.map((prop) => getZodSchema({ schema: prop, ctx, meta, options })).join(\", \")}])`\n        );\n    }\n\n    // anyOf = oneOf but with 1 or more = `T extends oneOf ? T | T[] : never`\n    if (schema.anyOf) {\n        if (schema.anyOf.length === 1) {\n            const firstSchema = schema.anyOf[0];\n            if (!firstSchema) throw new Error(\"anyOf array has invalid first element\");\n            const type = getZodSchema({ schema: firstSchema, ctx, meta, options });\n            return code.assign(type.toString());\n        }\n\n        const types = schema.anyOf\n            .map((prop) => getZodSchema({ schema: prop, ctx, meta, options }))\n            .map((type) => type.toString())\n            .join(\", \");\n\n        return code.assign(`z.union([${types}])`);\n    }\n\n    if (schema.allOf) {\n        if (schema.allOf.length === 1) {\n            const firstSchema = schema.allOf[0];\n            if (!firstSchema) throw new Error(\"allOf array has invalid first element\");\n            const type = getZodSchema({ schema: firstSchema, ctx, meta, options });\n            return code.assign(type.toString());\n        }\n        const { patchRequiredSchemaInLoop, noRequiredOnlyAllof, composedRequiredSchema } = inferRequiredSchema(schema);\n\n        const types = noRequiredOnlyAllof.map((prop) => {\n            const zodSchema = getZodSchema({ schema: prop, ctx, meta, options });\n            if (ctx?.resolver) {\n                patchRequiredSchemaInLoop(prop, ctx.resolver);\n            }\n            return zodSchema;\n        });\n\n        if (composedRequiredSchema.required.length > 0) {\n            types.push(\n                getZodSchema({\n                    schema: composedRequiredSchema,\n                    ctx,\n                    meta,\n                    options,\n                })\n            );\n        }\n        const first = types.at(0);\n        if (!first) throw new Error(\"allOf schemas list is empty\");\n        const rest = types\n            .slice(1)\n            .map((type) => `and(${type.toString()})`)\n            .join(\".\");\n\n        return code.assign(`${first.toString()}.${rest}`);\n    }\n\n    const schemaType = schema.type ? (schema.type.toLowerCase() as NonNullable<typeof schema.type>) : undefined;\n    if (schemaType && isPrimitiveSchemaType(schemaType)) {\n        if (schema.enum) {\n            // Handle string enums\n            if (schemaType === \"string\") {\n                return code.assign(generateStringEnumZodCode(schema.enum));\n            }\n\n            // Non-string enums with string values are invalid\n            if (shouldEnumBeNever(schemaType, schema.enum)) {\n                return code.assign(\"z.never()\");\n            }\n\n            // Handle number/integer enums\n            return code.assign(generateNonStringEnumZodCode(schema.enum));\n        }\n\n        return code.assign(\n            match(schemaType)\n                .with(\"integer\", () => \"z.number()\")\n                .with(\"string\", () =>\n                    match(schema.format)\n                        .with(\"binary\", () => \"z.instanceof(File)\")\n                        .otherwise(() => \"z.string()\")\n                )\n                .otherwise((type) => `z.${type}()`)\n        );\n    }\n\n    const readonly = options?.allReadonly ? \".readonly()\" : \"\";\n\n    if (schemaType === \"array\") {\n        if (schema.items) {\n            return code.assign(\n                `z.array(${getZodSchema({ schema: schema.items, ctx, meta, options }).toString()}${getZodChain({\n                    schema: schema.items as SchemaObject,\n                    meta: { ...meta, isRequired: true },\n                    options,\n                })})${readonly}`\n            );\n        }\n\n        return code.assign(`z.array(z.any())${readonly}`);\n    }\n\n    if (schemaType === \"object\" || schema.properties || schema.additionalProperties) {\n        // additional properties default to true if additionalPropertiesDefaultValue not provided\n        const additionalPropsDefaultValue =\n            options?.additionalPropertiesDefaultValue === undefined ? true : options?.additionalPropertiesDefaultValue;\n        const additionalProps =\n            schema.additionalProperties == null ? additionalPropsDefaultValue : schema.additionalProperties;\n        const additionalPropsSchema = additionalProps === false ? \"\" : \".passthrough()\";\n\n        if (typeof schema.additionalProperties === \"object\" && Object.keys(schema.additionalProperties).length > 0) {\n            const additionalPropsZod = getZodSchema({ schema: schema.additionalProperties, ctx, meta, options });\n            const additionalPropsChain = getZodChain({\n                schema: schema.additionalProperties as SchemaObject,\n                meta: { ...meta, isRequired: true },\n                options,\n            });\n            return code.assign(`z.record(${additionalPropsZod.toString()}${additionalPropsChain})`);\n        }\n\n        const hasRequiredArray = schema.required && schema.required.length > 0;\n        const isPartial = options?.withImplicitRequiredProps ? false : !schema.required?.length;\n        let properties = \"{}\";\n\n        if (schema.properties) {\n            const propsMap = Object.entries(schema.properties).map(([prop, propSchema]) => {\n                // Determine if this property is required\n                let propIsRequired: boolean | undefined;\n                if (isPartial) {\n                    propIsRequired = true;\n                } else if (hasRequiredArray) {\n                    propIsRequired = schema.required?.includes(prop);\n                } else {\n                    propIsRequired = options?.withImplicitRequiredProps;\n                }\n\n                // Build metadata, only including isRequired if defined (exactOptionalPropertyTypes)\n                const propMetadata: CodeMetaData = {\n                    ...meta,\n                    name: prop,\n                };\n                if (propIsRequired !== undefined) {\n                    propMetadata.isRequired = propIsRequired;\n                }\n\n                let propActualSchema = propSchema;\n\n                if (isReferenceObject(propSchema) && ctx?.resolver) {\n                    propActualSchema = ctx.resolver.getSchemaByRef(propSchema.$ref);\n                    if (!propActualSchema) {\n                        throw new Error(`Schema ${propSchema.$ref} not found`);\n                    }\n                }\n\n                const propZodSchema = getZodSchema({ schema: propSchema, ctx, meta: propMetadata, options });\n                const propChain = getZodChain({\n                    schema: propActualSchema as SchemaObject,\n                    meta: propMetadata,\n                    options,\n                });\n                const propCode = `${propZodSchema.toString()}${propChain}`;\n\n                return [prop, propCode];\n            });\n\n            properties =\n                \"{ \" +\n                propsMap\n                    .filter((entry): entry is [string, string] => entry[0] !== undefined)\n                    .map(([prop, propSchema]) => `${wrapWithQuotesIfNeeded(prop)}: ${propSchema}`)\n                    .join(\", \") +\n                \" }\";\n        }\n\n        const partial = isPartial ? \".partial()\" : \"\";\n        const strict = options?.strictObjects ? \".strict()\" : \"\";\n        return code.assign(`z.object(${properties})${partial}${strict}${additionalPropsSchema}${readonly}`);\n    }\n\n    if (!schemaType) return code.assign(\"z.unknown()\");\n\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new Error(`Unsupported schema type: ${schemaType}`);\n}\n\ntype ZodChainArgs = { schema: SchemaObject; meta?: CodeMetaData; options?: TemplateContext[\"options\"] };\n\nexport const getZodChain = ({ schema, meta, options }: ZodChainArgs) => {\n    const chains: string[] = [];\n\n    match(schema.type)\n        .with(\"string\", () => chains.push(getZodChainableStringValidations(schema)))\n        .with(\"number\", \"integer\", () => chains.push(getZodChainableNumberValidations(schema)))\n        .with(\"array\", () => chains.push(getZodChainableArrayValidations(schema)))\n        .otherwise(() => void 0);\n\n    if (typeof schema.description === \"string\" && schema.description !== \"\" && options?.withDescription) {\n        if ([\"\\n\", \"\\r\", \"\\r\\n\"].some((c) => String.prototype.includes.call(schema.description, c))) {\n            chains.push(`describe(\\`${schema.description}\\`)`);\n        } else {\n            chains.push(`describe(\"${schema.description}\")`);\n        }\n    }\n\n    const output = chains\n        .concat(\n            getZodChainablePresence(schema, meta),\n            options?.withDefaultValues === false ? [] : getZodChainableDefault(schema)\n        )\n        .filter(Boolean)\n        .join(\".\");\n    return output ? `.${output}` : \"\";\n};\n\nconst getZodChainablePresence = (schema: SchemaObject, meta?: CodeMetaData) => {\n    if (schema.nullable && !meta?.isRequired) {\n        return \"nullish()\";\n    }\n\n    if (schema.nullable) {\n        return \"nullable()\";\n    }\n\n    if (!meta?.isRequired) {\n        return \"optional()\";\n    }\n\n    return \"\";\n};\n\n// NOTE: OpenAPI prefixItems support (z.tuple) is not yet implemented\n// eslint-disable-next-line sonarjs/function-return-type\nconst unwrapQuotesIfNeeded = (value: string | number): string | number => {\n    if (typeof value === \"string\" && value.startsWith('\"') && value.endsWith('\"')) {\n        return value.slice(1, -1);\n    }\n\n    return value;\n};\n\nconst getZodChainableDefault = (schema: SchemaObject): string => {\n    if (schema.default !== undefined) {\n        const defaultValue: unknown = schema.default;\n        const value: string | number = match(schema.type)\n            .with(\"number\", \"integer\", (): string | number => {\n                if (typeof defaultValue === \"number\") return defaultValue;\n                if (typeof defaultValue === \"string\") return unwrapQuotesIfNeeded(defaultValue);\n                return JSON.stringify(defaultValue);\n            })\n            .otherwise(() => JSON.stringify(defaultValue));\n        return `default(${String(value)})`;\n    }\n\n    return \"\";\n};\n\nconst formatPatternIfNeeded = (pattern: string) => {\n    if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n        pattern = pattern.slice(1, -1);\n    }\n\n    pattern = escapeControlCharacters(pattern);\n\n    return pattern.includes(String.raw`\\u`) || pattern.includes(String.raw`\\p`) ? `/${pattern}/u` : `/${pattern}/`;\n};\n\nconst getZodChainableStringValidations = (schema: SchemaObject) => {\n    const validations: string[] = [];\n\n    if (!schema.enum) {\n        if (schema.minLength !== undefined) {\n            validations.push(`min(${schema.minLength})`);\n        }\n\n        if (schema.maxLength !== undefined) {\n            validations.push(`max(${schema.maxLength})`);\n        }\n    }\n\n    if (schema.pattern) {\n        validations.push(`regex(${formatPatternIfNeeded(schema.pattern)})`);\n    }\n\n    if (schema.format) {\n        const chain = match(schema.format)\n            .with(\"email\", () => \"email()\")\n            .with(\"hostname\", () => \"url()\")\n            .with(\"uri\", () => \"url()\")\n            .with(\"uuid\", () => \"uuid()\")\n            .with(\"date-time\", () => \"datetime({ offset: true })\")\n            .otherwise(() => \"\");\n\n        if (chain) {\n            validations.push(chain);\n        }\n    }\n\n    return validations.join(\".\");\n};\n\nconst getZodChainableNumberValidations = (schema: SchemaObject) => {\n    const validations: string[] = [];\n\n    // none of the chains are valid for enums\n    if (schema.enum) {\n        return \"\";\n    }\n\n    if (schema.type === \"integer\") {\n        validations.push(\"int()\");\n    }\n\n    if (schema.minimum !== undefined) {\n        if (schema.exclusiveMinimum === true) {\n            validations.push(`gt(${schema.minimum})`);\n        } else {\n            validations.push(`gte(${schema.minimum})`);\n        }\n    } else if (typeof schema.exclusiveMinimum === \"number\") {\n        validations.push(`gt(${schema.exclusiveMinimum})`);\n    }\n\n    if (schema.maximum !== undefined) {\n        if (schema.exclusiveMaximum === true) {\n            validations.push(`lt(${schema.maximum})`);\n        } else {\n            validations.push(`lte(${schema.maximum})`);\n        }\n    } else if (typeof schema.exclusiveMaximum === \"number\") {\n        validations.push(`lt(${schema.exclusiveMaximum})`);\n    }\n\n    if (schema.multipleOf) {\n        validations.push(`multipleOf(${schema.multipleOf})`);\n    }\n\n    return validations.join(\".\");\n};\n\nconst getZodChainableArrayValidations = (schema: SchemaObject) => {\n    const validations: string[] = [];\n\n    if (schema.minItems) {\n        validations.push(`min(${schema.minItems})`);\n    }\n\n    if (schema.maxItems) {\n        validations.push(`max(${schema.maxItems})`);\n    }\n\n    return validations.join(\".\");\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/schema-complexity.enum.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/schema-complexity.helpers.ts","messages":[{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":52,"column":25,"nodeType":"TSAsExpression","messageId":"never","endLine":52,"endColumn":95},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":52,"column":44,"nodeType":"TSAsExpression","messageId":"never","endLine":52,"endColumn":77},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":64,"column":29,"nodeType":"TSAsExpression","messageId":"never","endLine":64,"endColumn":94},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":64,"column":48,"nodeType":"TSAsExpression","messageId":"never","endLine":64,"endColumn":76}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Helper functions for schema complexity calculation\n * Extracted to reduce cognitive complexity in schema-complexity.ts\n */\n\nimport type { ReferenceObject, SchemaObject } from \"openapi3-ts\";\nimport { getSum } from \"pastable\";\n\ntype ComplexityFn = (args: { current: number; schema: SchemaObject | ReferenceObject | undefined }) => number;\ntype CompositeType = \"oneOf\" | \"anyOf\" | \"allOf\" | \"enum\" | \"array\" | \"empty-object\" | \"object\" | \"record\";\n\n/**\n * Calculates complexity for a composition schema (oneOf, anyOf, allOf)\n * Handles both single-item and multi-item compositions\n */\nexport function calculateCompositionComplexity(\n    schemas: ReadonlyArray<SchemaObject | ReferenceObject>,\n    compositeType: CompositeType,\n    current: number,\n    complexityByComposite: (type: CompositeType) => number,\n    getSchemaComplexity: ComplexityFn\n): number {\n    if (schemas.length === 1) {\n        return complexityByComposite(compositeType) + getSchemaComplexity({ current, schema: schemas[0] });\n    }\n\n    return (\n        current +\n        complexityByComposite(compositeType) +\n        getSum(schemas.map((prop) => getSchemaComplexity({ current: 0, schema: prop })))\n    );\n}\n\n/**\n * Calculates complexity for a type array (OpenAPI 3.1 feature)\n * Handles both single-type and multi-type arrays\n */\nexport function calculateTypeArrayComplexity(\n    types: string[],\n    schema: SchemaObject,\n    current: number,\n    complexityByComposite: (type: CompositeType) => number,\n    getSchemaComplexity: ComplexityFn\n): number {\n    if (types.length === 1) {\n        const firstType = types[0];\n        if (!firstType) return current;\n        return (\n            complexityByComposite(\"oneOf\") +\n            getSchemaComplexity({\n                current,\n                schema: { ...schema, type: firstType as SchemaObject[\"type\"] } as SchemaObject,\n            })\n        );\n    }\n\n    return (\n        current +\n        complexityByComposite(\"oneOf\") +\n        getSum(\n            types.map((prop) =>\n                getSchemaComplexity({\n                    current: 0,\n                    schema: { ...schema, type: prop as SchemaObject[\"type\"] } as SchemaObject,\n                })\n            )\n        )\n    );\n}\n\n/**\n * Calculates complexity for object properties\n * Sums complexity of all properties\n */\nexport function calculatePropertiesComplexity(\n    properties: Record<string, SchemaObject | ReferenceObject>,\n    current: number,\n    complexityByComposite: (type: CompositeType) => number,\n    getSchemaComplexity: ComplexityFn\n): number {\n    const props = Object.values(properties);\n    return (\n        current +\n        complexityByComposite(\"object\") +\n        getSum(props.map((prop) => getSchemaComplexity({ current: 0, schema: prop })))\n    );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/schema-complexity.test.ts","messages":[{"ruleId":"max-statements","severity":2,"message":"Async arrow function has too many statements (34). Maximum allowed is 30.","line":8,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":261,"endColumn":2},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":8,"column":38,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":8,"endColumn":40,"suggestions":[{"messageId":"removeAsync","fix":{"range":[282,288],"text":""},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { expect, test } from \"vitest\";\n\nimport type { SchemaObject } from \"openapi3-ts\";\nimport { getSchemaComplexity } from \"./schema-complexity.js\";\n\nconst getComplexity = (schema: SchemaObject) => getSchemaComplexity({ schema: schema, current: 0 });\n\ntest(\"getSchemaComplexity\", async () => {\n    expect(getComplexity({ type: \"null\" })).toMatchInlineSnapshot(\"1\");\n    expect(getComplexity({ type: \"boolean\" })).toMatchInlineSnapshot(\"1\");\n    expect(getComplexity({ type: \"string\" })).toMatchInlineSnapshot(\"1\");\n    expect(getComplexity({ type: \"number\" })).toMatchInlineSnapshot(\"1\");\n    expect(getComplexity({ type: \"integer\" })).toMatchInlineSnapshot(\"1\");\n\n    expect(getComplexity({ type: \"array\", items: { type: \"string\" } })).toMatchInlineSnapshot(\"2\");\n    expect(getComplexity({ type: \"array\" })).toMatchInlineSnapshot(\"1\");\n\n    expect(getComplexity({ type: \"object\" })).toMatchInlineSnapshot(\"1\");\n\n    expect(getComplexity({ type: \"object\", additionalProperties: true })).toMatchInlineSnapshot(\"1\");\n    expect(getComplexity({ type: \"object\", additionalProperties: { type: \"string\" } })).toMatchInlineSnapshot(\"2\");\n\n    expect(\n        getComplexity({\n            type: \"object\",\n            additionalProperties: { type: \"object\", properties: { str: { type: \"string\" } } },\n        })\n    ).toMatchInlineSnapshot(\"4\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            additionalProperties: { type: \"object\", properties: { str: { type: \"string\" }, nb: { type: \"number\" } } },\n        })\n    ).toMatchInlineSnapshot(\"5\");\n\n    expect(getComplexity({ type: \"object\", properties: { str: { type: \"string\" } } })).toMatchInlineSnapshot(\"3\");\n    expect(\n        getComplexity({ type: \"object\", properties: { reference: { $ref: \"#/components/schemas/Basic\" } } })\n    ).toMatchInlineSnapshot(\"4\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: { refArray: { type: \"array\", items: { $ref: \"#/components/schemas/Basic\" } } },\n        })\n    ).toMatchInlineSnapshot(\"5\");\n    expect(\n        getComplexity({ type: \"object\", properties: { str: { type: \"string\" }, nb: { type: \"number\" } } })\n    ).toMatchInlineSnapshot(\"4\");\n\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                str: { type: \"string\" },\n                nb: { type: \"number\" },\n                nested: {\n                    type: \"object\",\n                    properties: {\n                        nested_prop: { type: \"boolean\" },\n                    },\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\"7\");\n\n    expect(\n        getComplexity({\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    str: { type: \"string\" },\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\"4\");\n\n    expect(\n        getComplexity({\n            type: \"array\",\n            items: {\n                type: \"array\",\n                items: {\n                    type: \"string\",\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\"3\");\n\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                union: { oneOf: [{ type: \"string\" }] },\n            },\n        })\n    ).toMatchInlineSnapshot(\"5\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                union: { oneOf: [{ type: \"string\" }, { type: \"number\" }] },\n            },\n        })\n    ).toMatchInlineSnapshot(\"6\");\n\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                unionOrArrayOfUnion: { anyOf: [{ type: \"string\" }] },\n            },\n        })\n    ).toMatchInlineSnapshot(\"6\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                unionOrArrayOfUnion: { anyOf: [{ type: \"string\" }, { type: \"number\" }] },\n            },\n        })\n    ).toMatchInlineSnapshot(\"7\");\n\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                intersection: { allOf: [{ type: \"string\" }] },\n            },\n        })\n    ).toMatchInlineSnapshot(\"5\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                intersection: { allOf: [{ type: \"string\" }, { type: \"number\" }] },\n            },\n        })\n    ).toMatchInlineSnapshot(\"6\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                intersection: {\n                    allOf: [{ type: \"string\" }, { type: \"number\" }, { type: \"boolean\" }],\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\"7\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                intersection: {\n                    allOf: [{ type: \"string\" }, { type: \"number\" }, { type: \"boolean\" }, { type: \"null\" }],\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\"8\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                intersection: {\n                    allOf: [\n                        { type: \"string\" },\n                        { type: \"number\" },\n                        { type: \"boolean\" },\n                        { type: \"null\" },\n                        { type: \"array\" },\n                    ],\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\"9\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                intersection: {\n                    allOf: [\n                        { type: \"string\" },\n                        { type: \"number\" },\n                        { type: \"boolean\" },\n                        { type: \"null\" },\n                        { type: \"array\" },\n                        { type: \"object\" },\n                    ],\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\"10\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                intersection: {\n                    allOf: [\n                        { type: \"string\" },\n                        { type: \"number\" },\n                        { type: \"boolean\" },\n                        { type: \"null\" },\n                        { type: \"array\" },\n                        { type: \"object\" },\n                        { type: \"object\" },\n                    ],\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\"11\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                intersection: {\n                    allOf: [\n                        { type: \"string\" },\n                        { type: \"number\" },\n                        { type: \"boolean\" },\n                        { type: \"null\" },\n                        { type: \"array\" },\n                        { type: \"object\" },\n                        {\n                            type: \"object\",\n                            properties: {\n                                str: { type: \"string\" },\n                            },\n                        },\n                    ],\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\"13\");\n    expect(\n        getComplexity({\n            type: \"object\",\n            properties: {\n                intersection: {\n                    allOf: [\n                        { type: \"string\" },\n                        { type: \"number\" },\n                        { type: \"boolean\" },\n                        { type: \"null\" },\n                        { type: \"array\" },\n                        { type: \"object\" },\n                        {\n                            type: \"object\",\n                            properties: {\n                                str: { type: \"string\" },\n                                nb: { type: \"number\" },\n                            },\n                        },\n                    ],\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\"14\");\n\n    expect(getComplexity({ type: \"string\", enum: [\"aaa\", \"bbb\", \"ccc\"] })).toMatchInlineSnapshot(\"2\");\n    expect(getComplexity({ type: \"number\", enum: [1, 2, 3, null] })).toMatchInlineSnapshot(\"2\");\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/schema-complexity.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Function 'getSchemaComplexity' has too many lines (105). Maximum allowed is 100.","line":43,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":147,"endColumn":2},{"ruleId":"max-statements","severity":2,"message":"Function 'getSchemaComplexity' has too many statements (32). Maximum allowed is 30.","line":43,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":147,"endColumn":2},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":104,"column":34,"nodeType":"TSAsExpression","messageId":"never","endLine":104,"endColumn":88},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":112,"column":43,"nodeType":"TSAsExpression","messageId":"never","endLine":112,"endColumn":97}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ReferenceObject, SchemaObject } from \"openapi3-ts\";\nimport { isReferenceObject } from \"openapi3-ts\";\n\nimport { match } from \"ts-pattern\";\n\nimport type { PrimitiveSchemaType } from \"./utils.js\";\nimport { isPrimitiveSchemaType } from \"./utils.js\";\nimport {\n    calculateCompositionComplexity,\n    calculatePropertiesComplexity,\n    calculateTypeArrayComplexity,\n} from \"./schema-complexity.helpers.js\";\n\ntype CompositeType = \"oneOf\" | \"anyOf\" | \"allOf\" | \"enum\" | \"array\" | \"empty-object\" | \"object\" | \"record\";\nconst complexityByType = (schema: SchemaObject & { type: PrimitiveSchemaType }) => {\n    const type = schema.type;\n    if (!type) return 0;\n\n    return match(type)\n        .with(\"string\", () => 1)\n        .with(\"number\", () => 1)\n        .with(\"integer\", () => 1)\n        .with(\"boolean\", () => 1)\n        .with(\"null\", () => 1)\n        .otherwise(() => 0);\n};\n\nconst complexityByComposite = (from?: CompositeType) => {\n    if (!from) return 0;\n\n    return match(from)\n        .with(\"oneOf\", () => 2)\n        .with(\"anyOf\", () => 3)\n        .with(\"allOf\", () => 2)\n        .with(\"enum\", () => 1)\n        .with(\"array\", () => 1)\n        .with(\"record\", () => 1)\n        .with(\"empty-object\", () => 1)\n        .with(\"object\", () => 2)\n        .otherwise(() => 0);\n};\n\nexport function getSchemaComplexity({\n    current,\n    schema,\n}: {\n    current: number;\n    schema: SchemaObject | ReferenceObject | undefined;\n}): number {\n    if (!schema) return current;\n    if (isReferenceObject(schema)) return current + 2;\n\n    if (Array.isArray(schema.type)) {\n        return calculateTypeArrayComplexity(schema.type, schema, current, complexityByComposite, getSchemaComplexity);\n    }\n\n    if (schema.type === \"null\") {\n        return current + complexityByType({ ...schema, type: \"null\" });\n    }\n\n    if (schema.oneOf) {\n        return calculateCompositionComplexity(\n            schema.oneOf,\n            \"oneOf\",\n            current,\n            complexityByComposite,\n            getSchemaComplexity\n        );\n    }\n\n    // anyOf = oneOf but with 1 or more = `T extends oneOf ? T | T[] : never`\n    if (schema.anyOf) {\n        return calculateCompositionComplexity(\n            schema.anyOf,\n            \"anyOf\",\n            current,\n            complexityByComposite,\n            getSchemaComplexity\n        );\n    }\n\n    if (schema.allOf) {\n        return calculateCompositionComplexity(\n            schema.allOf,\n            \"allOf\",\n            current,\n            complexityByComposite,\n            getSchemaComplexity\n        );\n    }\n\n    // Handle enum without explicit type BEFORE early return (e.g., { enum: [\"a\", \"b\"] })\n    if (schema.enum && !schema.type) {\n        return current + complexityByComposite(\"enum\") + 1;\n        // 1 for base enum declaration + 1 for enum composite = 2 total\n    }\n\n    if (!schema.type) return current;\n\n    if (isPrimitiveSchemaType(schema.type)) {\n        if (schema.enum) {\n            return (\n                current +\n                complexityByType(schema as SchemaObject & { type: PrimitiveSchemaType }) +\n                complexityByComposite(\"enum\")\n                // NOTE: We intentionally do NOT add enum.length here\n                // Rationale: An enum is an enum whether it has 2 or 100 values\n                // The base complexity remains constant to ensure inlining behavior\n            );\n        }\n\n        return current + complexityByType(schema as SchemaObject & { type: PrimitiveSchemaType });\n    }\n\n    if (schema.type === \"array\") {\n        if (schema.items) {\n            return complexityByComposite(\"array\") + getSchemaComplexity({ current, schema: schema.items });\n        }\n\n        return complexityByComposite(\"array\") + getSchemaComplexity({ current, schema: undefined });\n    }\n\n    if (schema.type === \"object\" || schema.properties || schema.additionalProperties) {\n        if (schema.additionalProperties) {\n            if (schema.additionalProperties === true) {\n                return complexityByComposite(\"record\") + getSchemaComplexity({ current, schema: undefined });\n            }\n\n            return (\n                complexityByComposite(\"record\") + getSchemaComplexity({ current, schema: schema.additionalProperties })\n            );\n        }\n\n        if (schema.properties) {\n            return calculatePropertiesComplexity(\n                schema.properties,\n                current,\n                complexityByComposite,\n                getSchemaComplexity\n            );\n        }\n\n        return complexityByComposite(\"empty-object\") + getSchemaComplexity({ current, schema: undefined });\n    }\n\n    return current;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/template-context.ts","messages":[{"ruleId":"max-lines-per-function","severity":2,"message":"Arrow function has too many lines (253). Maximum allowed is 100.","line":20,"column":44,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":272,"endColumn":2},{"ruleId":"max-statements","severity":2,"message":"Arrow function has too many statements (41). Maximum allowed is 30.","line":20,"column":44,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":272,"endColumn":2},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":83,"column":26,"nodeType":"TSAsExpression","messageId":"never","endLine":88,"endColumn":26},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":99,"column":34,"nodeType":"TSAsExpression","messageId":"never","endLine":104,"endColumn":34},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":142,"column":32,"nodeType":"TSAsExpression","messageId":"never","endLine":142,"endColumn":64},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (481). Maximum allowed is 350.","line":351,"column":1,"nodeType":null,"messageId":"exceed","endLine":482,"endColumn":1}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { OpenAPIObject, OperationObject, PathItemObject, ReferenceObject, SchemaObject } from \"openapi3-ts\";\nimport { sortBy, sortListFromRefArray, sortObjKeysFromArray } from \"pastable/server\";\nimport { ts } from \"tanu\";\nimport { match } from \"ts-pattern\";\n\nimport { getOpenApiDependencyGraph } from \"./getOpenApiDependencyGraph.js\";\nimport type { EndpointDefinitionWithRefs } from \"./getZodiosEndpointDefinitionList.js\";\nimport { getZodiosEndpointDefinitionList } from \"./getZodiosEndpointDefinitionList.js\";\nimport type { TsConversionContext } from \"./openApiToTypescript.js\";\nimport { getTypescriptFromOpenApi } from \"./openApiToTypescript.js\";\nimport { getZodSchema } from \"./openApiToZod.js\";\nimport { topologicalSort } from \"./topologicalSort.js\";\nimport { asComponentSchema, normalizeString } from \"./utils.js\";\nimport type { CodeMetaData } from \"./CodeMeta.js\";\n\nconst file = ts.createSourceFile(\"\", \"\", ts.ScriptTarget.ESNext, true);\nconst printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\nconst printTs = (node: ts.Node) => printer.printNode(ts.EmitHint.Unspecified, node, file);\n\nexport const getZodClientTemplateContext = (openApiDoc: OpenAPIObject, options?: TemplateContext[\"options\"]) => {\n    const result = getZodiosEndpointDefinitionList(openApiDoc, options);\n    const data = makeTemplateContext();\n\n    const docSchemas = openApiDoc.components?.schemas ?? {};\n    const depsGraphs = getOpenApiDependencyGraph(\n        Object.keys(docSchemas).map((name) => asComponentSchema(name)),\n        result.resolver.getSchemaByRef\n    );\n\n    if (options?.shouldExportAllSchemas) {\n        Object.entries(docSchemas).forEach(([name, schema]) => {\n            if (!result.zodSchemaByName[name]) {\n                const schemaArgs = { schema, ctx: result, options };\n                const zodSchema = getZodSchema(schemaArgs);\n                const zodSchemaString = zodSchema.toString();\n                if (!zodSchemaString) {\n                    throw new Error(\n                        `Could not get Zod schema string for schema: ${name}, with value: ${JSON.stringify(schema)}`\n                    );\n                }\n                result.zodSchemaByName[name] = zodSchemaString;\n            }\n        });\n    }\n\n    const wrapWithLazyIfNeeded = (schemaName: string) => {\n        const code = result.zodSchemaByName[schemaName];\n        if (!code) {\n            throw new Error(`Zod schema not found for name: ${schemaName}`);\n        }\n\n        // Try to resolve the schema name to get its ref\n        // The schema might not be in byNormalized yet if it hasn't been accessed via getSchemaByRef\n        let ref: string | undefined;\n        try {\n            ref = result.resolver.resolveSchemaName(schemaName)?.ref;\n        } catch {\n            // Schema not yet resolved, try constructing the ref\n            ref = asComponentSchema(schemaName);\n        }\n\n        const isCircular = ref && depsGraphs.deepDependencyGraph[ref]?.has(ref);\n        if (isCircular) {\n            data.circularTypeByName[schemaName] = true;\n        }\n\n        return isCircular ? `z.lazy(() => ${code})` : code;\n    };\n\n    for (const name in result.zodSchemaByName) {\n        data.schemas[normalizeString(name)] = wrapWithLazyIfNeeded(name);\n    }\n\n    for (const ref in depsGraphs.deepDependencyGraph) {\n        const isCircular = ref && depsGraphs.deepDependencyGraph[ref]?.has(ref);\n        const ctx: TsConversionContext = { nodeByRef: {}, resolver: result.resolver, visitedRefs: {} };\n\n        // Specifically check isCircular if shouldExportAllTypes is false. Either should cause shouldGenerateType to be true.\n\n        const shouldGenerateType = options?.shouldExportAllTypes || isCircular;\n        const schemaName = shouldGenerateType ? result.resolver.resolveRef(ref)?.normalized : undefined;\n        if (shouldGenerateType && schemaName && !data.types[schemaName]) {\n            const node = getTypescriptFromOpenApi({\n                schema: result.resolver.getSchemaByRef(ref),\n                ctx,\n                meta: { name: schemaName },\n                options,\n            }) as ts.Node;\n            data.types[schemaName] = printTs(node).replace(\"export \", \"\");\n            data.emittedType[schemaName] = true;\n\n            for (const depRef of depsGraphs.deepDependencyGraph[ref] ?? []) {\n                const depSchemaName = result.resolver.resolveRef(depRef)?.normalized;\n                if (!depSchemaName) continue;\n                const isDepCircular = depsGraphs.deepDependencyGraph[depRef]?.has(depRef);\n\n                if (!isDepCircular && !data.types[depSchemaName]) {\n                    const nodeSchema = result.resolver.getSchemaByRef(depRef);\n                    const node = getTypescriptFromOpenApi({\n                        schema: nodeSchema,\n                        ctx,\n                        meta: { name: depSchemaName },\n                        options,\n                    }) as ts.Node;\n                    data.types[depSchemaName] = printTs(node).replace(\"export \", \"\");\n                    // defining types for strings and using the `z.ZodType<string>` type for their schema\n                    // prevents consumers of the type from adding zod validations like `.min()` to the type\n                    if (options?.shouldExportAllTypes && nodeSchema.type === \"object\") {\n                        data.emittedType[depSchemaName] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // NOTE: Topological sort ensures schemas are ordered by their dependencies\n    const schemaOrderedByDependencies = topologicalSort(depsGraphs.deepDependencyGraph).map((ref) => {\n        const resolved = result.resolver.resolveRef(ref);\n        if (!resolved) {\n            throw new Error(`Schema not found for $ref: ${ref}`);\n        }\n        return resolved.ref;\n    });\n    data.schemas = sortObjKeysFromArray(data.schemas, schemaOrderedByDependencies);\n\n    const groupStrategy = options?.groupStrategy ?? \"none\";\n    const dependenciesByGroupName = new Map<string, Set<string>>();\n\n    result.endpoints.forEach((endpoint) => {\n        if (!endpoint.response) return;\n\n        data.endpoints.push(endpoint);\n\n        if (groupStrategy !== \"none\") {\n            const operationPath = getOriginalPathWithBrackets(endpoint.path);\n            const pathItemObject: unknown = openApiDoc.paths[endpoint.path] ?? openApiDoc.paths[operationPath];\n            if (!pathItemObject || typeof pathItemObject !== \"object\") {\n                console.warn(\"Missing path\", endpoint.path);\n                return;\n            }\n\n            const operation = (pathItemObject as PathItemObject)[endpoint.method];\n            if (!operation) {\n                console.warn(`Missing operation ${endpoint.method} for path ${endpoint.path}`);\n                return;\n            }\n            const baseName = match(groupStrategy)\n                .with(\"tag\", \"tag-file\", () => operation.tags?.[0] ?? \"Default\")\n                .with(\"method\", \"method-file\", () => endpoint.method)\n                .exhaustive();\n            const groupName = normalizeString(baseName);\n\n            if (!data.endpointsGroups[groupName]) {\n                data.endpointsGroups[groupName] = makeEndpointTemplateContext();\n            }\n\n            const group = data.endpointsGroups[groupName];\n            group.endpoints.push(endpoint);\n\n            if (!dependenciesByGroupName.has(groupName)) {\n                dependenciesByGroupName.set(groupName, new Set());\n            }\n\n            const dependencies = dependenciesByGroupName.get(groupName);\n            if (!dependencies) {\n                throw new Error(`Dependencies not found for group: ${groupName}`);\n            }\n\n            const addDependencyIfNeeded = (schemaName: string) => {\n                if (!schemaName) return;\n                if (schemaName.startsWith(\"z.\")) return;\n                // Sometimes the schema includes a chain that should be removed from the dependency\n                const [normalizedSchemaName] = schemaName.split(\".\");\n                if (normalizedSchemaName) {\n                    dependencies.add(normalizedSchemaName);\n                }\n            };\n\n            addDependencyIfNeeded(endpoint.response);\n            endpoint.parameters.forEach((param) => addDependencyIfNeeded(param.schema));\n            endpoint.errors.forEach((param) => addDependencyIfNeeded(param.schema));\n            dependencies.forEach((schemaName) => {\n                const schema = data.schemas[schemaName];\n                if (schema) {\n                    group.schemas[schemaName] = schema;\n                }\n            });\n\n            // reduce types/schemas for each group using prev computed deep dependencies\n            if (groupStrategy.includes(\"file\")) {\n                [...dependencies].forEach((schemaName) => {\n                    const schemaType = data.types[schemaName];\n                    if (schemaType) {\n                        group.types[schemaName] = schemaType;\n                    }\n\n                    const schema = data.schemas[schemaName];\n                    if (schema) {\n                        group.schemas[schemaName] = schema;\n                    }\n\n                    // Try to resolve the schema name, fallback to constructing ref\n                    let resolvedRef: string | undefined;\n                    try {\n                        resolvedRef = result.resolver.resolveSchemaName(schemaName)?.ref;\n                    } catch {\n                        resolvedRef = asComponentSchema(schemaName);\n                    }\n\n                    depsGraphs.deepDependencyGraph[resolvedRef]?.forEach((transitiveRef) => {\n                        const transitiveSchemaName = result.resolver.resolveRef(transitiveRef)?.normalized;\n                        if (!transitiveSchemaName) return;\n                        addDependencyIfNeeded(transitiveSchemaName);\n                        const transitiveType = data.types[transitiveSchemaName];\n                        if (transitiveType) {\n                            group.types[transitiveSchemaName] = transitiveType;\n                        }\n                        const transitiveSchema = data.schemas[transitiveSchemaName];\n                        if (transitiveSchema) {\n                            group.schemas[transitiveSchemaName] = transitiveSchema;\n                        }\n                    });\n                });\n            }\n        }\n    });\n\n    data.endpoints = sortBy(data.endpoints, \"path\");\n\n    if (groupStrategy.includes(\"file\")) {\n        const dependenciesCount = new Map<string, number>();\n        dependenciesByGroupName.forEach((deps) => {\n            deps.forEach((dep) => {\n                dependenciesCount.set(dep, (dependenciesCount.get(dep) ?? -1) + 1);\n            });\n        });\n\n        const commonSchemaNames = new Set<string>();\n        Object.keys(data.endpointsGroups).forEach((groupName) => {\n            const group = data.endpointsGroups[groupName];\n            if (!group) return;\n            group.imports = {};\n\n            const groupSchemas: Record<string, string> = {};\n            const groupTypes: Record<string, string> = {};\n            Object.entries(group.schemas).forEach(([name, schema]) => {\n                const count = dependenciesCount.get(name) ?? 0;\n                if (count >= 1) {\n                    if (group.imports) {\n                        group.imports[name] = \"common\";\n                    }\n                    commonSchemaNames.add(name);\n                } else {\n                    groupSchemas[name] = schema;\n\n                    const groupType = group.types[name];\n                    if (groupType) {\n                        groupTypes[name] = groupType;\n                    }\n                }\n            });\n\n            group.schemas = sortObjKeysFromArray(groupSchemas, getPureSchemaNames(schemaOrderedByDependencies));\n            group.types = groupTypes;\n        });\n        data.commonSchemaNames = new Set(\n            sortListFromRefArray([...commonSchemaNames], getPureSchemaNames(schemaOrderedByDependencies))\n        );\n    }\n\n    return data;\n};\n\nconst makeEndpointTemplateContext = (): MinimalTemplateContext => ({ schemas: {}, endpoints: [], types: {} });\n\ntype MinimalTemplateContext = Pick<TemplateContext, \"endpoints\" | \"schemas\" | \"types\"> & {\n    imports?: Record<string, string>;\n};\n\nconst makeTemplateContext = (): TemplateContext => {\n    return {\n        ...makeEndpointTemplateContext(),\n        circularTypeByName: {},\n        endpointsGroups: {},\n        emittedType: {},\n        options: { withAlias: false, baseUrl: \"\" },\n    };\n};\n\nconst originalPathParam = /:(\\w+)/g;\nconst getOriginalPathWithBrackets = (path: string) => path.replaceAll(originalPathParam, \"{$1}\");\n// Example full schema name is like: #/components/schemas/Category.\n// We only want to get the \"Category\".\n//\n// This is because when using `sortObjKeysFromArray`, the string array needs to be exactly the same\n// like the object keys. Otherwise, the object keys won't be re-ordered.\nconst getPureSchemaNames = (fullSchemaNames: string[]) =>\n    fullSchemaNames.map((name) => {\n        const parts = name.split(\"/\");\n        const lastPart = parts.at(-1);\n        if (!lastPart) throw new Error(`Invalid schema name: ${name}`);\n        return lastPart;\n    });\n\nexport type TemplateContext = {\n    schemas: Record<string, string>;\n    endpoints: EndpointDefinitionWithRefs[];\n    endpointsGroups: Record<string, MinimalTemplateContext>;\n    types: Record<string, string>;\n    circularTypeByName: Record<string, true>;\n    emittedType: Record<string, true>;\n    commonSchemaNames?: Set<string>;\n    options?: TemplateContextOptions | undefined;\n};\n\nexport type TemplateContextGroupStrategy = \"none\" | \"tag\" | \"method\" | \"tag-file\" | \"method-file\";\n\nexport type TemplateContextOptions = {\n    /** @see https://www.zodios.org/docs/client#baseurl */\n    baseUrl?: string;\n    /**\n     * When true, will either use the `operationId` as `alias`, or auto-generate it from the method and path.\n     *\n     * You can alternatively provide a custom function to generate the alias with the following signature:\n     * `(path: string, method: string, operation: OperationObject) => string`\n     * `OperationObject` is the OpenAPI operation object as defined in `openapi3-ts` npm package.\n     * @see https://github.com/metadevpro/openapi3-ts/blob/master/src/model/OpenApi.ts#L110\n     *\n     * @see https://www.zodios.org/docs/client#zodiosalias\n     * @default true\n     */\n    withAlias?: boolean | ((path: string, method: string, operation: OperationObject) => string);\n    /**\n     * when using the default `template.hbs`, allow customizing the `export const {apiClientName}`\n     *\n     * @default \"api\"\n     */\n    apiClientName?: string;\n    /**\n     * when defined, will be used to pick which endpoint to use as the main one and set to `ZodiosEndpointDefinition[\"response\"]`\n     * will use `default` status code as fallback\n     *\n     * @see https://www.zodios.org/docs/api/api-definition#api-definition-structure\n     *\n     * works like `validateStatus` from axios\n     * @see https://github.com/axios/axios#handling-errors\n     *\n     * @default `(status >= 200 && status < 300)`\n     */\n    isMainResponseStatus?: string | ((status: number) => boolean);\n    /**\n     * when defined, will be used to pick which endpoints should be included in the `ZodiosEndpointDefinition[\"errors\"]` array\n     * ignores `default` status\n     *\n     * @see https://www.zodios.org/docs/api/api-definition#errors\n     *\n     * works like `validateStatus` from axios\n     * @see https://github.com/axios/axios#handling-errors\n     *\n     * @default `!(status >= 200 && status < 300)`\n     */\n    isErrorStatus?: string | ((status: number) => boolean);\n    /**\n     * when defined, will be used to pick the first MediaType found in ResponseObject[\"content\"] map matching the given expression\n     *\n     * context: some APIs returns multiple media types for the same response, this option allows you to pick which one to use\n     * or allows you to define a custom media type to use like `application/json-ld` or `application/vnd.api+json`) etc...\n     * @see https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#response-object\n     * @see https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#media-types\n     *\n     * @default `mediaType === \"application/json\"`\n     */\n    isMediaTypeAllowed?: string | ((mediaType: string) => boolean);\n    /** if OperationObject[\"description\"] is not defined but the main ResponseObject[\"description\"] is defined, use the latter as ZodiosEndpointDefinition[\"description\"] */\n    useMainResponseDescriptionAsEndpointDefinitionFallback?: boolean;\n    /**\n     * when true, will export all `#/components/schemas` even when not used in any PathItemObject\n     * @see https://github.com/astahmer/openapi-zod-client/issues/19\n     */\n    shouldExportAllSchemas?: boolean;\n    /**\n     * When true, will generate and output types for all schemas, not just circular ones.\n     * This helps with \"The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed.ts(7056)\" errors.\n     */\n    shouldExportAllTypes?: boolean;\n    /**\n     * when true, will make all properties of an object required by default (rather than the current opposite), unless an explicitly `required` array is set\n     * @see https://github.com/astahmer/openapi-zod-client/issues/23\n     */\n    withImplicitRequiredProps?: boolean;\n    /**\n     * when true, will add the default values from the openapi schemas to the generated zod schemas\n     *\n     * @default true\n     */\n    withDefaultValues?: boolean;\n    /**\n     * when true, will keep deprecated endpoints in the api output\n     * @default false\n     */\n    withDeprecatedEndpoints?: boolean;\n    /**\n     * when true, will add jsdoc comments to generated types\n     * @default false\n     */\n    withDocs?: boolean;\n    /**\n     * groups endpoints by a given strategy\n     *\n     * when strategy is \"tag\" and multiple tags are defined for an endpoint, the first one will be used\n     *\n     * @default \"none\"\n     */\n    groupStrategy?: TemplateContextGroupStrategy | undefined;\n    /**\n     * schema complexity threshold to determine which one (using less than `<` operator) should be assigned to a variable\n     * tl;dr higher means more schemas will be inlined (rather than assigned to a variable)\n     * ^ if you want to always inline schemas, set it to `-1` (special value) or a high value such as `1000`\n     * v if you want to assign all schemas to a variable, set it to `0`\n     *\n     * @default 4\n     */\n    complexityThreshold?: number | undefined;\n    /**\n     * when defined as \"auto-correct\", will automatically use `default` as fallback for `response` when no status code was declared\n     *\n     * - if no main response has been found, this should be considered it as a fallback\n     * - else this will be added as an error response\n     *\n     * @see https://github.com/astahmer/openapi-zod-client/pull/30#issuecomment-1280434068\n     *\n     * @default \"spec-compliant\"\n     */\n    defaultStatusBehavior?: \"spec-compliant\" | \"auto-correct\" | undefined;\n    willSuppressWarnings?: boolean | undefined;\n    /**\n     * when true, will add z.describe(xxx)\n     * @see https://github.com/astahmer/openapi-zod-client/pull/143\n     */\n    withDescription?: boolean | undefined;\n    /**\n     * A function to refine the default endpoint definition. Mostly useful for adding fields from OperationObject\n     * that aren't defined yet in the default definition.\n     */\n    endpointDefinitionRefiner?: (\n        defaultDefinition: EndpointDefinitionWithRefs,\n        operation: OperationObject\n    ) => EndpointDefinitionWithRefs | undefined;\n\n    /**\n     * When true, all generated objects and arrays will be readonly.\n     */\n    allReadonly?: boolean | undefined;\n\n    /**\n     * When true, all generated zod objects will be strict - meaning no unknown keys will be allowed\n     */\n    strictObjects?: boolean | undefined;\n\n    /**\n     * Set default value when additionalProperties is not provided. Default to true.\n     */\n    additionalPropertiesDefaultValue?: boolean | SchemaObject | undefined;\n\n    /**\n     * When true, returns a \"responses\" array with all responses (both success and errors)\n     */\n    withAllResponses?: boolean | undefined;\n\n    /**\n     * When true, prevents using the exact same name for the same type\n     * For example, if 2 schemas have the same type, but different names, export each as separate schemas\n     * If 2 schemas have the same name but different types, export subsequent names with numbers appended\n     */\n    exportAllNamedSchemas?: boolean | undefined;\n\n    /**\n     * A function that runs in the schema conversion process to refine the schema before it's converted to a Zod schema.\n     */\n    schemaRefiner?: <T extends SchemaObject | ReferenceObject>(schema: T, parentMeta?: CodeMetaData) => T | undefined;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/template-context.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/topologicalSort.ts","messages":[{"ruleId":"sonarjs/no-commented-code","severity":2,"message":"Remove this commented out code.","line":16,"column":21,"nodeType":null,"messageId":"commentedCode","endLine":18,"endColumn":26,"suggestions":[{"messageId":"commentedCodeFix","fix":{"range":[724,889],"text":""},"desc":"Remove this commented out code"}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** @see https://gist.github.com/RubyTuesdayDONO/5006455 */\nexport function topologicalSort(graph: Record<string, Set<string>>) {\n    const sorted: string[] = [], // sorted list of IDs ( returned value )\n        visited: Record<string, boolean> = {}; // hash: id of already visited node => true\n\n    function visit(name: string, ancestors: string[]) {\n        if (!Array.isArray(ancestors)) ancestors = [];\n        ancestors.push(name);\n        visited[name] = true;\n\n        if (graph[name]) {\n            graph[name].forEach((dep) => {\n                if (ancestors.includes(dep)) {\n                    // if already in ancestors, a closed chain (recursive relation) exists\n                    return;\n                    // throw new Error(\n                    //     'Circular dependency \"' + dep + '\" is required by \"' + name + '\": ' + ancestors.join(\" -> \")\n                    // );\n                }\n\n                // if already exists, do nothing\n                if (visited[dep]) return;\n                visit(dep, [...ancestors]); // recursive call\n            });\n        }\n\n        if (!sorted.includes(name)) sorted.push(name);\n    }\n\n    // 2. topological sort\n    Object.keys(graph).forEach((name) => visit(name, []));\n\n    return sorted;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/utils.ts","messages":[],"suppressedMessages":[{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x08, \\x0b, \\x0c, \\x0e, \\x1f.","line":100,"column":25,"nodeType":"Literal","messageId":"unexpected","endLine":100,"endColumn":95,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/no-control-regex","severity":2,"message":"Remove this control character.","line":100,"column":28,"nodeType":null,"endLine":100,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/no-control-regex","severity":2,"message":"Remove this control character.","line":100,"column":35,"nodeType":null,"endLine":100,"endColumn":41,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/no-control-regex","severity":2,"message":"Remove this control character.","line":100,"column":41,"nodeType":null,"endLine":100,"endColumn":47,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/no-control-regex","severity":2,"message":"Remove this control character.","line":100,"column":47,"nodeType":null,"endLine":100,"endColumn":53,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/no-control-regex","severity":2,"message":"Remove this control character.","line":100,"column":53,"nodeType":null,"endLine":100,"endColumn":59,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/no-control-regex","severity":2,"message":"Remove this control character.","line":100,"column":60,"nodeType":null,"endLine":100,"endColumn":66,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/no-nested-template-literals","severity":2,"message":"Refactor this code to not use nested template literals.","line":106,"column":47,"nodeType":"TemplateLiteral","messageId":"nestedTemplateLiterals","endLine":106,"endColumn":57,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"sonarjs/no-nested-template-literals","severity":2,"message":"Refactor this code to not use nested template literals.","line":108,"column":30,"nodeType":"TemplateLiteral","messageId":"nestedTemplateLiterals","endLine":108,"endColumn":42,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/zodiosEndpoint.helpers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/zodiosEndpoint.helpers.ts","messages":[{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":140,"column":21,"nodeType":"TSAsExpression","messageId":"never","endLine":140,"endColumn":105}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Pure helper functions for Zodios endpoint generation\n * Extracted to reduce cognitive complexity in getZodiosEndpointDefinitionList.ts\n *\n * Each function has a single responsibility and is < 50 lines\n */\n\nimport type { ReferenceObject, SchemaObject } from \"openapi3-ts\";\n\nimport type { CodeMeta } from \"./CodeMeta.js\";\nimport { getSchemaComplexity } from \"./schema-complexity.js\";\nimport { normalizeString } from \"./utils.js\";\n\ntype ZodiosContext = {\n    zodSchemaByName: Record<string, string>;\n    schemaByName: Record<string, string>;\n    schemasByName?: Record<string, string[]>;\n    resolver: {\n        resolveRef: (ref: string) => { name: string };\n        getSchemaByRef: (ref: string) => unknown;\n    };\n};\n\n/**\n * Checks if schema should be inlined (no variable extraction)\n * Returns true if complexity is below threshold or threshold is -1\n */\nexport function shouldInlineSchema(complexity: number, complexityThreshold: number): boolean {\n    // Special case: -1 means always inline everything\n    if (complexityThreshold === -1) {\n        return true;\n    }\n\n    // Simple schemas below threshold should be inlined\n    return complexity < complexityThreshold;\n}\n\n/**\n * Generates a unique variable name with collision detection\n * Iteratively adds suffix numbers until a unique name is found\n */\nexport function generateUniqueVarName(\n    baseName: string,\n    existingNames: Record<string, string>,\n    options?: {\n        exportAllNamedSchemas?: boolean;\n        schemasByName?: Record<string, string[]>;\n        schemaKey?: string;\n    }\n): string {\n    let formattedName = baseName;\n    let reuseCount = 1;\n\n    while (existingNames[formattedName]) {\n        // Check if we can reuse this name\n        if (options?.exportAllNamedSchemas && options.schemasByName && options.schemaKey) {\n            if (options.schemasByName[options.schemaKey]?.includes(formattedName)) {\n                return formattedName;\n            }\n        } else if (existingNames[formattedName] === baseName) {\n            return formattedName;\n        }\n\n        // Name is taken, try with suffix\n        reuseCount += 1;\n        formattedName = `${baseName}__${reuseCount}`;\n    }\n\n    return formattedName;\n}\n\n/**\n * Registers a schema name in the context for reuse\n */\nexport function registerSchemaName(\n    ctx: ZodiosContext,\n    varName: string,\n    schemaResult: string,\n    exportAllNamedSchemas: boolean\n): void {\n    ctx.zodSchemaByName[varName] = schemaResult;\n    ctx.schemaByName[schemaResult] = varName;\n\n    if (exportAllNamedSchemas && ctx.schemasByName) {\n        ctx.schemasByName[schemaResult] = (ctx.schemasByName[schemaResult] ?? []).concat(varName);\n    }\n}\n\n/**\n * Handles inline-everything mode (complexityThreshold === -1)\n * Returns the full schema definition or resolved reference\n */\nexport function handleInlineEverything(input: CodeMeta, result: string, ctx: ZodiosContext): string {\n    if (input.ref) {\n        const zodSchema = ctx.zodSchemaByName[result];\n        if (!zodSchema) {\n            throw new Error(`Zod schema not found for ref: ${result}`);\n        }\n        return zodSchema;\n    }\n    return result;\n}\n\n/**\n * Checks if a schema variable already exists and can be reused\n * Returns the existing variable name if found, undefined otherwise\n */\nexport function findExistingSchemaVar(\n    result: string,\n    ctx: ZodiosContext,\n    exportAllNamedSchemas: boolean\n): string | undefined {\n    if (!exportAllNamedSchemas && ctx.schemaByName[result]) {\n        return ctx.schemaByName[result];\n    }\n    return undefined;\n}\n\n/**\n * Handles reference schema variable naming\n * Resolves refs and checks complexity\n */\nexport function handleRefSchema(\n    input: CodeMeta,\n    result: string,\n    ctx: ZodiosContext,\n    complexityThreshold: number\n): string {\n    let schema = ctx.zodSchemaByName[result];\n\n    // Try to resolve ref if schema not found directly\n    if (!schema && input.ref) {\n        const refInfo = ctx.resolver.resolveRef(input.ref);\n        schema = ctx.zodSchemaByName[refInfo.name];\n    }\n\n    if (input.ref && schema) {\n        const complexity = getSchemaComplexity({\n            current: 0,\n            schema: ctx.resolver.getSchemaByRef(input.ref) as SchemaObject | ReferenceObject | undefined,\n        });\n\n        // Simple refs can be inlined\n        if (complexity < complexityThreshold) {\n            const zodSchema = ctx.zodSchemaByName[result];\n            if (!zodSchema) {\n                throw new Error(`Zod schema not found for ref: ${result}`);\n            }\n            return zodSchema;\n        }\n\n        return result;\n    }\n\n    console.log({ ref: input.ref, result });\n    throw new Error(\"Invalid ref: \" + input.ref);\n}\n\n/**\n * Main logic for determining variable name or inline schema\n * Orchestrates the various helper functions\n */\nexport function getSchemaVarName(\n    input: CodeMeta,\n    ctx: ZodiosContext,\n    complexityThreshold: number,\n    fallbackName: string | undefined,\n    options: { exportAllNamedSchemas?: boolean } | undefined\n): string {\n    const result = input.toString();\n\n    // Handle inline-everything mode\n    if (complexityThreshold === -1) {\n        return handleInlineEverything(input, result, ctx);\n    }\n\n    // Handle simple schemas with fallback names\n    if ((result.startsWith(\"z.\") || input.ref === undefined) && fallbackName) {\n        // Inline if simple enough\n        if (input.complexity < complexityThreshold) {\n            return result;\n        }\n\n        const safeName = normalizeString(fallbackName);\n\n        // Check if already exists\n        const existing = findExistingSchemaVar(result, ctx, Boolean(options?.exportAllNamedSchemas));\n        if (existing) {\n            return existing;\n        }\n\n        // Generate unique name and register\n        const varName = ctx.schemasByName\n            ? generateUniqueVarName(safeName, ctx.zodSchemaByName, {\n                  exportAllNamedSchemas: options?.exportAllNamedSchemas ?? false,\n                  schemasByName: ctx.schemasByName,\n                  schemaKey: result,\n              })\n            : generateUniqueVarName(safeName, ctx.zodSchemaByName);\n\n        registerSchemaName(ctx, varName, result, options?.exportAllNamedSchemas ?? false);\n        return varName;\n    }\n\n    // Handle reference schemas\n    return handleRefSchema(input, result, ctx, complexityThreshold);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/zodiosEndpoint.operation.helpers.ts","messages":[{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":76,"column":25,"nodeType":"TSAsExpression","messageId":"never","endLine":80,"endColumn":27},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":132,"column":23,"nodeType":"TSAsExpression","messageId":"never","endLine":132,"endColumn":118},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":203,"column":18,"nodeType":"TSAsExpression","messageId":"never","endLine":207,"endColumn":46},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":233,"column":26,"nodeType":"TSAsExpression","messageId":"never","endLine":235,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Pure helper functions for processing individual Zodios endpoint operations\n * Extracted to reduce cognitive complexity in getZodiosEndpointDefinitionList.ts main loop\n */\n\nimport type {\n    OperationObject,\n    ParameterObject,\n    RequestBodyObject,\n    ResponseObject,\n    SchemaObject,\n    ReferenceObject,\n} from \"openapi3-ts\";\nimport { isReferenceObject, isSchemaObject } from \"openapi3-ts\";\nimport { match, P } from \"ts-pattern\";\n\nimport type { CodeMeta, ConversionTypeContext } from \"./CodeMeta.js\";\nimport { getZodChain, getZodSchema } from \"./openApiToZod.js\";\nimport type { TemplateContext } from \"./template-context.js\";\nimport type { DefaultStatusBehavior } from \"./template-context.types.js\";\nimport { pathParamToVariableName } from \"./utils.js\";\n\nconst voidSchema = \"z.void()\";\n\nexport type GetZodVarNameFn = (input: CodeMeta, fallbackName?: string) => string;\n\ntype EndpointParameter = {\n    name: string;\n    type: \"Body\" | \"Header\" | \"Query\" | \"Path\";\n    description?: string;\n    schema: string;\n};\n\ntype EndpointResponse = {\n    statusCode: string;\n    schema: string;\n    description?: string;\n};\n\ntype EndpointError = {\n    schema: string;\n    status: number | \"default\";\n    description?: string;\n};\n\nconst allowedPathInValues = [\"path\", \"query\", \"header\"];\n\nconst isAllowedParamMediaTypes = (mediaType: string) =>\n    mediaType === \"*/*\" ||\n    mediaType.includes(\"json\") ||\n    mediaType.includes(\"x-www-form-urlencoded\") ||\n    mediaType.includes(\"form-data\") ||\n    mediaType.includes(\"octet-stream\") ||\n    mediaType.includes(\"text/\");\n\nconst isMediaTypeAllowed = (mediaType: string) => mediaType.includes(\"json\") || mediaType.includes(\"text/\");\n\nconst isMainResponseStatus = (status: number) => status >= 200 && status < 300;\nconst isErrorStatus = (status: number) => status >= 400 && status < 600;\n\n/**\n * Processes request body for an endpoint\n * Returns the body parameter and request format\n */\nexport function processRequestBody(\n    operation: OperationObject,\n    ctx: ConversionTypeContext,\n    operationName: string,\n    getZodVarName: GetZodVarNameFn,\n    options?: TemplateContext[\"options\"]\n): { parameter: EndpointParameter; requestFormat: \"json\" | \"binary\" | \"form-url\" | \"form-data\" | \"text\" } | undefined {\n    if (!operation.requestBody) {\n        return undefined;\n    }\n\n    const requestBody = (\n        isReferenceObject(operation.requestBody)\n            ? ctx.resolver.getSchemaByRef(operation.requestBody.$ref)\n            : operation.requestBody\n    ) as RequestBodyObject;\n\n    const mediaTypes = Object.keys(requestBody.content ?? {});\n    const matchingMediaType = mediaTypes.find(isAllowedParamMediaTypes);\n    const bodySchema = matchingMediaType && requestBody.content?.[matchingMediaType]?.schema;\n\n    if (!bodySchema) {\n        return undefined;\n    }\n\n    const requestFormat = match(matchingMediaType)\n        .with(\"application/octet-stream\", () => \"binary\" as const)\n        .with(\"application/x-www-form-urlencoded\", () => \"form-url\" as const)\n        .with(\"multipart/form-data\", () => \"form-data\" as const)\n        .with(P.string.includes(\"json\"), () => \"json\" as const)\n        .otherwise(() => \"text\" as const);\n\n    const bodyCode = getZodSchema({\n        schema: bodySchema,\n        ctx,\n        meta: { isRequired: requestBody.required ?? true },\n        options,\n    });\n\n    const schema =\n        getZodVarName(bodyCode, operationName + \"_Body\") +\n        getZodChain({\n            schema: isReferenceObject(bodySchema) ? ctx.resolver.getSchemaByRef(bodySchema.$ref) : bodySchema,\n            meta: bodyCode.meta,\n        });\n\n    return {\n        parameter: {\n            name: \"body\",\n            type: \"Body\",\n            description: requestBody.description ?? \"\",\n            schema,\n        },\n        requestFormat,\n    };\n}\n\n/**\n * Processes a single parameter for an endpoint\n * Returns the parameter definition or undefined if it should be skipped\n */\nexport function processParameter(\n    param: ParameterObject | ReferenceObject,\n    ctx: ConversionTypeContext,\n    getZodVarName: GetZodVarNameFn,\n    options?: TemplateContext[\"options\"]\n): EndpointParameter | undefined {\n    const paramItem = (isReferenceObject(param) ? ctx.resolver.getSchemaByRef(param.$ref) : param) as ParameterObject;\n\n    if (!allowedPathInValues.includes(paramItem.in)) {\n        return undefined;\n    }\n\n    let paramSchema: SchemaObject | ReferenceObject | undefined;\n\n    if (paramItem.content) {\n        const mediaTypes = Object.keys(paramItem.content ?? {});\n        const matchingMediaType = mediaTypes.find(isAllowedParamMediaTypes);\n\n        if (!matchingMediaType) {\n            throw new Error(`Unsupported media type for param ${paramItem.name}: ${mediaTypes.join(\", \")}`);\n        }\n\n        const mediaTypeObject = paramItem.content[matchingMediaType];\n        if (!mediaTypeObject) {\n            throw new Error(`No content with media type for param ${paramItem.name}: ${matchingMediaType}`);\n        }\n\n        // Per OAS 3.0 spec: MediaType.schema must be Schema | Reference\n        // $ref should be inside the schema property, not at the MediaType level\n        if (!mediaTypeObject.schema) {\n            throw new Error(\n                `Invalid OpenAPI specification: mediaTypeObject for parameter \"${paramItem.name}\" ` +\n                    `must have a 'schema' property. Found ${Object.keys(mediaTypeObject).join(\", \")}. ` +\n                    `See: https://spec.openapis.org/oas/v3.0.3#media-type-object`\n            );\n        }\n\n        paramSchema = mediaTypeObject.schema;\n    } else if (paramItem.schema) {\n        paramSchema = isReferenceObject(paramItem.schema)\n            ? ctx.resolver.getSchemaByRef(paramItem.schema.$ref)\n            : paramItem.schema;\n    } else {\n        // OpenAPI spec requires parameters to have either 'schema' or 'content'\n        // Per SchemaXORContent constraint in OAS 3.0+ spec\n        throw new Error(\n            `Invalid OpenAPI specification: Parameter \"${paramItem.name}\" (in: ${paramItem.in}) must have either 'schema' or 'content' property. ` +\n                `See: https://spec.openapis.org/oas/v3.0.3#parameter-object`\n        );\n    }\n\n    // Ensure schema was successfully resolved from references\n    if (!paramSchema) {\n        throw new Error(\n            `Invalid OpenAPI specification: Could not resolve schema for parameter \"${paramItem.name}\" (in: ${paramItem.in}). ` +\n                `This may indicate a missing or invalid $ref target.`\n        );\n    }\n\n    if (options?.withDescription && isSchemaObject(paramSchema)) {\n        paramSchema.description = (paramItem.description ?? \"\").trim();\n    }\n\n    // Resolve ref if needed, fallback to default (unknown) value if needed\n    paramSchema = isReferenceObject(paramSchema) ? ctx.resolver.getSchemaByRef(paramSchema.$ref) : paramSchema;\n\n    const paramCode = getZodSchema({\n        schema: paramSchema,\n        ctx,\n        meta: { isRequired: paramItem.in === \"path\" ? true : (paramItem.required ?? false) },\n        options,\n    });\n\n    const name = match(paramItem.in)\n        .with(\"path\", () => pathParamToVariableName(paramItem.name))\n        .otherwise(() => paramItem.name);\n\n    const type = match(paramItem.in)\n        .with(\"header\", () => \"Header\")\n        .with(\"query\", () => \"Query\")\n        .with(\"path\", () => \"Path\")\n        .run() as \"Header\" | \"Query\" | \"Path\";\n\n    const schema = getZodVarName(\n        paramCode.assign(paramCode.toString() + getZodChain({ schema: paramSchema, meta: paramCode.meta, options })),\n        paramItem.name\n    );\n\n    return { name, type, schema };\n}\n\n/**\n * Processes a single response for an endpoint\n * Returns response data and updates to make to the endpoint\n */\nexport function processResponse(\n    statusCode: string,\n    responseObj: ResponseObject | ReferenceObject,\n    ctx: ConversionTypeContext,\n    getZodVarName: GetZodVarNameFn,\n    options?: TemplateContext[\"options\"]\n): {\n    responseEntry?: EndpointResponse;\n    mainResponse?: string;\n    mainResponseDescription?: string;\n    error?: EndpointError;\n} {\n    const responseItem = (\n        isReferenceObject(responseObj) ? ctx.resolver.getSchemaByRef(responseObj.$ref) : responseObj\n    ) as ResponseObject;\n\n    const mediaTypes = Object.keys(responseItem.content ?? {});\n    const matchingMediaType = mediaTypes.find(isMediaTypeAllowed);\n    const maybeSchema = matchingMediaType ? responseItem.content?.[matchingMediaType]?.schema : null;\n\n    let schemaString = matchingMediaType ? undefined : voidSchema;\n    let schema: CodeMeta | undefined;\n\n    if (maybeSchema) {\n        schema = getZodSchema({ schema: maybeSchema, ctx, meta: { isRequired: true }, options });\n        schemaString =\n            (schema.ref ? getZodVarName(schema) : schema.toString()) +\n            getZodChain({\n                schema: isReferenceObject(maybeSchema) ? ctx.resolver.getSchemaByRef(maybeSchema.$ref) : maybeSchema,\n                meta: schema.meta,\n            });\n    }\n\n    const result: ReturnType<typeof processResponse> = {};\n\n    if (options?.withAllResponses) {\n        result.responseEntry = {\n            statusCode,\n            schema: schemaString ?? voidSchema,\n            description: responseItem.description,\n        };\n    }\n\n    if (schemaString) {\n        const status = Number(statusCode);\n\n        if (isMainResponseStatus(status)) {\n            result.mainResponse = schemaString;\n            if (responseItem.description && options?.useMainResponseDescriptionAsEndpointDefinitionFallback) {\n                result.mainResponseDescription = responseItem.description;\n            }\n        } else if (statusCode !== \"default\" && isErrorStatus(status)) {\n            result.error = {\n                schema: schemaString,\n                status,\n                description: responseItem.description,\n            };\n        }\n    }\n\n    return result;\n}\n\n/**\n * Processes the default response for an endpoint\n * Returns updates to make based on defaultStatusBehavior\n */\nexport function processDefaultResponse(\n    defaultResponse: ResponseObject,\n    ctx: ConversionTypeContext,\n    getZodVarName: GetZodVarNameFn,\n    hasMainResponse: boolean,\n    defaultStatusBehavior: DefaultStatusBehavior,\n    options?: TemplateContext[\"options\"]\n): {\n    mainResponse?: string;\n    error?: EndpointError;\n    shouldIgnoreFallback?: boolean;\n    shouldIgnoreGeneric?: boolean;\n} {\n    const mediaTypes = Object.keys(defaultResponse.content ?? {});\n    const matchingMediaType = mediaTypes.find(isMediaTypeAllowed);\n    const maybeSchema = matchingMediaType && defaultResponse.content?.[matchingMediaType]?.schema;\n\n    let schemaString = matchingMediaType ? undefined : voidSchema;\n    let schema: CodeMeta | undefined;\n\n    if (maybeSchema) {\n        schema = getZodSchema({ schema: maybeSchema, ctx, meta: { isRequired: true }, options });\n        schemaString =\n            (schema.ref ? getZodVarName(schema) : schema.toString()) +\n            getZodChain({\n                schema: isReferenceObject(maybeSchema) ? ctx.resolver.getSchemaByRef(maybeSchema.$ref) : maybeSchema,\n                meta: schema.meta,\n            });\n    }\n\n    if (!schemaString) {\n        return {};\n    }\n\n    if (defaultStatusBehavior === \"auto-correct\") {\n        if (hasMainResponse) {\n            return {\n                error: {\n                    schema: schemaString,\n                    status: \"default\",\n                    description: defaultResponse.description,\n                },\n            };\n        }\n        return { mainResponse: schemaString };\n    }\n\n    // spec-compliant mode\n    if (hasMainResponse) {\n        return { shouldIgnoreFallback: true };\n    }\n    return { shouldIgnoreGeneric: true };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/src/zodiosEndpoint.path.helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-assignment","severity":2,"message":"Unsafe assignment of an `any` value.","line":33,"column":15,"nodeType":"VariableDeclarator","messageId":"anyAssignment","endLine":33,"endColumn":60},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":36,"column":52,"nodeType":"TSAsExpression","messageId":"never","endLine":36,"endColumn":81},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":72,"column":9,"nodeType":"TSAsExpression","messageId":"never","endLine":72,"endColumn":54},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":128,"column":17,"nodeType":"TSAsExpression","messageId":"never","endLine":128,"endColumn":63},{"ruleId":"@typescript-eslint/consistent-type-assertions","severity":1,"message":"Do not use any type assertions.","line":145,"column":43,"nodeType":"TSAsExpression","messageId":"never","endLine":145,"endColumn":85}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Helpers for processing operations within getZodiosEndpointDefinitionList\n * Extracted to reduce cognitive complexity in the main function\n */\n\nimport type { OperationObject, ParameterObject, ReferenceObject, ResponseObject } from \"openapi3-ts\";\nimport type { TemplateContext } from \"./template-context.js\";\nimport type { DefaultStatusBehavior } from \"./template-context.types.js\";\nimport type { ConversionTypeContext } from \"./CodeMeta.js\";\nimport type { EndpointDefinitionWithRefs } from \"./getZodiosEndpointDefinitionList.js\";\nimport { replaceHyphenatedPath } from \"./utils.js\";\nimport type { GetZodVarNameFn } from \"./zodiosEndpoint.operation.helpers.js\";\nimport {\n    processDefaultResponse,\n    processParameter,\n    processRequestBody,\n    processResponse,\n} from \"./zodiosEndpoint.operation.helpers.js\";\n\nconst voidSchema = \"z.void()\";\n\n/**\n * Processes all responses for an operation, collecting main response, errors, and response entries\n */\nfunction processResponses(\n    operation: OperationObject,\n    endpointDefinition: EndpointDefinitionWithRefs,\n    ctx: ConversionTypeContext,\n    getZodVarName: GetZodVarNameFn,\n    options?: TemplateContext[\"options\"]\n): void {\n    for (const statusCode in operation.responses) {\n        const responseObj = operation.responses[statusCode];\n        if (!responseObj) continue;\n\n        const result = processResponse(statusCode, responseObj as ResponseObject, ctx, getZodVarName, options);\n\n        if (result.responseEntry && endpointDefinition.responses !== undefined) {\n            endpointDefinition.responses.push(result.responseEntry);\n        }\n\n        if (result.mainResponse && !endpointDefinition.response) {\n            endpointDefinition.response = result.mainResponse;\n            if (!endpointDefinition.description && result.mainResponseDescription) {\n                endpointDefinition.description = result.mainResponseDescription;\n            }\n        }\n\n        if (result.error) {\n            endpointDefinition.errors.push(result.error);\n        }\n    }\n}\n\n/**\n * Processes default response and returns warnings if needed\n */\nfunction handleDefaultResponse(\n    operation: OperationObject,\n    endpointDefinition: EndpointDefinitionWithRefs,\n    operationName: string,\n    ctx: ConversionTypeContext,\n    getZodVarName: GetZodVarNameFn,\n    defaultStatusBehavior: DefaultStatusBehavior | undefined,\n    options?: TemplateContext[\"options\"]\n): { ignoredFallback?: string | undefined; ignoredGeneric?: string | undefined } {\n    if (!operation.responses?.default) {\n        return {};\n    }\n\n    const defaultResult = processDefaultResponse(\n        operation.responses.default as ResponseObject,\n        ctx,\n        getZodVarName,\n        Boolean(endpointDefinition.response),\n        defaultStatusBehavior ?? \"spec-compliant\",\n        options\n    );\n\n    if (defaultResult.mainResponse) {\n        endpointDefinition.response = defaultResult.mainResponse;\n    }\n\n    if (defaultResult.error) {\n        endpointDefinition.errors.push(defaultResult.error);\n    }\n\n    return {\n        ignoredFallback: defaultResult.shouldIgnoreFallback ? operationName : undefined,\n        ignoredGeneric: defaultResult.shouldIgnoreGeneric ? operationName : undefined,\n    };\n}\n\ntype ProcessOperationParams = {\n    path: string;\n    method: string;\n    operation: OperationObject;\n    operationName: string;\n    parameters: Array<unknown>;\n    ctx: ConversionTypeContext;\n    getZodVarName: GetZodVarNameFn;\n    defaultStatusBehavior: DefaultStatusBehavior | undefined;\n    options?: TemplateContext[\"options\"];\n};\n\ntype ProcessOperationResult = {\n    endpoint: EndpointDefinitionWithRefs;\n    ignoredFallback?: string | undefined;\n    ignoredGeneric?: string | undefined;\n};\n\n/**\n * Processes a single operation to create an endpoint definition\n * Handles request body, parameters, responses, and default responses\n */\nexport function processOperation({\n    path,\n    method,\n    operation,\n    operationName,\n    parameters,\n    ctx,\n    getZodVarName,\n    defaultStatusBehavior,\n    options,\n}: ProcessOperationParams): ProcessOperationResult {\n    let endpointDefinition: EndpointDefinitionWithRefs = {\n        method: method as EndpointDefinitionWithRefs[\"method\"],\n        path: replaceHyphenatedPath(path),\n        ...(options?.withAlias && { alias: operationName }),\n        description: operation.description,\n        requestFormat: \"json\",\n        parameters: [],\n        errors: [],\n        response: \"\",\n    };\n\n    const bodyResult = processRequestBody(operation, ctx, operationName, getZodVarName, options);\n    if (bodyResult) {\n        endpointDefinition.requestFormat = bodyResult.requestFormat;\n        endpointDefinition.parameters.push(bodyResult.parameter);\n    }\n\n    for (const param of parameters) {\n        const paramDef = processParameter(param as ParameterObject | ReferenceObject, ctx, getZodVarName, options);\n        if (paramDef) {\n            endpointDefinition.parameters.push(paramDef);\n        }\n    }\n\n    if (options?.withAllResponses) {\n        endpointDefinition.responses = [];\n    }\n\n    processResponses(operation, endpointDefinition, ctx, getZodVarName, options);\n\n    const { ignoredFallback, ignoredGeneric } = handleDefaultResponse(\n        operation,\n        endpointDefinition,\n        operationName,\n        ctx,\n        getZodVarName,\n        defaultStatusBehavior,\n        options\n    );\n\n    if (!endpointDefinition.response) {\n        endpointDefinition.response = voidSchema;\n    }\n\n    if (options?.endpointDefinitionRefiner) {\n        const refined = options.endpointDefinitionRefiner(endpointDefinition, operation);\n        if (refined) {\n            endpointDefinition = refined;\n        }\n    }\n\n    return { endpoint: endpointDefinition, ignoredFallback, ignoredGeneric };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/additionalProperties-is-default.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/additionalPropertiesDefaultValue-option.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/allOf-infer-required-only-item.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/allOf-missing-and.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/allOf-oneOf-anyOf-single-ref.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/anyOf-behavior.test.ts","messages":[{"ruleId":"@typescript-eslint/no-implied-eval","severity":2,"message":"Implied eval. Do not use the Function constructor to create functions.","line":13,"column":12,"nodeType":"NewExpression","messageId":"noFunctionConstructor","endLine":13,"endColumn":74},{"ruleId":"sonarjs/code-eval","severity":2,"message":"Make sure that this dynamic injection or execution of code is safe.","line":13,"column":16,"nodeType":"Identifier","messageId":"safeCode","endLine":13,"endColumn":24},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"CodeMeta\" of template literal expression.","line":13,"column":49,"nodeType":"Identifier","messageId":"invalidType","endLine":13,"endColumn":58}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, test, expect } from \"vitest\";\nimport { z } from \"zod\";\nimport { getZodSchema } from \"../src/openApiToZod.js\";\nimport { type CodeMeta } from \"../src/CodeMeta.js\";\nimport { type OpenAPIObject } from \"openapi3-ts\";\nimport { generateZodClientFromOpenAPI } from \"../src/generateZodClientFromOpenAPI.js\";\n\n// the schemas and fixtures used in these tests are modified from examples here: https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/#anyof\n\ntype Validator = <T>(zod: typeof z, input: T) => T;\n\nfunction createValidator(zodSchema: CodeMeta) {\n    return new Function(\"z\", \"input\", `return ${zodSchema}.parse(input)`) as Validator;\n}\n\nconst fixtures = {\n    petByAge: { age: 4 },\n    petByType: { pet_type: \"Cat\" },\n    petByAgeAndType: {\n        nickname: \"Fido\",\n        pet_type: \"Dog\",\n        age: 4,\n    },\n    invalid: {\n        nickname: \"Mr. Paws\",\n        hunts: false,\n    },\n};\n\ndescribe(\"anyOf behavior\", () => {\n    test(\"adds passthrough() to objects\", () => {\n        const zodSchema = getZodSchema({\n            schema: {\n                anyOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            age: {\n                                type: \"integer\",\n                            },\n                            nickname: {\n                                type: \"string\",\n                            },\n                        },\n                        required: [\"age\"],\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            pet_type: {\n                                type: \"string\",\n                                enum: [\"Cat\", \"Dog\"],\n                            },\n                            hunts: {\n                                type: \"boolean\",\n                            },\n                        },\n                        required: [\"pet_type\"],\n                    },\n                ],\n            },\n        });\n\n        expect(zodSchema).toMatchInlineSnapshot(\n            '\"z.union([z.object({ age: z.number().int(), nickname: z.string().optional() }).passthrough(), z.object({ pet_type: z.enum([\"Cat\", \"Dog\"]), hunts: z.boolean().optional() }).passthrough()])\"'\n        );\n\n        const validator = createValidator(zodSchema);\n        expect(validator(z, fixtures.petByAge)).toEqual(fixtures.petByAge);\n        expect(validator(z, fixtures.petByType)).toEqual(fixtures.petByType);\n        expect(validator(z, fixtures.petByAgeAndType)).toEqual(fixtures.petByAgeAndType);\n        expect(() => validator(z, fixtures.invalid)).toThrowError();\n    });\n\n    test(\"handles mixes of primitive types and objects\", () => {\n        const zodSchema = getZodSchema({\n            schema: {\n                anyOf: [\n                    {\n                        type: \"object\",\n                        properties: {\n                            age: {\n                                type: \"integer\",\n                            },\n                            nickname: {\n                                type: \"string\",\n                            },\n                        },\n                        required: [\"age\"],\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            pet_type: {\n                                type: \"string\",\n                                enum: [\"Cat\", \"Dog\"],\n                            },\n                            hunts: {\n                                type: \"boolean\",\n                            },\n                        },\n                        required: [\"pet_type\"],\n                    },\n                    { type: \"number\" },\n                ],\n            },\n        });\n\n        expect(zodSchema).toMatchInlineSnapshot(\n            '\"z.union([z.object({ age: z.number().int(), nickname: z.string().optional() }).passthrough(), z.object({ pet_type: z.enum([\"Cat\", \"Dog\"]), hunts: z.boolean().optional() }).passthrough(), z.number()])\"'\n        );\n\n        const validator = createValidator(zodSchema);\n        expect(validator(z, fixtures.petByAge)).toEqual(fixtures.petByAge);\n        expect(validator(z, fixtures.petByType)).toEqual(fixtures.petByType);\n        expect(validator(z, fixtures.petByAgeAndType)).toEqual(fixtures.petByAgeAndType);\n        expect(() => validator(z, fixtures.invalid)).toThrowError();\n        expect(validator(z, 1)).toEqual(1);\n    });\n\n    test(\"handles an array of types\", () => {\n        const zodSchema = getZodSchema({\n            schema: {\n                anyOf: [\n                    {\n                        type: [\"number\", \"boolean\"],\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            age: {\n                                type: \"integer\",\n                            },\n                            nickname: {\n                                type: \"string\",\n                            },\n                        },\n                        required: [\"age\"],\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            pet_type: {\n                                type: \"string\",\n                                enum: [\"Cat\", \"Dog\"],\n                            },\n                            hunts: {\n                                type: \"boolean\",\n                            },\n                        },\n                        required: [\"pet_type\"],\n                    },\n                    { type: \"string\" },\n                ],\n            },\n        });\n\n        expect(zodSchema).toMatchInlineSnapshot(\n            '\"z.union([z.union([z.number(), z.boolean()]), z.object({ age: z.number().int(), nickname: z.string().optional() }).passthrough(), z.object({ pet_type: z.enum([\"Cat\", \"Dog\"]), hunts: z.boolean().optional() }).passthrough(), z.string()])\"'\n        );\n\n        const validator = createValidator(zodSchema);\n        expect(validator(z, fixtures.petByAge)).toEqual(fixtures.petByAge);\n        expect(validator(z, fixtures.petByType)).toEqual(fixtures.petByType);\n        expect(validator(z, fixtures.petByAgeAndType)).toEqual(fixtures.petByAgeAndType);\n        expect(() => validator(z, fixtures.invalid)).toThrowError();\n        expect(validator(z, 1)).toEqual(1);\n        expect(validator(z, \"hello\")).toEqual(\"hello\");\n        expect(validator(z, true)).toEqual(true);\n    });\n\n    test(\"handles $refs\", async () => {\n        const openApiDoc: OpenAPIObject = {\n            openapi: \"3.0.2\",\n            info: {\n                title: \"anyOf with refs\",\n                version: \"v1\",\n            },\n            paths: {\n                \"/test\": {\n                    get: {\n                        parameters: [\n                            {\n                                name: \"anyOfRef\",\n                                schema: {\n                                    anyOf: [\n                                        { $ref: \"#/components/schemas/PetByAge\" },\n                                        { $ref: \"#/components/schemas/PetByType\" },\n                                    ],\n                                },\n                                in: \"query\",\n                            },\n                        ],\n                    },\n                },\n            },\n            components: {\n                schemas: {\n                    PetByAge: {\n                        type: \"object\",\n                        properties: {\n                            age: {\n                                type: \"integer\",\n                            },\n                            nickname: {\n                                type: \"string\",\n                            },\n                        },\n                        required: [\"age\"],\n                    },\n                    PetByType: {\n                        type: \"object\",\n                        properties: {\n                            pet_type: {\n                                type: \"string\",\n                                enum: [\"Cat\", \"Dog\"],\n                            },\n                            hunts: {\n                                type: \"boolean\",\n                            },\n                        },\n                        required: [\"pet_type\"],\n                    },\n                },\n            },\n        };\n\n        const output = await generateZodClientFromOpenAPI({ disableWriteToFile: true, openApiDoc });\n        expect(output).toMatchInlineSnapshot(`\n          \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const PetByAge = z\n            .object({ age: z.number().int(), nickname: z.string().optional() })\n            .passthrough();\n          const PetByType = z\n            .object({ pet_type: z.enum([\"Cat\", \"Dog\"]), hunts: z.boolean().optional() })\n            .passthrough();\n          const anyOfRef = z.union([PetByAge, PetByType]).optional();\n\n          export const schemas = {\n            PetByAge,\n            PetByType,\n            anyOfRef,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"get\",\n              path: \"/test\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"anyOfRef\",\n                  type: \"Query\",\n                  schema: anyOfRef,\n                },\n              ],\n              response: z.void(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \"\n        `);\n    });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/array-body-with-chains-tag-group-strategy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/array-default-values.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/array-oneOf-discriminated-union.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/autofix-unusual-ref-format.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/common-parameters.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/defaut-status-behavior.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/deps-graph-with-additionalProperties.test.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":21,"column":55,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":21,"endColumn":57,"suggestions":[{"messageId":"removeAsync","fix":{"range":[758,764],"text":""},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type ReferenceObject, type SchemaObject, type SchemasObject } from \"openapi3-ts\";\nimport { expect, test } from \"vitest\";\nimport { getOpenApiDependencyGraph } from \"../src/index.js\";\n\nconst makeOpenApiDoc = (schemas: SchemasObject, responseSchema: SchemaObject | ReferenceObject) => ({\n    openapi: \"3.0.3\",\n    info: { title: \"Swagger Petstore - OpenAPI 3.0\", version: \"1.0.11\" },\n    paths: {\n        \"/example\": {\n            get: {\n                operationId: \"getExample\",\n                responses: {\n                    \"200\": { description: \"OK\", content: { \"application/json\": { schema: responseSchema } } },\n                },\n            },\n        },\n    },\n    components: { schemas },\n});\n\ntest(\"deps-graph-with-additionalProperties\", async () => {\n    const schemas = {\n        ResponseItem: {\n            type: \"object\",\n            properties: {\n                id: { type: \"string\" },\n            },\n        },\n        Something: {\n            type: \"object\",\n            properties: {\n                str: { type: \"string\" },\n            },\n        },\n        ResponsesMap: {\n            type: \"object\",\n            properties: {\n                smth: { $ref: \"Something\" },\n            },\n            additionalProperties: {\n                $ref: \"ResponseItem\",\n            },\n        },\n    } as SchemasObject;\n    const openApiDoc = makeOpenApiDoc(schemas, { $ref: \"ResponsesMap\" });\n    const getSchemaByRef = (ref: string): SchemaObject | ReferenceObject => {\n        const schema = schemas[ref];\n        if (!schema) throw new Error(`Schema not found: ${ref}`);\n        return schema;\n    };\n    expect(getOpenApiDependencyGraph(Object.keys(openApiDoc.components.schemas), getSchemaByRef))\n        .toMatchInlineSnapshot(`\n          {\n              \"deepDependencyGraph\": {\n                  \"ResponsesMap\": Set {\n                      \"Something\",\n                      \"ResponseItem\",\n                  },\n              },\n              \"refsDependencyGraph\": {\n                  \"ResponsesMap\": Set {\n                      \"Something\",\n                      \"ResponseItem\",\n                  },\n              },\n          }\n        `);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/description-in-zod.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/enum-min-max.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/enum-null.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/errors-responses.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/export-all-named-schemas.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/export-all-types.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/export-schemas-option.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/group-strategy-file-multi-props-object-as-query-parameter.test.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":7,"column":85,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":7,"endColumn":87,"suggestions":[{"messageId":"removeAsync","fix":{"range":[380,386],"text":""},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { OpenAPIObject } from \"openapi3-ts\";\nimport { describe, expect, test } from \"vitest\";\nimport { generateZodClientFromOpenAPI } from \"../src/index.js\";\nimport type { TemplateContextGroupStrategy } from \"../src/template-context.js\";\n\n// https://github.com/astahmer/openapi-zod-client/issues/157\ndescribe(\"file group strategy with multi-props object as query parameter\", async () => {\n    const openApiDoc: OpenAPIObject = {\n        openapi: \"3.0.1\",\n        info: {\n            version: \"v1\",\n            title: \"file group strategy with multi-props object as query parameter\",\n        },\n        paths: {\n            \"/api/v1/test\": {\n                post: {\n                    parameters: [\n                        {\n                            name: \"req\",\n                            in: \"query\",\n                            required: true,\n                            schema: {\n                                required: [\"prop1\", \"prop2\"],\n                                type: \"object\",\n                                properties: {\n                                    prop1: { type: \"integer\", format: \"int32\" },\n                                    prop2: { type: \"integer\", format: \"int32\" },\n                                },\n                            },\n                        },\n                    ],\n                    responses: {\n                        200: {\n                            description: \"OK\",\n                        },\n                    },\n                },\n            },\n        },\n    };\n\n    const runTest = async (groupStrategy: TemplateContextGroupStrategy): Promise<void> => {\n        const output = await generateZodClientFromOpenAPI({\n            disableWriteToFile: true,\n            openApiDoc,\n            options: { groupStrategy },\n        });\n\n        const expectedIndexValue = `export { ${groupStrategy === \"method-file\" ? \"PostApi\" : \"DefaultApi\"} } from \"./${groupStrategy === \"method-file\" ? \"post\" : \"Default\"}\";\\n`;\n\n        const expectedApiValue = `import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\nimport { z } from \"zod\";\n\nconst req = z\n  .object({ prop1: z.number().int(), prop2: z.number().int() })\n  .passthrough();\n\nexport const schemas = {\n  req,\n};\n\nconst endpoints = makeApi([\n  {\n    method: \"post\",\n    path: \"/api/v1/test\",\n    requestFormat: \"json\",\n    parameters: [\n      {\n        name: \"req\",\n        type: \"Query\",\n        schema: req,\n      },\n    ],\n    response: z.void(),\n  },\n]);\n\nexport const ${groupStrategy === \"method-file\" ? \"PostApi\" : \"DefaultApi\"} = new Zodios(endpoints);\n\nexport function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n  return new Zodios(baseUrl, endpoints, options);\n}\\n`;\n\n        const expected = {\n            __index: expectedIndexValue,\n            [groupStrategy === \"method-file\" ? \"post\" : \"Default\"]: expectedApiValue,\n        };\n\n        expect(output).toEqual(expected);\n    };\n\n    test(\"tag file\", () => runTest(\"tag-file\"));\n    test(\"method file\", () => runTest(\"method-file\"));\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/group-strategy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/handle-props-with-special-characters.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/handle-refs-with-dots-in-name.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/handle-refs-without-var-name.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/hyphenated-parameters.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/infer-as-object-when-only-properties-set.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/inline-simple-schemas.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/invalid-pattern-regex.test.ts","messages":[{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":2,"message":"Invalid operand for a '+' operation. Operands must each be a number or string, allowing a string + any of: `any`, `boolean`, `null`, `RegExp`, `undefined`. Got `CodeMeta`.","line":20,"column":12,"nodeType":"CallExpression","messageId":"invalid","endLine":20,"endColumn":44},{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":2,"message":"Invalid operand for a '+' operation. Operands must each be a number or string, allowing a string + any of: `any`, `boolean`, `null`, `RegExp`, `undefined`. Got `CodeMeta`.","line":23,"column":12,"nodeType":"CallExpression","messageId":"invalid","endLine":23,"endColumn":51},{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":2,"message":"Invalid operand for a '+' operation. Operands must each be a number or string, allowing a string + any of: `any`, `boolean`, `null`, `RegExp`, `undefined`. Got `CodeMeta`.","line":27,"column":9,"nodeType":"CallExpression","messageId":"invalid","endLine":27,"endColumn":52}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getZodSchema } from \"../src/index.js\";\nimport { expect, test } from \"vitest\";\nimport { getZodChain } from \"../src/openApiToZod.js\";\nimport { type SchemaObject } from \"openapi3-ts\";\n\ntest(\"invalid-pattern-regex\", () => {\n    const invalidSchema: SchemaObject = {\n        type: \"string\",\n        pattern: \"[0-9]+\",\n    };\n    const schema: SchemaObject = {\n        type: \"string\",\n        pattern: \"/[0-9]+/\",\n    };\n    const controlCharacters: SchemaObject = {\n        type: \"string\",\n        pattern:\n            \"/[\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\u0008\\u0009\\u000A\\u000B\\u000C\\u000D\\u000E\\u000F\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001A\\u001B\\u001C\\u001D\\u001E\\u001F\\u007F\\u0080\\u0081\\u0082\\u0083\\u0084\\u0085\\u0086\\u0087\\u0088\\u0089\\u008A\\u008B\\u008C\\u008D\\u008E\\u008F\\u0090\\u0091\\u0092\\u0093\\u0094\\u0095\\u0096\\u0097\\u0098\\u0099\\u009A\\u009B\\u009C\\u009D\\u009E\\u009F\\uFFFE\\uFFFF]+/\",\n    };\n    expect(getZodSchema({ schema: schema }) + getZodChain({ schema })).toMatchInlineSnapshot(\n        '\"z.string().regex(/[0-9]+/).optional()\"'\n    );\n    expect(getZodSchema({ schema: invalidSchema }) + getZodChain({ schema: invalidSchema })).toMatchInlineSnapshot(\n        '\"z.string().regex(/[0-9]+/).optional()\"'\n    );\n    expect(\n        getZodSchema({ schema: controlCharacters }) + getZodChain({ schema: controlCharacters })\n    ).toMatchInlineSnapshot(\n        String.raw`\"z.string().regex(/[\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\ufffe\\uffff]+/u).optional()\"`\n    );\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/is-main-response.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/is-media-type-allowed.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/jsdoc.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/kebab-case-in-props.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/main-description-as-fallback.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/min-with-max.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/missing-operationId-variables-undefined_Body.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/missing-zod-chains-on-z-object-with-refs-props.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/missing-zod-chains.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/name-starting-with-number.test.ts","messages":[{"ruleId":"sonarjs/todo-tag","severity":2,"message":"Complete the task associated to this \"TODO\" comment.","line":42,"column":8,"nodeType":null,"messageId":"completeTODO","endLine":42,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type OpenAPIObject } from \"openapi3-ts\";\nimport { expect, test } from \"vitest\";\nimport { generateZodClientFromOpenAPI, getZodClientTemplateContext } from \"../src/index.js\";\n\ntest(\"operationId-starting-with-number\", async () => {\n    const openApiDoc: OpenAPIObject = {\n        openapi: \"3.0.3\",\n        info: { version: \"1\", title: \"Example API\" },\n        paths: {\n            \"/operationId-starting-with-number\": {\n                get: {\n                    operationId: \"123_example\",\n                    responses: {\n                        \"200\": {\n                            content: { \"application/json\": { schema: { $ref: \"#/components/schemas/Basic\" } } },\n                        },\n                    },\n                },\n            },\n        },\n        components: {\n            schemas: {\n                Basic: { type: \"string\" },\n            },\n        },\n    };\n    const ctx = getZodClientTemplateContext(openApiDoc);\n    expect(ctx.endpoints).toMatchInlineSnapshot(`\n      [\n          {\n              \"description\": undefined,\n              \"errors\": [],\n              \"method\": \"get\",\n              \"parameters\": [],\n              \"path\": \"/operationId-starting-with-number\",\n              \"requestFormat\": \"json\",\n              \"response\": \"z.string()\",\n          },\n      ]\n    `);\n\n    // TODO fix\n    const result = await generateZodClientFromOpenAPI({\n        disableWriteToFile: true,\n        openApiDoc,\n        options: { withAlias: true },\n    });\n    expect(result).toMatchInlineSnapshot(`\n      \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n      import { z } from \"zod\";\n\n      const Basic = z.string();\n\n      export const schemas = {\n        Basic,\n      };\n\n      const endpoints = makeApi([\n        {\n          method: \"get\",\n          path: \"/operationId-starting-with-number\",\n          alias: \"123_example\",\n          requestFormat: \"json\",\n          response: z.string(),\n        },\n      ]);\n\n      export const api = new Zodios(endpoints);\n\n      export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n        return new Zodios(baseUrl, endpoints, options);\n      }\n      \"\n    `);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/name-with-special-characters.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/number-default-as-number.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/numerical-enum.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/object-default-values.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/openapi-spec-compliance.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/param-invalid-spec.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/param-with-content.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/recursive-schema.test.ts","messages":[{"ruleId":"sonarjs/todo-tag","severity":2,"message":"Complete the task associated to this \"TODO\" comment.","line":15,"column":4,"nodeType":null,"messageId":"completeTODO","endLine":15,"endColumn":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { SchemaObject, SchemasObject } from \"openapi3-ts\";\nimport { describe, expect, test } from \"vitest\";\nimport {\n    getOpenApiDependencyGraph,\n    getZodClientTemplateContext,\n    getZodiosEndpointDefinitionList,\n    getZodSchema,\n} from \"../src/index.js\";\nimport { generateZodClientFromOpenAPI } from \"../src/generateZodClientFromOpenAPI.js\";\nimport { topologicalSort } from \"../src/topologicalSort.js\";\nimport type { ConversionTypeContext } from \"../src/CodeMeta.js\";\nimport { makeSchemaResolver } from \"../src/makeSchemaResolver.js\";\nimport { asComponentSchema } from \"../src/utils.js\";\n\n// TODO recursive inline response/param ?\n\nconst makeOpenApiDoc = (schemas: SchemasObject, responseSchema: SchemaObject) => ({\n    openapi: \"3.0.3\",\n    info: { title: \"Swagger Petstore - OpenAPI 3.0\", version: \"1.0.11\" },\n    paths: {\n        \"/example\": {\n            get: {\n                operationId: \"getExample\",\n                responses: {\n                    \"200\": { description: \"OK\", content: { \"application/json\": { schema: responseSchema } } },\n                },\n            },\n        },\n    },\n    components: { schemas },\n});\n\ndescribe(\"recursive-schema\", () => {\n    const UserSchema = {\n        type: \"object\",\n        properties: {\n            name: { type: \"string\" },\n            parent: { $ref: \"#/components/schemas/User\" },\n        },\n    } as SchemaObject;\n\n    test(\"indirect single recursive\", async () => {\n        const schemas = {\n            User: {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    middle: { $ref: \"#/components/schemas/Middle\" },\n                },\n            },\n            Middle: {\n                type: \"object\",\n                properties: {\n                    user: { $ref: \"#/components/schemas/User\" },\n                },\n            },\n            Root: {\n                type: \"object\",\n                properties: {\n                    recursive: {\n                        $ref: \"#/components/schemas/User\",\n                    },\n                    basic: { type: \"number\" },\n                },\n            },\n        } as SchemasObject;\n        const ctx: ConversionTypeContext = {\n            zodSchemaByName: {},\n            schemaByName: {},\n            resolver: makeSchemaResolver({ components: { schemas } } as any),\n        };\n        Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n        const rootSchema = schemas[\"Root\"];\n        if (!rootSchema) throw new Error(\"Root schema not found\");\n        expect(getZodSchema({ schema: rootSchema, ctx })).toMatchInlineSnapshot(\n            '\"z.object({ recursive: User, basic: z.number() }).partial().passthrough()\"'\n        );\n        expect(ctx).toMatchInlineSnapshot(`\n          {\n              \"resolver\": {\n                  \"getSchemaByRef\": [Function],\n                  \"resolveRef\": [Function],\n                  \"resolveSchemaName\": [Function],\n              },\n              \"schemaByName\": {},\n              \"zodSchemaByName\": {\n                  \"Middle\": \"z.object({ user: User }).partial().passthrough()\",\n                  \"User\": \"z.object({ name: z.string(), middle: Middle }).partial().passthrough()\",\n              },\n          }\n        `);\n\n        const openApiDoc = makeOpenApiDoc(schemas, rootSchema);\n        const depsGraph = getOpenApiDependencyGraph(\n            Object.keys(ctx.zodSchemaByName).map((name) => asComponentSchema(name)),\n            ctx.resolver.getSchemaByRef\n        );\n        expect(depsGraph).toMatchInlineSnapshot(`\n          {\n              \"deepDependencyGraph\": {\n                  \"#/components/schemas/Middle\": Set {\n                      \"#/components/schemas/User\",\n                      \"#/components/schemas/Middle\",\n                  },\n                  \"#/components/schemas/User\": Set {\n                      \"#/components/schemas/Middle\",\n                      \"#/components/schemas/User\",\n                  },\n              },\n              \"refsDependencyGraph\": {\n                  \"#/components/schemas/Middle\": Set {\n                      \"#/components/schemas/User\",\n                  },\n                  \"#/components/schemas/User\": Set {\n                      \"#/components/schemas/Middle\",\n                  },\n              },\n          }\n        `);\n\n        expect(topologicalSort(depsGraph.refsDependencyGraph)).toMatchInlineSnapshot(`\n          [\n              \"#/components/schemas/User\",\n              \"#/components/schemas/Middle\",\n          ]\n        `);\n\n        const prettyOutput = await generateZodClientFromOpenAPI({ openApiDoc, disableWriteToFile: true });\n        expect(prettyOutput).toMatchInlineSnapshot(`\n          \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          type User = Partial<{\n            name: string;\n            middle: Middle;\n          }>;\n          type Middle = Partial<{\n            user: User;\n          }>;\n\n          const Middle: z.ZodType<Middle> = z.lazy(() =>\n            z.object({ user: User }).partial().passthrough(),\n          );\n          const User: z.ZodType<User> = z.lazy(() =>\n            z.object({ name: z.string(), middle: Middle }).partial().passthrough(),\n          );\n\n          export const schemas = {\n            Middle,\n            User,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"get\",\n              path: \"/example\",\n              requestFormat: \"json\",\n              response: z\n                .object({ recursive: User, basic: z.number() })\n                .partial()\n                .passthrough(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \"\n        `);\n    });\n\n    const ObjectWithRecursiveArray = {\n        type: \"object\",\n        properties: {\n            isInsideObjectWithRecursiveArray: { type: \"boolean\" },\n            array: {\n                type: \"array\",\n                items: {\n                    $ref: \"#/components/schemas/ObjectWithRecursiveArray\",\n                },\n            },\n        },\n    } as SchemaObject;\n    const schemas2 = { ObjectWithRecursiveArray };\n    const ResponseSchema = {\n        type: \"object\",\n        properties: {\n            recursiveRef: {\n                $ref: \"#/components/schemas/ObjectWithRecursiveArray\",\n            },\n            basic: { type: \"number\" },\n        },\n    } as SchemaObject;\n\n    test(\"recursive array\", () => {\n        const ctx: ConversionTypeContext = {\n            zodSchemaByName: {},\n            schemaByName: {},\n            resolver: makeSchemaResolver({ components: { schemas } } as any),\n        };\n        Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n        expect(getZodSchema({ schema: ResponseSchema, ctx })).toMatchInlineSnapshot(\n            '\"z.object({ recursiveRef: ObjectWithRecursiveArray, basic: z.number() }).partial().passthrough()\"'\n        );\n        expect(ctx).toMatchInlineSnapshot(`\n          {\n              \"resolver\": {\n                  \"getSchemaByRef\": [Function],\n                  \"resolveRef\": [Function],\n                  \"resolveSchemaName\": [Function],\n              },\n              \"schemaByName\": {},\n              \"zodSchemaByName\": {\n                  \"ObjectWithRecursiveArray\": \"z.object({ isInsideObjectWithRecursiveArray: z.boolean(), array: z.array(ObjectWithRecursiveArray) }).partial().passthrough()\",\n              },\n          }\n        `);\n\n        expect(getZodiosEndpointDefinitionList(makeOpenApiDoc(schemas2, ResponseSchema))).toMatchInlineSnapshot(`\n          {\n              \"deepDependencyGraph\": {\n                  \"#/components/schemas/ObjectWithRecursiveArray\": Set {\n                      \"#/components/schemas/ObjectWithRecursiveArray\",\n                  },\n              },\n              \"endpoints\": [\n                  {\n                      \"description\": undefined,\n                      \"errors\": [],\n                      \"method\": \"get\",\n                      \"parameters\": [],\n                      \"path\": \"/example\",\n                      \"requestFormat\": \"json\",\n                      \"response\": \"z.object({ recursiveRef: ObjectWithRecursiveArray, basic: z.number() }).partial().passthrough()\",\n                  },\n              ],\n              \"issues\": {\n                  \"ignoredFallbackResponse\": [],\n                  \"ignoredGenericError\": [],\n              },\n              \"refsDependencyGraph\": {\n                  \"#/components/schemas/ObjectWithRecursiveArray\": Set {\n                      \"#/components/schemas/ObjectWithRecursiveArray\",\n                  },\n              },\n              \"resolver\": {\n                  \"getSchemaByRef\": [Function],\n                  \"resolveRef\": [Function],\n                  \"resolveSchemaName\": [Function],\n              },\n              \"schemaByName\": {},\n              \"zodSchemaByName\": {\n                  \"ObjectWithRecursiveArray\": \"z.object({ isInsideObjectWithRecursiveArray: z.boolean(), array: z.array(ObjectWithRecursiveArray) }).partial().passthrough()\",\n              },\n          }\n        `);\n    });\n\n    test(\"direct recursive\", () => {\n        const ctx: ConversionTypeContext = {\n            zodSchemaByName: {},\n            schemaByName: {},\n            resolver: makeSchemaResolver({ components: { schemas } } as any),\n        };\n        Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n        expect(getZodSchema({ schema: UserSchema, ctx })).toMatchInlineSnapshot(\n            '\"z.object({ name: z.string(), parent: User }).partial().passthrough()\"'\n        );\n        expect(ctx).toMatchInlineSnapshot(`\n          {\n              \"resolver\": {\n                  \"getSchemaByRef\": [Function],\n                  \"resolveRef\": [Function],\n                  \"resolveSchemaName\": [Function],\n              },\n              \"schemaByName\": {},\n              \"zodSchemaByName\": {\n                  \"User\": \"z.object({ name: z.string(), parent: User }).partial().passthrough()\",\n              },\n          }\n        `);\n    });\n\n    const UserWithFriends = {\n        type: \"object\",\n        properties: {\n            name: { type: \"string\" },\n            parent: { $ref: \"#/components/schemas/UserWithFriends\" },\n            friends: { type: \"array\", items: { $ref: \"#/components/schemas/Friend\" } },\n            bestFriend: { $ref: \"#/components/schemas/Friend\" },\n        },\n    } as SchemaObject;\n\n    const Friend = {\n        type: \"object\",\n        properties: {\n            nickname: { type: \"string\" },\n            user: { $ref: \"#/components/schemas/UserWithFriends\" },\n            circle: { type: \"array\", items: { $ref: \"#/components/schemas/Friend\" } },\n        },\n    } as SchemaObject;\n    const schemas = { User: UserSchema, UserWithFriends, Friend, ResponseSchema, ObjectWithRecursiveArray };\n\n    test(\"multiple recursive in one root schema\", async () => {\n        const ctx: ConversionTypeContext = {\n            zodSchemaByName: {},\n            schemaByName: {},\n            resolver: makeSchemaResolver({ components: { schemas } } as any),\n        };\n        Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n        expect(\n            getZodSchema({\n                schema: {\n                    type: \"object\",\n                    properties: {\n                        recursiveUser: {\n                            $ref: \"#/components/schemas/UserWithFriends\",\n                        },\n                        basic: { type: \"number\" },\n                    },\n                },\n                ctx,\n            })\n        ).toMatchInlineSnapshot(\n            '\"z.object({ recursiveUser: UserWithFriends, basic: z.number() }).partial().passthrough()\"'\n        );\n        expect(ctx).toMatchInlineSnapshot(`\n          {\n              \"resolver\": {\n                  \"getSchemaByRef\": [Function],\n                  \"resolveRef\": [Function],\n                  \"resolveSchemaName\": [Function],\n              },\n              \"schemaByName\": {},\n              \"zodSchemaByName\": {\n                  \"Friend\": \"z.object({ nickname: z.string(), user: UserWithFriends, circle: z.array(Friend) }).partial().passthrough()\",\n                  \"UserWithFriends\": \"z.object({ name: z.string(), parent: UserWithFriends, friends: z.array(Friend), bestFriend: Friend }).partial().passthrough()\",\n              },\n          }\n        `);\n\n        const openApiDoc = makeOpenApiDoc(schemas, {\n            type: \"object\",\n            properties: {\n                someUser: {\n                    $ref: \"#/components/schemas/UserWithFriends\",\n                },\n                someProp: { type: \"boolean\" },\n            },\n        });\n\n        expect(getZodiosEndpointDefinitionList(openApiDoc)).toMatchInlineSnapshot(`\n          {\n              \"deepDependencyGraph\": {\n                  \"#/components/schemas/Friend\": Set {\n                      \"#/components/schemas/UserWithFriends\",\n                      \"#/components/schemas/Friend\",\n                  },\n                  \"#/components/schemas/ObjectWithRecursiveArray\": Set {\n                      \"#/components/schemas/ObjectWithRecursiveArray\",\n                  },\n                  \"#/components/schemas/ResponseSchema\": Set {\n                      \"#/components/schemas/ObjectWithRecursiveArray\",\n                  },\n                  \"#/components/schemas/User\": Set {\n                      \"#/components/schemas/User\",\n                  },\n                  \"#/components/schemas/UserWithFriends\": Set {\n                      \"#/components/schemas/UserWithFriends\",\n                      \"#/components/schemas/Friend\",\n                  },\n              },\n              \"endpoints\": [\n                  {\n                      \"description\": undefined,\n                      \"errors\": [],\n                      \"method\": \"get\",\n                      \"parameters\": [],\n                      \"path\": \"/example\",\n                      \"requestFormat\": \"json\",\n                      \"response\": \"z.object({ someUser: UserWithFriends, someProp: z.boolean() }).partial().passthrough()\",\n                  },\n              ],\n              \"issues\": {\n                  \"ignoredFallbackResponse\": [],\n                  \"ignoredGenericError\": [],\n              },\n              \"refsDependencyGraph\": {\n                  \"#/components/schemas/Friend\": Set {\n                      \"#/components/schemas/UserWithFriends\",\n                      \"#/components/schemas/Friend\",\n                  },\n                  \"#/components/schemas/ObjectWithRecursiveArray\": Set {\n                      \"#/components/schemas/ObjectWithRecursiveArray\",\n                  },\n                  \"#/components/schemas/ResponseSchema\": Set {\n                      \"#/components/schemas/ObjectWithRecursiveArray\",\n                  },\n                  \"#/components/schemas/User\": Set {\n                      \"#/components/schemas/User\",\n                  },\n                  \"#/components/schemas/UserWithFriends\": Set {\n                      \"#/components/schemas/UserWithFriends\",\n                      \"#/components/schemas/Friend\",\n                  },\n              },\n              \"resolver\": {\n                  \"getSchemaByRef\": [Function],\n                  \"resolveRef\": [Function],\n                  \"resolveSchemaName\": [Function],\n              },\n              \"schemaByName\": {},\n              \"zodSchemaByName\": {\n                  \"Friend\": \"z.object({ nickname: z.string(), user: UserWithFriends, circle: z.array(Friend) }).partial().passthrough()\",\n                  \"UserWithFriends\": \"z.object({ name: z.string(), parent: UserWithFriends, friends: z.array(Friend), bestFriend: Friend }).partial().passthrough()\",\n              },\n          }\n        `);\n\n        const templateCtx = getZodClientTemplateContext(openApiDoc);\n        expect(templateCtx).toMatchInlineSnapshot(`\n          {\n              \"circularTypeByName\": {\n                  \"Friend\": true,\n                  \"UserWithFriends\": true,\n              },\n              \"emittedType\": {\n                  \"Friend\": true,\n                  \"ObjectWithRecursiveArray\": true,\n                  \"User\": true,\n                  \"UserWithFriends\": true,\n              },\n              \"endpoints\": [\n                  {\n                      \"description\": undefined,\n                      \"errors\": [],\n                      \"method\": \"get\",\n                      \"parameters\": [],\n                      \"path\": \"/example\",\n                      \"requestFormat\": \"json\",\n                      \"response\": \"z.object({ someUser: UserWithFriends, someProp: z.boolean() }).partial().passthrough()\",\n                  },\n              ],\n              \"endpointsGroups\": {},\n              \"options\": {\n                  \"baseUrl\": \"\",\n                  \"withAlias\": false,\n              },\n              \"schemas\": {\n                  \"Friend\": \"z.lazy(() => z.object({ nickname: z.string(), user: UserWithFriends, circle: z.array(Friend) }).partial().passthrough())\",\n                  \"UserWithFriends\": \"z.lazy(() => z.object({ name: z.string(), parent: UserWithFriends, friends: z.array(Friend), bestFriend: Friend }).partial().passthrough())\",\n              },\n              \"types\": {\n                  \"Friend\": \"type Friend = Partial<{\n              nickname: string;\n              user: UserWithFriends;\n              circle: Array<Friend>;\n          }>;\",\n                  \"ObjectWithRecursiveArray\": \"type ObjectWithRecursiveArray = Partial<{\n              isInsideObjectWithRecursiveArray: boolean;\n              array: Array<ObjectWithRecursiveArray>;\n          }>;\",\n                  \"User\": \"type User = Partial<{\n              name: string;\n              parent: User;\n          }>;\",\n                  \"UserWithFriends\": \"type UserWithFriends = Partial<{\n              name: string;\n              parent: UserWithFriends;\n              friends: Array<Friend>;\n              bestFriend: Friend;\n          }>;\",\n              },\n          }\n        `);\n\n        const prettyOutput = await generateZodClientFromOpenAPI({ openApiDoc, disableWriteToFile: true });\n        expect(prettyOutput).toMatchInlineSnapshot(`\n          \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          type User = Partial<{\n            name: string;\n            parent: User;\n          }>;\n          type UserWithFriends = Partial<{\n            name: string;\n            parent: UserWithFriends;\n            friends: Array<Friend>;\n            bestFriend: Friend;\n          }>;\n          type Friend = Partial<{\n            nickname: string;\n            user: UserWithFriends;\n            circle: Array<Friend>;\n          }>;\n          type ObjectWithRecursiveArray = Partial<{\n            isInsideObjectWithRecursiveArray: boolean;\n            array: Array<ObjectWithRecursiveArray>;\n          }>;\n\n          const Friend: z.ZodType<Friend> = z.lazy(() =>\n            z\n              .object({\n                nickname: z.string(),\n                user: UserWithFriends,\n                circle: z.array(Friend),\n              })\n              .partial()\n              .passthrough(),\n          );\n          const UserWithFriends: z.ZodType<UserWithFriends> = z.lazy(() =>\n            z\n              .object({\n                name: z.string(),\n                parent: UserWithFriends,\n                friends: z.array(Friend),\n                bestFriend: Friend,\n              })\n              .partial()\n              .passthrough(),\n          );\n\n          export const schemas = {\n            Friend,\n            UserWithFriends,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"get\",\n              path: \"/example\",\n              requestFormat: \"json\",\n              response: z\n                .object({ someUser: UserWithFriends, someProp: z.boolean() })\n                .partial()\n                .passthrough(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \"\n        `);\n    });\n\n    test(\"recursive schema with $ref to another simple schema should still generate and output that simple schema and its dependencies\", async () => {\n        const Playlist = {\n            type: \"object\",\n            properties: {\n                name: { type: \"string\" },\n                author: { $ref: \"#/components/schemas/Author\" },\n                songs: { type: \"array\", items: { $ref: \"#/components/schemas/Song\" } },\n            },\n        } as SchemaObject;\n\n        const Song = {\n            type: \"object\",\n            properties: {\n                name: { type: \"string\" },\n                duration: { type: \"number\" },\n                in_playlists: { type: \"array\", items: { $ref: \"#/components/schemas/Playlist\" } },\n            },\n        } as SchemaObject;\n\n        const Author = {\n            type: \"object\",\n            properties: {\n                name: { type: \"string\" },\n                mail: { type: \"string\" },\n                settings: { $ref: \"#/components/schemas/Settings\" },\n            },\n        } as SchemaObject;\n        const Settings = {\n            type: \"object\",\n            properties: {\n                theme_color: { type: \"string\" },\n            },\n        } as SchemaObject;\n        const schemas = { Playlist, Song, Author, Settings };\n\n        const ctx: ConversionTypeContext = {\n            zodSchemaByName: {},\n            schemaByName: {},\n            resolver: makeSchemaResolver({ components: { schemas } } as any),\n        };\n        Object.keys(schemas).forEach((key) => ctx.resolver.getSchemaByRef(asComponentSchema(key)));\n\n        const RootSchema = {\n            type: \"object\",\n            properties: {\n                playlist: { $ref: \"#/components/schemas/Playlist\" },\n                by_author: { $ref: \"#/components/schemas/Author\" },\n            },\n        } as SchemaObject;\n        expect(getZodSchema({ schema: RootSchema, ctx })).toMatchInlineSnapshot(\n            '\"z.object({ playlist: Playlist, by_author: Author }).partial().passthrough()\"'\n        );\n        expect(ctx).toMatchInlineSnapshot(`\n          {\n              \"resolver\": {\n                  \"getSchemaByRef\": [Function],\n                  \"resolveRef\": [Function],\n                  \"resolveSchemaName\": [Function],\n              },\n              \"schemaByName\": {},\n              \"zodSchemaByName\": {\n                  \"Author\": \"z.object({ name: z.string(), mail: z.string(), settings: Settings }).partial().passthrough()\",\n                  \"Playlist\": \"z.object({ name: z.string(), author: Author, songs: z.array(Song) }).partial().passthrough()\",\n                  \"Settings\": \"z.object({ theme_color: z.string() }).partial().passthrough()\",\n                  \"Song\": \"z.object({ name: z.string(), duration: z.number(), in_playlists: z.array(Playlist) }).partial().passthrough()\",\n              },\n          }\n        `);\n\n        const openApiDoc = makeOpenApiDoc(schemas, RootSchema);\n        const prettyOutput = await generateZodClientFromOpenAPI({ openApiDoc, disableWriteToFile: true });\n        expect(prettyOutput).toMatchInlineSnapshot(`\n          \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          type Playlist = Partial<{\n            name: string;\n            author: Author;\n            songs: Array<Song>;\n          }>;\n          type Author = Partial<{\n            name: string;\n            mail: string;\n            settings: Settings;\n          }>;\n          type Settings = Partial<{\n            theme_color: string;\n          }>;\n          type Song = Partial<{\n            name: string;\n            duration: number;\n            in_playlists: Array<Playlist>;\n          }>;\n\n          const Settings = z.object({ theme_color: z.string() }).partial().passthrough();\n          const Author = z\n            .object({ name: z.string(), mail: z.string(), settings: Settings })\n            .partial()\n            .passthrough();\n          const Song: z.ZodType<Song> = z.lazy(() =>\n            z\n              .object({\n                name: z.string(),\n                duration: z.number(),\n                in_playlists: z.array(Playlist),\n              })\n              .partial()\n              .passthrough(),\n          );\n          const Playlist: z.ZodType<Playlist> = z.lazy(() =>\n            z\n              .object({ name: z.string(), author: Author, songs: z.array(Song) })\n              .partial()\n              .passthrough(),\n          );\n\n          export const schemas = {\n            Settings,\n            Author,\n            Song,\n            Playlist,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"get\",\n              path: \"/example\",\n              requestFormat: \"json\",\n              response: z\n                .object({ playlist: Playlist, by_author: Author })\n                .partial()\n                .passthrough(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \"\n        `);\n    });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/ref-in-another-file.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/refine-default-endpoint-callback.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/regex-with-escapes.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/regex-with-unnecessary-escape.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/request-body-ref.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/required-additional-props-not-in-properties.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/resolve-ref-responses.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/same-schema-different-name.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/samples.test.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":21,"column":40,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":21,"endColumn":42,"suggestions":[{"messageId":"removeAsync","fix":{"range":[712,718],"text":""},"desc":"Remove 'async'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import SwaggerParser from \"@apidevtools/swagger-parser\";\nimport type { OpenAPIObject } from \"openapi3-ts\";\nimport { type Options, resolveConfig } from \"prettier\";\nimport { getZodClientTemplateContext } from \"../src/template-context.js\";\nimport { getHandlebars } from \"../src/getHandlebars.js\";\nimport { maybePretty } from \"../src/maybePretty.js\";\n\nimport fg from \"fast-glob\";\n\nimport { readFileSync } from \"node:fs\";\nimport * as path from \"node:path\";\nimport { beforeAll, describe, expect, test } from \"vitest\";\n\nlet prettierConfig: Options | null;\nconst pkgRoot = process.cwd();\n\nbeforeAll(async () => {\n    prettierConfig = await resolveConfig(path.resolve(pkgRoot, \"../\"));\n});\n\ndescribe(\"samples-generator\", async () => {\n    const samplesPath = path.resolve(pkgRoot, \"../\", String.raw`./samples/v3\\.*/**/*.yaml`);\n    const list = fg.sync([samplesPath]);\n\n    const template = getHandlebars().compile(readFileSync(\"./src/templates/default.hbs\", \"utf8\"));\n    const resultByFile = {} as Record<string, string>;\n\n    for (const docPath of list) {\n        test(docPath, async () => {\n            const openApiDoc = (await SwaggerParser.parse(docPath)) as OpenAPIObject;\n            const data = getZodClientTemplateContext(openApiDoc);\n\n            const output = template({ ...data, options: { ...data.options, apiClientName: \"api\" } });\n            const prettyOutput = await maybePretty(output, prettierConfig);\n            const fileName = docPath.replace(\"yaml\", \"\");\n\n            // means the .ts file is valid\n            expect(prettyOutput).not.toBe(output);\n            resultByFile[fileName] = prettyOutput;\n        });\n    }\n\n    test(\"results by file\", () => {\n        expect(\n            Object.fromEntries(Object.entries(resultByFile).map(([key, value]) => [key.split(\"samples/\").at(1), value]))\n        ).toMatchInlineSnapshot(`\n          {\n              \"v3.0/api-with-examples.\": \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const endpoints = makeApi([\n            {\n              method: \"get\",\n              path: \"/\",\n              requestFormat: \"json\",\n              response: z.void(),\n            },\n            {\n              method: \"get\",\n              path: \"/v2\",\n              requestFormat: \"json\",\n              response: z.void(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \",\n              \"v3.0/callback-example.\": \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const endpoints = makeApi([\n            {\n              method: \"post\",\n              path: \"/streams\",\n              description: \\`subscribes a client to receive out-of-band data\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"callbackUrl\",\n                  type: \"Query\",\n                  schema: z.string().url(),\n                },\n              ],\n              response: z.object({ subscriptionId: z.string() }).passthrough(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \",\n              \"v3.0/link-example.\": \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const user = z\n            .object({ username: z.string(), uuid: z.string() })\n            .partial()\n            .passthrough();\n          const repository = z\n            .object({ slug: z.string(), owner: user })\n            .partial()\n            .passthrough();\n          const pullrequest = z\n            .object({\n              id: z.number().int(),\n              title: z.string(),\n              repository: repository,\n              author: user,\n            })\n            .partial()\n            .passthrough();\n\n          export const schemas = {\n            user,\n            repository,\n            pullrequest,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"get\",\n              path: \"/2.0/repositories/:username\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.array(repository),\n            },\n            {\n              method: \"get\",\n              path: \"/2.0/repositories/:username/:slug\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n                {\n                  name: \"slug\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: repository,\n            },\n            {\n              method: \"get\",\n              path: \"/2.0/repositories/:username/:slug/pullrequests\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n                {\n                  name: \"slug\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n                {\n                  name: \"state\",\n                  type: \"Query\",\n                  schema: z.enum([\"open\", \"merged\", \"declined\"]).optional(),\n                },\n              ],\n              response: z.array(pullrequest),\n            },\n            {\n              method: \"get\",\n              path: \"/2.0/repositories/:username/:slug/pullrequests/:pid\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n                {\n                  name: \"slug\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n                {\n                  name: \"pid\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: pullrequest,\n            },\n            {\n              method: \"post\",\n              path: \"/2.0/repositories/:username/:slug/pullrequests/:pid/merge\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n                {\n                  name: \"slug\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n                {\n                  name: \"pid\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.void(),\n            },\n            {\n              method: \"get\",\n              path: \"/2.0/users/:username\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"username\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: user,\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \",\n              \"v3.0/petstore-expanded.\": \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const NewPet = z\n            .object({ name: z.string(), tag: z.string().optional() })\n            .passthrough();\n          const Pet = NewPet.and(z.object({ id: z.number().int() }).passthrough());\n          const Error = z\n            .object({ code: z.number().int(), message: z.string() })\n            .passthrough();\n\n          export const schemas = {\n            NewPet,\n            Pet,\n            Error,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"get\",\n              path: \"/pets\",\n              description: \\`Returns all pets from the system that the user has access to\n          Nam sed condimentum est. Maecenas tempor sagittis sapien, nec rhoncus sem sagittis sit amet. Aenean at gravida augue, ac iaculis sem. Curabitur odio lorem, ornare eget elementum nec, cursus id lectus. Duis mi turpis, pulvinar ac eros ac, tincidunt varius justo. In hac habitasse platea dictumst. Integer at adipiscing ante, a sagittis ligula. Aenean pharetra tempor ante molestie imperdiet. Vivamus id aliquam diam. Cras quis velit non tortor eleifend sagittis. Praesent at enim pharetra urna volutpat venenatis eget eget mauris. In eleifend fermentum facilisis. Praesent enim enim, gravida ac sodales sed, placerat id erat. Suspendisse lacus dolor, consectetur non augue vel, vehicula interdum libero. Morbi euismod sagittis libero sed lacinia.\n\n          Sed tempus felis lobortis leo pulvinar rutrum. Nam mattis velit nisl, eu condimentum ligula luctus nec. Phasellus semper velit eget aliquet faucibus. In a mattis elit. Phasellus vel urna viverra, condimentum lorem id, rhoncus nibh. Ut pellentesque posuere elementum. Sed a varius odio. Morbi rhoncus ligula libero, vel eleifend nunc tristique vitae. Fusce et sem dui. Aenean nec scelerisque tortor. Fusce malesuada accumsan magna vel tempus. Quisque mollis felis eu dolor tristique, sit amet auctor felis gravida. Sed libero lorem, molestie sed nisl in, accumsan tempor nisi. Fusce sollicitudin massa ut lacinia mattis. Sed vel eleifend lorem. Pellentesque vitae felis pretium, pulvinar elit eu, euismod sapien.\n          \\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"tags\",\n                  type: \"Query\",\n                  schema: z.array(z.string()).optional(),\n                },\n                {\n                  name: \"limit\",\n                  type: \"Query\",\n                  schema: z.number().int().optional(),\n                },\n              ],\n              response: z.array(Pet),\n            },\n            {\n              method: \"post\",\n              path: \"/pets\",\n              description: \\`Creates a new pet in the store. Duplicates are allowed\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"body\",\n                  description: \\`Pet to add to the store\\`,\n                  type: \"Body\",\n                  schema: NewPet,\n                },\n              ],\n              response: Pet,\n            },\n            {\n              method: \"get\",\n              path: \"/pets/:id\",\n              description: \\`Returns a user based on a single ID, if the user does not have access to the pet\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"id\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: Pet,\n            },\n            {\n              method: \"delete\",\n              path: \"/pets/:id\",\n              description: \\`deletes a single pet based on the ID supplied\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"id\",\n                  type: \"Path\",\n                  schema: z.number().int(),\n                },\n              ],\n              response: z.void(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \",\n              \"v3.0/petstore.\": \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const Pet = z\n            .object({\n              id: z.number().int(),\n              name: z.string(),\n              tag: z.string().optional(),\n            })\n            .passthrough();\n          const Pets = z.array(Pet);\n          const Error = z\n            .object({ code: z.number().int(), message: z.string() })\n            .passthrough();\n\n          export const schemas = {\n            Pet,\n            Pets,\n            Error,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"get\",\n              path: \"/pets\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"limit\",\n                  type: \"Query\",\n                  schema: z.number().int().optional(),\n                },\n              ],\n              response: z.array(Pet),\n            },\n            {\n              method: \"post\",\n              path: \"/pets\",\n              requestFormat: \"json\",\n              response: z.void(),\n            },\n            {\n              method: \"get\",\n              path: \"/pets/:petId\",\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"petId\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: Pet,\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \",\n              \"v3.0/uspto.\": \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const dataSetList = z\n            .object({\n              total: z.number().int(),\n              apis: z.array(\n                z\n                  .object({\n                    apiKey: z.string(),\n                    apiVersionNumber: z.string(),\n                    apiUrl: z.string(),\n                    apiDocumentationUrl: z.string(),\n                  })\n                  .partial()\n                  .passthrough(),\n              ),\n            })\n            .partial()\n            .passthrough();\n          const perform_search_Body = z\n            .object({\n              criteria: z.string().default(\"*:*\"),\n              start: z.number().int().optional().default(0),\n              rows: z.number().int().optional().default(100),\n            })\n            .passthrough();\n\n          export const schemas = {\n            dataSetList,\n            perform_search_Body,\n          };\n\n          const endpoints = makeApi([\n            {\n              method: \"get\",\n              path: \"/\",\n              requestFormat: \"json\",\n              response: dataSetList,\n            },\n            {\n              method: \"get\",\n              path: \"/:dataset/:version/fields\",\n              description: \\`This GET API returns the list of all the searchable field names that are in the oa_citations. Please see the &#x27;fields&#x27; attribute which returns an array of field names. Each field or a combination of fields can be searched using the syntax options shown below.\\`,\n              requestFormat: \"json\",\n              parameters: [\n                {\n                  name: \"dataset\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n                {\n                  name: \"version\",\n                  type: \"Path\",\n                  schema: z.string(),\n                },\n              ],\n              response: z.string(),\n              errors: [\n                {\n                  status: 404,\n                  description: \\`The combination of dataset name and version is not found in the system or it is not published yet to be consumed by public.\\`,\n                  schema: z.string(),\n                },\n              ],\n            },\n            {\n              method: \"post\",\n              path: \"/:dataset/:version/records\",\n              description: \\`This API is based on Solr/Lucene Search. The data is indexed using SOLR. This GET API returns the list of all the searchable field names that are in the Solr Index. Please see the &#x27;fields&#x27; attribute which returns an array of field names. Each field or a combination of fields can be searched using the Solr/Lucene Syntax. Please refer https://lucene.apache.org/core/3_6_2/queryparsersyntax.html#Overview for the query syntax. List of field names that are searchable can be determined using above GET api.\\`,\n              requestFormat: \"form-url\",\n              parameters: [\n                {\n                  name: \"body\",\n                  type: \"Body\",\n                  schema: perform_search_Body,\n                },\n                {\n                  name: \"version\",\n                  type: \"Path\",\n                  schema: z.string().default(\"v1\"),\n                },\n                {\n                  name: \"dataset\",\n                  type: \"Path\",\n                  schema: z.string().default(\"oa_citations\"),\n                },\n              ],\n              response: z.array(z.record(z.object({}).partial().passthrough())),\n              errors: [\n                {\n                  status: 404,\n                  description: \\`No matching record found for the given criteria.\\`,\n                  schema: z.void(),\n                },\n              ],\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \",\n              \"v3.1/non-oauth-scopes.\": \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const endpoints = makeApi([\n            {\n              method: \"get\",\n              path: \"/users\",\n              requestFormat: \"json\",\n              response: z.void(),\n            },\n          ]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \",\n              \"v3.1/webhook-example.\": \"import { makeApi, Zodios, type ZodiosOptions } from \"@zodios/core\";\n          import { z } from \"zod\";\n\n          const endpoints = makeApi([]);\n\n          export const api = new Zodios(endpoints);\n\n          export function createApiClient(baseUrl: string, options?: ZodiosOptions) {\n            return new Zodios(baseUrl, endpoints, options);\n          }\n          \",\n          }\n        `);\n    });\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/schema-name-already-used.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/schema-refiner.test.ts","messages":[{"ruleId":"sonarjs/no-invariant-returns","severity":2,"message":"Refactor this function to not always return the same value.","line":19,"column":17,"nodeType":null,"endLine":19,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isReferenceObject } from \"openapi3-ts\";\nimport { getZodSchema } from \"../src/openApiToZod.js\";\nimport { test, expect } from \"vitest\";\n\ntest(\"schema-refiner\", () => {\n    expect(\n        getZodSchema({\n            schema: {\n                properties: {\n                    name: {\n                        type: \"string\",\n                    },\n                    email: {\n                        type: \"string\",\n                    },\n                },\n            },\n            options: {\n                schemaRefiner(schema) {\n                    if (isReferenceObject(schema) || !schema.properties) {\n                        return schema;\n                    }\n\n                    if (!schema.required && schema.properties) {\n                        for (const key in schema.properties) {\n                            const prop = schema.properties[key];\n\n                            if (prop && !isReferenceObject(prop)) {\n                                prop.nullable = true;\n                            }\n                        }\n                    }\n\n                    return schema;\n                },\n            },\n        })\n    ).toMatchInlineSnapshot(\n        '\"z.object({ name: z.string().nullable(), email: z.string().nullable() }).partial().passthrough()\"'\n    );\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/schema-type-list-3.1.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/schema-type-wrong-case.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/spec-compliance.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/strictObjects-option.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/unicode-pattern-regex.test.ts","messages":[{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":2,"message":"Invalid operand for a '+' operation. Operands must each be a number or string, allowing a string + any of: `any`, `boolean`, `null`, `RegExp`, `undefined`. Got `CodeMeta`.","line":23,"column":12,"nodeType":"CallExpression","messageId":"invalid","endLine":23,"endColumn":44},{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":2,"message":"Invalid operand for a '+' operation. Operands must each be a number or string, allowing a string + any of: `any`, `boolean`, `null`, `RegExp`, `undefined`. Got `CodeMeta`.","line":27,"column":9,"nodeType":"CallExpression","messageId":"invalid","endLine":27,"endColumn":52},{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":2,"message":"Invalid operand for a '+' operation. Operands must each be a number or string, allowing a string + any of: `any`, `boolean`, `null`, `RegExp`, `undefined`. Got `CodeMeta`.","line":30,"column":9,"nodeType":"CallExpression","messageId":"invalid","endLine":30,"endColumn":66},{"ruleId":"@typescript-eslint/restrict-plus-operands","severity":2,"message":"Invalid operand for a '+' operation. Operands must each be a number or string, allowing a string + any of: `any`, `boolean`, `null`, `RegExp`, `undefined`. Got `CodeMeta`.","line":34,"column":9,"nodeType":"CallExpression","messageId":"invalid","endLine":34,"endColumn":51}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getZodSchema } from \"../src/index.js\";\nimport { expect, test } from \"vitest\";\nimport { getZodChain } from \"../src/openApiToZod.js\";\nimport { type SchemaObject } from \"openapi3-ts\";\n\ntest(\"unicode-pattern-regex\", () => {\n    const schema: SchemaObject = {\n        type: \"string\",\n        pattern: String.raw`\\p{L}+`,\n    };\n    const schemaWithSlashes: SchemaObject = {\n        type: \"string\",\n        pattern: String.raw`/\\p{L}+/`,\n    };\n    const schemaWithComplexUnicodePattern: SchemaObject = {\n        type: \"string\",\n        pattern: String.raw`$|^[\\p{L}\\d]+[\\p{L}\\d\\s.&()\\*'',-;#]*|$`,\n    };\n    const schemaWithSlashU: SchemaObject = {\n        type: \"string\",\n        pattern: String.raw`\\u{1F600}+`,\n    };\n    expect(getZodSchema({ schema: schema }) + getZodChain({ schema })).toMatchInlineSnapshot(\n        String.raw`\"z.string().regex(/\\p{L}+/u).optional()\"`\n    );\n    expect(\n        getZodSchema({ schema: schemaWithSlashes }) + getZodChain({ schema: schemaWithSlashes })\n    ).toMatchInlineSnapshot(String.raw`\"z.string().regex(/\\p{L}+/u).optional()\"`);\n    expect(\n        getZodSchema({ schema: schemaWithComplexUnicodePattern }) +\n            getZodChain({ schema: schemaWithComplexUnicodePattern })\n    ).toMatchInlineSnapshot(String.raw`\"z.string().regex(/$|^[\\p{L}\\d]+[\\p{L}\\d\\s.&()\\*'',-;#]*|$/u).optional()\"`);\n    expect(\n        getZodSchema({ schema: schemaWithSlashU }) + getZodChain({ schema: schemaWithSlashU })\n    ).toMatchInlineSnapshot(String.raw`\"z.string().regex(/\\u{1F600}+/u).optional()\"`);\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/use-union-only-when-multiple-choices.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/validations.test.ts","messages":[{"ruleId":"sonarjs/todo-tag","severity":2,"message":"Complete the task associated to this \"TODO\" comment.","line":40,"column":24,"nodeType":null,"messageId":"completeTODO","endLine":40,"endColumn":28},{"ruleId":"sonarjs/todo-tag","severity":2,"message":"Complete the task associated to this \"TODO\" comment.","line":45,"column":24,"nodeType":null,"messageId":"completeTODO","endLine":45,"endColumn":28}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getZodSchema } from \"../src/openApiToZod.js\";\nimport { test, expect } from \"vitest\";\n\ntest(\"validations\", () => {\n    expect(\n        getZodSchema({\n            schema: {\n                type: \"object\",\n                properties: {\n                    str: { type: \"string\" },\n                    strWithLength: { type: \"string\", minLength: 3, maxLength: 3 },\n                    strWithMin: { type: \"string\", minLength: 3 },\n                    strWithMax: { type: \"string\", maxLength: 3 },\n                    strWithPattern: { type: \"string\", pattern: \"/^[a-z]+$/\" },\n                    strWithPatternWithSlash: { type: \"string\", pattern: \"/abc/def/ghi/\" },\n                    email: { type: \"string\", format: \"email\" },\n                    hostname: { type: \"string\", format: \"hostname\" },\n                    url: { type: \"string\", format: \"uri\" },\n                    uuid: { type: \"string\", format: \"uuid\" },\n                    //\n                    number: { type: \"number\" },\n                    int: { type: \"integer\" },\n                    intWithMin: { type: \"integer\", minimum: 3 },\n                    intWithMax: { type: \"integer\", maximum: 3 },\n                    intWithMinAndMax: { type: \"integer\", minimum: 3, maximum: 3 },\n                    intWithExclusiveMinTrue: { type: \"integer\", minimum: 3, exclusiveMinimum: true },\n                    intWithExclusiveMinFalse: { type: \"integer\", minimum: 3, exclusiveMinimum: false },\n                    intWithExclusiveMin: { type: \"integer\", exclusiveMinimum: 3 },\n                    intWithExclusiveMaxTrue: { type: \"integer\", maximum: 3, exclusiveMaximum: true },\n                    intWithExclusiveMaxFalse: { type: \"integer\", maximum: 3, exclusiveMaximum: false },\n                    intWithExclusiveMax: { type: \"integer\", exclusiveMaximum: 3 },\n                    intWithMultipleOf: { type: \"integer\", multipleOf: 3 },\n                    //\n                    bool: { type: \"boolean\" },\n                    //\n                    array: { type: \"array\", items: { type: \"string\" } },\n                    arrayWithMin: { type: \"array\", items: { type: \"string\" }, minItems: 3 },\n                    arrayWithMax: { type: \"array\", items: { type: \"string\" }, maxItems: 3 },\n                    arrayWithFormat: { type: \"array\", items: { type: \"string\", format: \"uuid\" } },\n                    // TODO ?\n                    // arrayWithUnique: { type: \"array\", items: { type: \"string\" }, uniqueItems: true },\n                    //\n                    object: { type: \"object\", properties: { str: { type: \"string\" } } },\n                    objectWithRequired: { type: \"object\", properties: { str: { type: \"string\" } }, required: [\"str\"] },\n                    // TODO ?\n                    // objectWithMin: { type: \"object\", properties: { str: { type: \"string\" } }, minProperties: 3 },\n                    // objectWithMax: { type: \"object\", properties: { str: { type: \"string\" } }, maxProperties: 3 },\n                    //\n                    oneOf: { oneOf: [{ type: \"string\" }, { type: \"number\" }] },\n                    anyOf: { anyOf: [{ type: \"string\" }, { type: \"number\" }] },\n                    allOf: { allOf: [{ type: \"string\" }, { type: \"number\" }] },\n                    nested: {\n                        additionalProperties: { type: \"number\" },\n                    },\n                    nestedNullable: {\n                        additionalProperties: { type: \"number\", nullable: true },\n                    },\n                },\n            },\n            options: {\n                withImplicitRequiredProps: true,\n            },\n        })\n    ).toMatchInlineSnapshot(\n        String.raw`\"z.object({ str: z.string(), strWithLength: z.string().min(3).max(3), strWithMin: z.string().min(3), strWithMax: z.string().max(3), strWithPattern: z.string().regex(/^[a-z]+$/), strWithPatternWithSlash: z.string().regex(/abc\\/def\\/ghi/), email: z.string().email(), hostname: z.string().url(), url: z.string().url(), uuid: z.string().uuid(), number: z.number(), int: z.number().int(), intWithMin: z.number().int().gte(3), intWithMax: z.number().int().lte(3), intWithMinAndMax: z.number().int().gte(3).lte(3), intWithExclusiveMinTrue: z.number().int().gt(3), intWithExclusiveMinFalse: z.number().int().gte(3), intWithExclusiveMin: z.number().int().gt(3), intWithExclusiveMaxTrue: z.number().int().lt(3), intWithExclusiveMaxFalse: z.number().int().lte(3), intWithExclusiveMax: z.number().int().lt(3), intWithMultipleOf: z.number().int().multipleOf(3), bool: z.boolean(), array: z.array(z.string()), arrayWithMin: z.array(z.string()).min(3), arrayWithMax: z.array(z.string()).max(3), arrayWithFormat: z.array(z.string().uuid()), object: z.object({ str: z.string() }).passthrough(), objectWithRequired: z.object({ str: z.string() }).passthrough(), oneOf: z.union([z.string(), z.number()]), anyOf: z.union([z.string(), z.number()]), allOf: z.string().and(z.number()), nested: z.record(z.number()), nestedNullable: z.record(z.number().nullable()) }).passthrough()\"`\n    );\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/with-deprecated.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tests/withImplicitRequired-option.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/tsup.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jim/code/personal/openapi-zod-client/lib/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
ELIFECYCLE Command failed with exit code 1.
