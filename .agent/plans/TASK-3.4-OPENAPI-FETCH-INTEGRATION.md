# Task 3.4: Integrate openapi-fetch with Zod Validation

**Status:** READY TO START  
**Estimated Duration:** 2-3 hours (TDD)  
**Prerequisites:** Tasks 3.1-3.3 complete

---

## ğŸ¯ Goal

Create a new template that generates a **type-safe, runtime-validated API client** by wrapping [openapi-fetch](https://github.com/openapi-ts/openapi-typescript/tree/main/packages/openapi-fetch) with our Zod schemas.

**Key Insight:** Instead of building our own fetch logic, we leverage openapi-fetch for HTTP operations and add Zod validation on top for runtime safety.

---

## ğŸ—ï¸ Architecture Deep Dive

### Three-Layer Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Generated API Client (Our Code)                            â”‚
â”‚  - Type-safe wrapper methods (getPet, createUser, etc.)     â”‚
â”‚  - Zod validation for requests & responses                  â”‚
â”‚  - Error handling with Zod parse failures                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ uses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  openapi-fetch (Peer Dependency)                            â”‚
â”‚  - HTTP client with OpenAPI-aware types                     â”‚
â”‚  - Path parameters, query strings, headers                  â”‚
â”‚  - Content negotiation (JSON, form-data, etc.)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ uses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  openapi-typescript (Peer Dependency)                       â”‚
â”‚  - Compile-time TypeScript types from OpenAPI              â”‚
â”‚  - Type inference for paths, methods, parameters            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why This Approach?

**Pros:**
- âœ… **Battle-tested HTTP logic** - Don't reinvent the wheel
- âœ… **Minimal code generation** - We just add validation wrapper
- âœ… **Type safety at compile time** (openapi-typescript) + runtime (Zod)
- âœ… **Maintenance burden stays low** - HTTP logic maintained by openapi-ts team
- âœ… **Standards compliant** - openapi-fetch follows OpenAPI spec closely
- âœ… **Small bundle size** - openapi-fetch is lightweight

**Cons:**
- âš ï¸ **Two peer dependencies** - Users must install openapi-fetch + openapi-typescript
- âš ï¸ **Learning curve** - Users need to understand openapi-fetch API
- âš ï¸ **Version compatibility** - Must keep in sync with openapi-fetch releases

---

## ğŸ“¦ Generated Code Structure

### File: `api-client.ts` (from new template)

```typescript
/**
 * Generated by openapi-zod-client
 * 
 * IMPORTANT: This file requires peer dependencies:
 * - openapi-fetch: ^0.10.0
 * - openapi-typescript: ^7.0.0
 * 
 * Install with: npm install openapi-fetch openapi-typescript
 */

import createClient from 'openapi-fetch';
import type { paths } from './openapi-types'; // User must generate this separately
import { z } from 'zod';

// ============================================================
// SECTION 1: Zod Schemas (Already Generated)
// ============================================================

export const Pet = z.object({
  id: z.number().int(),
  name: z.string(),
  status: z.enum(['available', 'pending', 'sold']),
}).strict();

export const CreatePetRequest = z.object({
  name: z.string(),
  status: z.enum(['available', 'pending', 'sold']).optional(),
}).strict();

// ... more schemas ...

// ============================================================
// SECTION 2: Endpoint Metadata (Already Generated)
// ============================================================

export const endpoints = [
  {
    method: "get" as const,
    path: "/pet/{petId}",
    operationId: "getPetById",
    request: {
      pathParams: z.object({ petId: z.string() })
    },
    responses: {
      200: { schema: Pet, description: "successful operation" },
      400: { schema: z.void(), description: "Invalid ID" },
      404: { schema: z.void(), description: "Pet not found" },
    }
  },
  {
    method: "post" as const,
    path: "/pet",
    operationId: "addPet",
    request: {
      body: CreatePetRequest
    },
    responses: {
      200: { schema: Pet, description: "successful operation" },
      405: { schema: z.void(), description: "Invalid input" },
    }
  },
  // ... more endpoints ...
] as const;

// ============================================================
// SECTION 3: Type-Safe + Runtime-Validated API Client (NEW!)
// ============================================================

/**
 * Configuration for the API client
 */
export type ApiClientConfig = {
  /** Base URL for all API requests */
  baseUrl: string;
  /** Optional fetch configuration */
  fetchOptions?: RequestInit;
  /** 
   * Validation mode:
   * - 'strict': Throw on validation errors (default)
   * - 'loose': Log warnings but don't throw
   * - 'none': Skip validation (use at your own risk)
   */
  validationMode?: 'strict' | 'loose' | 'none';
};

/**
 * Creates a type-safe, runtime-validated API client.
 * 
 * @example
 * ```typescript
 * const api = createApiClient({ 
 *   baseUrl: 'https://petstore.example.com/v1' 
 * });
 * 
 * // Type-safe + runtime validated
 * const pet = await api.getPetById({ petId: '123' });
 * //    ^? Pet (validated at runtime)
 * 
 * // Validation errors throw by default
 * try {
 *   await api.addPet({ name: 123 }); // Type error + runtime error
 * } catch (err) {
 *   if (err instanceof z.ZodError) {
 *     console.log('Validation failed:', err.issues);
 *   }
 * }
 * ```
 */
export function createApiClient(config: ApiClientConfig) {
  const { baseUrl, fetchOptions, validationMode = 'strict' } = config;
  
  // Underlying openapi-fetch client (handles HTTP)
  const client = createClient<paths>({ 
    baseUrl,
    ...fetchOptions 
  });

  /**
   * Helper to validate data with Zod schema
   */
  function validate<T>(schema: z.ZodType<T>, data: unknown, context: string): T {
    if (validationMode === 'none') {
      return data as T;
    }

    const result = schema.safeParse(data);
    
    if (!result.success) {
      const message = `Validation failed for ${context}`;
      
      if (validationMode === 'loose') {
        console.warn(message, result.error.issues);
        return data as T; // Pass through despite errors
      }
      
      // strict mode: throw
      throw new Error(`${message}: ${result.error.message}`);
    }
    
    return result.data;
  }

  // ============================================================
  // Generated type-safe methods for each endpoint
  // ============================================================

  return {
    /**
     * Get pet by ID
     * 
     * @operationId getPetById
     * @path GET /pet/{petId}
     */
    async getPetById(params: { petId: string }) {
      // 1. Validate request parameters
      const validatedParams = validate(
        z.object({ petId: z.string() }),
        params,
        'getPetById request params'
      );

      // 2. Call openapi-fetch (type-safe!)
      const { data, error, response } = await client.GET('/pet/{petId}', {
        params: {
          path: validatedParams
        }
      });

      // 3. Handle errors
      if (error) {
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      }

      // 4. Validate response
      const validated = validate(
        Pet,
        data,
        'getPetById response'
      );

      return validated;
    },

    /**
     * Add a new pet to the store
     * 
     * @operationId addPet
     * @path POST /pet
     */
    async addPet(body: z.infer<typeof CreatePetRequest>) {
      // 1. Validate request body
      const validatedBody = validate(
        CreatePetRequest,
        body,
        'addPet request body'
      );

      // 2. Call openapi-fetch (type-safe!)
      const { data, error, response } = await client.POST('/pet', {
        body: validatedBody
      });

      // 3. Handle errors
      if (error) {
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      }

      // 4. Validate response
      const validated = validate(
        Pet,
        data,
        'addPet response'
      );

      return validated;
    },

    // ... more methods for each endpoint ...

    /**
     * Access to the underlying openapi-fetch client for advanced use cases
     */
    _raw: client,
  };
}

/**
 * Type of the API client (for consumers)
 */
export type ApiClient = ReturnType<typeof createApiClient>;
```

---

## ğŸ”§ Implementation Plan (TDD)

### Phase 1: RED - Write Tests First (30 min)

```typescript
// lib/src/templates/schemas-with-client.test.ts

import { describe, expect, it } from 'vitest';
import { generateZodClientFromOpenAPI } from '../generateZodClientFromOpenAPI.js';

describe('schemas-with-client template', () => {
  const minimalSpec = {
    openapi: '3.0.0',
    info: { title: 'Test', version: '1.0.0' },
    paths: {
      '/pets/{id}': {
        get: {
          operationId: 'getPet',
          parameters: [
            { name: 'id', in: 'path', required: true, schema: { type: 'string' } }
          ],
          responses: {
            '200': {
              description: 'Success',
              content: {
                'application/json': {
                  schema: {
                    type: 'object',
                    properties: {
                      id: { type: 'string' },
                      name: { type: 'string' }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  it('should generate openapi-fetch wrapper', async () => {
    const result = await generateZodClientFromOpenAPI({
      openApiDoc: minimalSpec,
      template: 'schemas-with-client',
      disableWriteToFile: true
    });

    // Should import openapi-fetch
    expect(result).toContain("import createClient from 'openapi-fetch'");
    expect(result).toContain("import type { paths } from");
    
    // Should generate createApiClient function
    expect(result).toContain('export function createApiClient(');
    
    // Should generate method for each operation
    expect(result).toContain('async getPet(');
    
    // Should validate with Zod
    expect(result).toContain('.safeParse(');
    
    // Should call openapi-fetch
    expect(result).toContain("client.GET('/pets/{id}'");
  });

  it('should include validation for request params', async () => {
    const result = await generateZodClientFromOpenAPI({
      openApiDoc: minimalSpec,
      template: 'schemas-with-client',
      disableWriteToFile: true
    });

    expect(result).toContain('validate(');
    expect(result).toContain('request params');
  });

  it('should include validation for responses', async () => {
    const result = await generateZodClientFromOpenAPI({
      openApiDoc: minimalSpec,
      template: 'schemas-with-client',
      disableWriteToFile: true
    });

    expect(result).toContain('validate(');
    expect(result).toContain('response');
  });

  it('should support configurable validation modes', async () => {
    const result = await generateZodClientFromOpenAPI({
      openApiDoc: minimalSpec,
      template: 'schemas-with-client',
      disableWriteToFile: true
    });

    expect(result).toContain("validationMode?: 'strict' | 'loose' | 'none'");
  });

  it('should expose raw client for advanced use', async () => {
    const result = await generateZodClientFromOpenAPI({
      openApiDoc: minimalSpec,
      template: 'schemas-with-client',
      disableWriteToFile: true
    });

    expect(result).toContain('_raw: client');
  });
});
```

**Run tests (should fail):**
```bash
cd lib
pnpm test -- schemas-with-client.test.ts --run
# Expected: All tests fail (template doesn't exist yet)
```

---

### Phase 2: GREEN - Create Template (60 min)

Create `lib/src/templates/schemas-with-client.hbs`:

```handlebars
{{!-- 
  Template: schemas-with-client.hbs
  
  Generates a type-safe API client that wraps openapi-fetch with Zod validation.
  
  Prerequisites (peer dependencies):
  - openapi-fetch: ^0.10.0
  - openapi-typescript: ^7.0.0
  
  Users must also generate openapi-typescript types separately.
--}}

/**
 * Generated by openapi-zod-client
 * 
 * DO NOT EDIT - This file is auto-generated
 * 
 * @see https://github.com/astahmer/openapi-zod-client
 */

import createClient from 'openapi-fetch';
import type { paths } from './openapi-types'; // Generate with: npx openapi-typescript openapi.yaml -o openapi-types.ts
import { z } from 'zod';

{{!-- SECTION 1: Zod Schemas (reuse from schemas-with-metadata) --}}
{{#if types}}
{{#each types}}
{{{this}}};
{{/each}}
{{/if}}

{{#each schemas}}
export const {{@key}}{{#if (lookup ../emittedType @key)}}: z.ZodType<{{@key}}>{{/if}} = {{{this}}};
{{/each}}

{{!-- SECTION 2: Endpoint Metadata (reuse from schemas-with-metadata) --}}
export const endpoints = [
{{#each endpoints}}
  {
    method: "{{method}}" as const,
    path: "{{path}}",
    {{#if alias}}
    operationId: "{{alias}}",
    {{/if}}
    {{#if description}}
    description: `{{description}}`,
    {{/if}}
    request: {
      {{~#if parameters~}}
      {{~#each parameters~}}
      {{~#ifeq type "Path"~}}
      pathParams: z.object({
        {{~#each ../parameters~}}
        {{~#ifeq type "Path"~}}
        "{{name}}": {{{schema}}},
        {{~/ifeq~}}
        {{~/each~}}
      }),
      {{~/ifeq~}}
      {{~/each~}}
      {{~#each parameters~}}
      {{~#ifeq type "Query"~}}
      queryParams: z.object({
        {{~#each ../parameters~}}
        {{~#ifeq type "Query"~}}
        "{{name}}": {{{schema}}},
        {{~/ifeq~}}
        {{~/each~}}
      }).optional(),
      {{~/ifeq~}}
      {{~/each~}}
      {{~#each parameters~}}
      {{~#ifeq type "Header"~}}
      headers: z.object({
        {{~#each ../parameters~}}
        {{~#ifeq type "Header"~}}
        "{{name}}": {{{schema}}},
        {{~/ifeq~}}
        {{~/each~}}
      }).optional(),
      {{~/ifeq~}}
      {{~/each~}}
      {{~#each parameters~}}
      {{~#ifeq type "Body"~}}
      body: {{{schema}}},
      {{~/ifeq~}}
      {{~/each~}}
      {{~/if~}}
    },
    responses: {
      {{~#if responses~}}
      {{~#each responses~}}
      {{statusCode}}: {
        {{~#if description~}}
        description: "{{description}}",
        {{~/if~}}
        schema: {{{schema}}},
      },
      {{~/each~}}
      {{~else~}}
      {{~#if response~}}
      200: {
        description: "Success",
        schema: {{{response}}},
      },
      {{~/if~}}
      {{~/if~}}
      {{~#if errors~}}
      {{~#each errors~}}
      {{~#ifeq status "default"~}}
      default: {
        {{~#if description~}}
        description: "{{description}}",
        {{~/if~}}
        schema: {{{schema}}},
      },
      {{~else~}}
      {{status}}: {
        {{~#if description~}}
        description: "{{description}}",
        {{~/if~}}
        schema: {{{schema}}},
      },
      {{~/ifeq~}}
      {{~/each~}}
      {{~/if~}}
    },
  },
{{/each}}
] as const;

{{!-- SECTION 3: API Client --}}

/**
 * Configuration for the API client
 */
export type ApiClientConfig = {
  /** Base URL for all API requests (e.g., 'https://api.example.com/v1') */
  baseUrl: string;
  /** Optional fetch configuration (headers, credentials, etc.) */
  fetchOptions?: RequestInit;
  /** 
   * Validation mode:
   * - 'strict': Throw ZodError on validation failures (default, recommended)
   * - 'loose': Log warnings but allow invalid data through (debugging)
   * - 'none': Skip validation entirely (not recommended)
   */
  validationMode?: 'strict' | 'loose' | 'none';
};

/**
 * Helper to validate data with Zod schema
 * @internal
 */
function validate<T>(
  schema: z.ZodType<T>, 
  data: unknown, 
  context: string,
  mode: 'strict' | 'loose' | 'none' = 'strict'
): T {
  if (mode === 'none') {
    return data as T;
  }

  const result = schema.safeParse(data);
  
  if (!result.success) {
    const message = `Validation failed for ${context}`;
    
    if (mode === 'loose') {
      console.warn(message, result.error.issues);
      return data as T;
    }
    
    // Throw ZodError for strict mode
    result.error.message = `${message}: ${result.error.message}`;
    throw result.error;
  }
  
  return result.data;
}

/**
 * Creates a type-safe, runtime-validated API client.
 * 
 * This client wraps openapi-fetch with Zod validation for runtime safety.
 * You get:
 * - Compile-time type safety (via openapi-typescript)
 * - Runtime validation (via Zod)
 * - Automatic error handling
 * - Clean, predictable API
 * 
 * @example Basic usage
 * ```typescript
 * import { createApiClient } from './{{options.apiClientName}}';
 * 
 * const api = createApiClient({ 
 *   baseUrl: 'https://api.example.com' 
 * });
 * 
 * // Type-safe + runtime validated
 * const data = await api.getPet({ petId: '123' });
 * ```
 * 
 * @example Error handling
 * ```typescript
 * import { z } from 'zod';
 * 
 * try {
 *   await api.createPet({ name: 'Fluffy' });
 * } catch (error) {
 *   if (error instanceof z.ZodError) {
 *     console.log('Validation failed:', error.issues);
 *   } else {
 *     console.log('API error:', error);
 *   }
 * }
 * ```
 * 
 * @example Custom fetch options
 * ```typescript
 * const api = createApiClient({
 *   baseUrl: 'https://api.example.com',
 *   fetchOptions: {
 *     headers: {
 *       'Authorization': 'Bearer token123'
 *     }
 *   }
 * });
 * ```
 */
export function createApiClient(config: ApiClientConfig) {
  const { baseUrl, fetchOptions, validationMode = 'strict' } = config;
  
  const client = createClient<paths>({ 
    baseUrl,
    ...fetchOptions 
  });

  return {
{{#each endpoints}}
    /**
     * {{#if description}}{{description}}{{else}}{{method}} {{path}}{{/if}}
     * 
     * @operationId {{#if alias}}{{alias}}{{else}}{{method}}_{{path}}{{/if}}
     * @path {{method}} {{path}}
     */
    async {{#if alias}}{{alias}}{{else}}{{method}}_{{path}}{{/if}}(
      {{~#if parameters~}}
      {{~#each parameters~}}
      {{~#ifeq type "Path"~}}
      params: { {{#each ../parameters}}{{#ifeq type "Path"}}{{name}}: z.infer<typeof endpoints[{{@../index}}]['request']['pathParams']>['{{name}}']{{#unless @last}}, {{/unless}}{{/ifeq}}{{/each}} }
      {{~/ifeq~}}
      {{~/each~}}
      {{~/if~}}
      {{~#if parameters~}}
      {{~#each parameters~}}
      {{~#ifeq type "Query"~}}
      , query?: z.infer<typeof endpoints[{{@../index}}]['request']['queryParams']>
      {{~/ifeq~}}
      {{~/each~}}
      {{~/if~}}
      {{~#if parameters~}}
      {{~#each parameters~}}
      {{~#ifeq type "Header"~}}
      , headers?: z.infer<typeof endpoints[{{@../index}}]['request']['headers']>
      {{~/ifeq~}}
      {{~/each~}}
      {{~/if~}}
      {{~#if parameters~}}
      {{~#each parameters~}}
      {{~#ifeq type "Body"~}}
      body: z.infer<typeof endpoints[{{@../index}}]['request']['body']>
      {{~/ifeq~}}
      {{~/each~}}
      {{~/if~}}
    ) {
      const endpoint = endpoints[{{@index}}];
      
      // Validate request parameters
      {{~#if parameters~}}
      {{~#each parameters~}}
      {{~#ifeq type "Path"~}}
      const validatedParams = validate(
        endpoint.request.pathParams,
        params,
        '{{../alias}} request params',
        validationMode
      );
      {{~/ifeq~}}
      {{~/each~}}
      {{~/if~}}
      
      {{~#if parameters~}}
      {{~#each parameters~}}
      {{~#ifeq type "Query"~}}
      const validatedQuery = query ? validate(
        endpoint.request.queryParams!,
        query,
        '{{../alias}} query params',
        validationMode
      ) : undefined;
      {{~/ifeq~}}
      {{~/each~}}
      {{~/if~}}
      
      {{~#if parameters~}}
      {{~#each parameters~}}
      {{~#ifeq type "Body"~}}
      const validatedBody = validate(
        endpoint.request.body,
        body,
        '{{../alias}} request body',
        validationMode
      );
      {{~/ifeq~}}
      {{~/each~}}
      {{~/if~}}
      
      // Call openapi-fetch
      const { data, error, response } = await client.{{method}}("{{path}}", {
        {{~#if parameters~}}
        {{~#each parameters~}}
        {{~#ifeq type "Path"~}}
        params: { path: validatedParams },
        {{~/ifeq~}}
        {{~/each~}}
        {{~#each parameters~}}
        {{~#ifeq type "Query"~}}
        ...(validatedQuery && { params: { query: validatedQuery } }),
        {{~/ifeq~}}
        {{~/each~}}
        {{~#each parameters~}}
        {{~#ifeq type "Body"~}}
        body: validatedBody,
        {{~/ifeq~}}
        {{~/each~}}
        {{~/if~}}
      });
      
      // Handle errors
      if (error) {
        throw new Error(`API error ({{method}} {{path}}): ${response.status} ${response.statusText}`);
      }
      
      // Validate response (use 200 as default if available)
      const responseSchema = endpoint.responses[response.status] || endpoint.responses[200] || endpoint.responses['default'];
      if (!responseSchema) {
        throw new Error(`No schema defined for status ${response.status}`);
      }
      
      return validate(
        responseSchema.schema,
        data,
        '{{alias}} response',
        validationMode
      );
    },

{{/each}}

    /**
     * Direct access to the underlying openapi-fetch client.
     * Use this for advanced scenarios not covered by the generated methods.
     * 
     * @example
     * ```typescript
     * const response = await api._raw.GET('/custom/endpoint');
     * ```
     */
    _raw: client,
  };
}

/**
 * Type of the generated API client
 */
export type {{options.apiClientName}}Client = ReturnType<typeof createApiClient>;
```

**Run tests (should pass):**
```bash
cd lib
pnpm test -- schemas-with-client.test.ts --run
# Expected: All tests pass
```

---

### Phase 3: REFACTOR - Polish & Document (30 min)

1. **Add JSDoc examples**
2. **Create usage documentation**
3. **Add error handling tests**
4. **Verify with real OpenAPI specs**

---

## ğŸ“ User Documentation

### Installation

```bash
# Install the generator
npm install openapi-zod-client

# Install peer dependencies
npm install openapi-fetch openapi-typescript

# Generate TypeScript types (one-time or in build script)
npx openapi-typescript openapi.yaml -o src/openapi-types.ts
```

### Generate Client

```bash
npx openapi-zod-client openapi.yaml \
  --output src/api-client.ts \
  --template schemas-with-client
```

### Usage

```typescript
import { createApiClient } from './api-client';
import { z } from 'zod';

// Create client instance
const api = createApiClient({
  baseUrl: 'https://api.example.com',
  validationMode: 'strict' // default
});

// Use it (fully type-safe + runtime validated!)
async function example() {
  try {
    // GET request with path params
    const pet = await api.getPet({ petId: '123' });
    console.log(pet.name); // Type-safe!
    
    // POST request with body
    const newPet = await api.createPet({
      name: 'Fluffy',
      status: 'available'
    });
    
  } catch (error) {
    if (error instanceof z.ZodError) {
      // Validation error (request or response)
      console.error('Validation failed:', error.issues);
    } else {
      // API/network error
      console.error('API error:', error);
    }
  }
}
```

---

## ğŸ§ª Testing Strategy

### Unit Tests
- Template rendering with various OpenAPI specs
- Validation logic for requests and responses
- Error handling scenarios
- Configuration options

### Integration Tests
- Generate client from real OpenAPI specs (petstore, etc.)
- Verify generated code compiles
- Mock fetch to test validation behavior

### Snapshot Tests
- Capture generated code for regression detection
- Verify no Zodios references
- Verify openapi-fetch integration

---

## âœ… Acceptance Criteria

1. **Template exists:** `lib/src/templates/schemas-with-client.hbs`
2. **Tests pass:** All new tests in `schemas-with-client.test.ts` pass
3. **Quality gates:** Format, build, type-check all pass
4. **Documentation:** Usage guide in template comments
5. **No Zodios:** Zero references to `@zodios/core`
6. **Type safe:** Generated code compiles with no type errors
7. **Runtime validated:** Zod validation on requests and responses
8. **Peer deps:** Documented requirement for openapi-fetch + openapi-typescript

---

## ğŸ“Š Success Metrics

**Before (Zodios):**
- User installs: `@zodios/core`
- Generated code: Tightly coupled to Zodios API
- Maintenance: We maintain HTTP client logic

**After (openapi-fetch + Zod):**
- User installs: `openapi-fetch`, `openapi-typescript` (peer deps)
- Generated code: Thin validation wrapper
- Maintenance: HTTP logic maintained by openapi-ts team
- Value-add: Runtime validation (unique to our tool)

---

## ğŸš€ Next Steps (After Task 3.4)

- **Task 3.5:** Update CLI to support `--template schemas-with-client`
- **Task 3.6:** Remove `@zodios/core` from package.json
- **Task 3.7:** Final validation and documentation

---

## ğŸ”— References

- [openapi-fetch docs](https://openapi-ts.pages.dev/openapi-fetch/)
- [openapi-typescript docs](https://openapi-ts.pages.dev/)
- [Zod documentation](https://zod.dev)

