// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`group-strategy 1`] = `
{
    "Default": {
        "endpoints": [
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/no-tags",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/no-tags",
                "requestFormat": "json",
                "response": "z.string()",
            },
        ],
        "schemas": {},
        "types": {},
    },
    "pet": {
        "endpoints": [
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/pet",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/pet",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/pet/all",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/pet/all",
                "requestFormat": "json",
                "response": "z.string()",
            },
        ],
        "schemas": {},
        "types": {},
    },
    "store": {
        "endpoints": [
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/store",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/store",
                "requestFormat": "json",
                "response": "z.string()",
            },
        ],
        "schemas": {},
        "types": {},
    },
    "user": {
        "endpoints": [
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/user",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/user",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/user/pets",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/user/pets",
                "requestFormat": "json",
                "response": "z.string()",
            },
        ],
        "schemas": {},
        "types": {},
    },
}
`;

exports[`group-strategy 2`] = `
"import { z } from "zod";

export const endpoints = [
  {
    method: "get" as const,
    path: "/no-tags",
    operationId: "noTagsGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/no-tags",
    operationId: "noTagsPut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "get" as const,
    path: "/pet",
    operationId: "petGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/pet",
    operationId: "petPut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "get" as const,
    path: "/pet/all",
    operationId: "petAllGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/pet/all",
    operationId: "petAllPut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "get" as const,
    path: "/store",
    operationId: "storeGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/store",
    operationId: "storePut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "get" as const,
    path: "/user",
    operationId: "userGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/user",
    operationId: "userPut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "get" as const,
    path: "/user/pets",
    operationId: "userGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/user/pets",
    operationId: "userPut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
"
`;

exports[`group-strategy 3`] = `
{
    "get": {
        "endpoints": [
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/pet",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/pet/all",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/store",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/user",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/user/pets",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/no-tags",
                "requestFormat": "json",
                "response": "z.string()",
            },
        ],
        "schemas": {},
        "types": {},
    },
    "put": {
        "endpoints": [
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/pet",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/pet/all",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/store",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/user",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/user/pets",
                "requestFormat": "json",
                "response": "z.string()",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/no-tags",
                "requestFormat": "json",
                "response": "z.string()",
            },
        ],
        "schemas": {},
        "types": {},
    },
}
`;

exports[`group-strategy 4`] = `
"import { z } from "zod";

export const endpoints = [
  {
    method: "get" as const,
    path: "/no-tags",
    operationId: "noTagsGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/no-tags",
    operationId: "noTagsPut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "get" as const,
    path: "/pet",
    operationId: "petGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/pet",
    operationId: "petPut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "get" as const,
    path: "/pet/all",
    operationId: "petAllGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/pet/all",
    operationId: "petAllPut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "get" as const,
    path: "/store",
    operationId: "storeGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/store",
    operationId: "storePut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "get" as const,
    path: "/user",
    operationId: "userGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/user",
    operationId: "userPut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "get" as const,
    path: "/user/pets",
    operationId: "userGet",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
  {
    method: "put" as const,
    path: "/user/pets",
    operationId: "userPut",
    request: {},
    responses: { 200: { schema: z.string() } },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
"
`;

exports[`group-strategy with complex schemas + split files 1`] = `
{
    "Default": {
        "endpoints": [
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/countries",
                "requestFormat": "json",
                "response": "Country",
            },
        ],
        "imports": {
            "Country": "common",
            "Store": "common",
            "User": "common",
        },
        "schemas": {},
        "types": {},
    },
    "pet": {
        "endpoints": [
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/pet",
                "requestFormat": "json",
                "response": "Pet",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/pet",
                "requestFormat": "json",
                "response": "Pet",
            },
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/pet/all",
                "requestFormat": "json",
                "response": "z.array(Pet)",
            },
            {
                "errors": [],
                "method": "post",
                "parameters": [],
                "path": "/pet/all",
                "requestFormat": "json",
                "response": "Pet",
            },
        ],
        "imports": {
            "User": "common",
        },
        "schemas": {
            "Pet": "z.object({ id: z.number().int(), nickname: z.string(), owner: User }).partial().passthrough()",
        },
        "types": {},
    },
    "store": {
        "endpoints": [
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/store",
                "requestFormat": "json",
                "response": "Store",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/store",
                "requestFormat": "json",
                "response": "Store",
            },
        ],
        "imports": {
            "Country": "common",
            "Store": "common",
            "User": "common",
        },
        "schemas": {},
        "types": {},
    },
    "user": {
        "endpoints": [
            {
                "errors": [],
                "method": "get",
                "parameters": [],
                "path": "/user",
                "requestFormat": "json",
                "response": "User",
            },
            {
                "errors": [],
                "method": "put",
                "parameters": [],
                "path": "/user",
                "requestFormat": "json",
                "response": "User",
            },
        ],
        "imports": {
            "User": "common",
        },
        "schemas": {},
        "types": {},
    },
}
`;

exports[`group-strategy with complex schemas + split files 2`] = `
{
    "Default": "import { z } from "zod";

import { Country } from "./common";
import { Store } from "./common";
import { User } from "./common";

export const endpoints = [
  {
    method: "get" as const,
    path: "/countries",
    operationId: "noTagsGet",
    request: {},
    responses: { 200: { schema: Country } },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
",
    "__common": "import { z } from "zod";

export type User = Partial<{
  id: number;
  firstname: string;
  lastname: string;
  email: string;
  friends: Array<User>;
}>;
export type Country = Partial<{
  id: number;
  name: string;
  code: string;
  store_list: Array<Store>;
}>;
export type Store = Partial<{
  id: number;
  name: string;
  address: string;
  country: Country;
  owner: User;
}>;

export const User = z.lazy(() =>
  z
    .object({
      id: z.number().int(),
      firstname: z.string(),
      lastname: z.string(),
      email: z.string(),
      friends: z.array(User),
    })
    .partial()
    .strict(),
);
export const Country = z.lazy(() =>
  z
    .object({
      id: z.number().int(),
      name: z.string(),
      code: z.string(),
      store_list: z.array(Store),
    })
    .partial()
    .strict(),
);
export const Store = z.lazy(() =>
  z
    .object({
      id: z.number().int(),
      name: z.string(),
      address: z.string(),
      country: Country,
      owner: User,
    })
    .partial()
    .strict(),
);
",
    "__index": "export { PetApi } from "./pet";
export { UserApi } from "./user";
export { StoreApi } from "./store";
export { DefaultApi } from "./Default";
",
    "pet": "import { z } from "zod";

import { User } from "./common";

export const Pet = z
  .object({ id: z.number().int(), nickname: z.string(), owner: User })
  .partial()
  .strict();

export const endpoints = [
  {
    method: "get" as const,
    path: "/pet",
    operationId: "petGet",
    request: {},
    responses: { 200: { schema: Pet } },
  },
  {
    method: "put" as const,
    path: "/pet",
    operationId: "petPut",
    request: {},
    responses: { 200: { schema: Pet } },
  },
  {
    method: "get" as const,
    path: "/pet/all",
    operationId: "petAllGet",
    request: {},
    responses: { 200: { schema: z.array(Pet) } },
  },
  {
    method: "post" as const,
    path: "/pet/all",
    operationId: "petAllPost",
    request: {},
    responses: { 200: { schema: Pet } },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
",
    "store": "import { z } from "zod";

import { Store } from "./common";
import { Country } from "./common";
import { User } from "./common";

export const endpoints = [
  {
    method: "get" as const,
    path: "/store",
    operationId: "storeGet",
    request: {},
    responses: { 200: { schema: Store } },
  },
  {
    method: "put" as const,
    path: "/store",
    operationId: "storePut",
    request: {},
    responses: { 200: { schema: Store } },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
",
    "user": "import { z } from "zod";

import { User } from "./common";

export const endpoints = [
  {
    method: "get" as const,
    path: "/user",
    operationId: "userGet",
    request: {},
    responses: { 200: { schema: User } },
  },
  {
    method: "put" as const,
    path: "/user",
    operationId: "userPut",
    request: {},
    responses: { 200: { schema: User } },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
",
}
`;

exports[`group-strategy: tag-file with modified petstore schema 1`] = `
{
    "__common": "import { z } from "zod";

export const Category = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Tag = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Pet = z
  .object({
    id: z.number().int().optional(),
    name: z.string(),
    category: Category.optional(),
    photoUrls: z.array(z.string()),
    tags: z.array(Tag).optional(),
    status: z.enum(["available", "pending", "sold"]).optional(),
  })
  .strict();
",
    "__index": "export { PetApi } from "./pet";
export { StoreApi } from "./store";
export { UserApi } from "./user";
",
    "pet": "import { z } from "zod";

import { Pet } from "./common";
import { Category } from "./common";
import { Tag } from "./common";

export const ApiResponse = z
  .object({ code: z.number().int(), type: z.string(), message: z.string() })
  .partial()
  .strict();

export const endpoints = [
  {
    method: "post" as const,
    path: "/pet",
    operationId: "addPet",
    description: \`Add a new pet to the store\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/pet",
    operationId: "updatePet",
    description: \`Update an existing pet by Id\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByStatus",
    operationId: "findPetsByStatus",
    description: \`Multiple status values can be provided with comma separated strings\`,
    request: {
      queryParams: z
        .object({
          status: z
            .enum(["available", "pending", "sold"])
            .optional()
            .default("available"),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid status value", schema: z.void() },
      400: { description: "Invalid status value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByTags",
    operationId: "findPetsByTags",
    description: \`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\`,
    request: {
      queryParams: z
        .object({ tags: z.array(z.string()).optional() })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid tag value", schema: z.void() },
      400: { description: "Invalid tag value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/:petId",
    operationId: "getPetById",
    description: \`Returns a single pet\`,
    request: { pathParams: z.object({ petId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId",
    operationId: "updatePetWithForm",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
    },
    responses: {
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/pet/:petId",
    operationId: "deletePet",
    description: \`delete a pet\`,
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      headers: z.object({ api_key: z.string().optional() }).optional(),
    },
    responses: {
      400: { description: "Invalid pet value", schema: z.void() },
      400: { description: "Invalid pet value", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId/uploadImage",
    operationId: "uploadFile",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ additionalMetadata: z.string().optional() })
        .optional(),
      body: z.instanceof(File),
    },
    responses: {
      200: { description: "successful operation", schema: ApiResponse },
    },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
",
    "store": "import { z } from "zod";

import { Pet } from "./common";
import { Category } from "./common";
import { Tag } from "./common";

export const Order = z
  .object({
    id: z.number().int(),
    petId: z.number().int(),
    quantity: z.number().int(),
    shipDate: z.string().datetime({ offset: true }),
    status: z.enum(["placed", "approved", "delivered"]),
    complete: z.boolean(),
    pet: Pet,
  })
  .partial()
  .strict();

export const endpoints = [
  {
    method: "get" as const,
    path: "/store/inventory",
    operationId: "getInventory",
    description: \`Returns a map of status codes to quantities\`,
    request: {},
    responses: {
      200: {
        description: "successful operation",
        schema: z.record(z.number().int()),
      },
    },
  },
  {
    method: "post" as const,
    path: "/store/order",
    operationId: "placeOrder",
    description: \`Place a new order in the store\`,
    request: { body: Order },
    responses: {
      200: { description: "successful operation", schema: Order },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/order/:orderId",
    operationId: "getOrderById",
    description: \`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Order },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/store/order/:orderId",
    operationId: "deleteOrder",
    description: \`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
",
    "user": "import { z } from "zod";

export const User = z
  .object({
    id: z.number().int(),
    username: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    email: z.string(),
    password: z.string(),
    phone: z.string(),
    userStatus: z.number().int(),
  })
  .partial()
  .strict();

export const endpoints = [
  {
    method: "post" as const,
    path: "/user",
    operationId: "createUser",
    description: \`This can only be done by the logged in user.\`,
    request: { body: User },
    responses: {
      default: { description: "successful operation", schema: User },
    },
  },
  {
    method: "post" as const,
    path: "/user/createWithList",
    operationId: "createUsersWithListInput",
    description: \`Creates list of users with given input array\`,
    request: { body: z.array(User) },
    responses: {
      200: { description: "Successful operation", schema: User },
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/user/login",
    operationId: "loginUser",
    request: {
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.string() },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
    },
  },
  {
    method: "get" as const,
    path: "/user/logout",
    operationId: "logoutUser",
    request: {},
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/user/:username",
    operationId: "getUserByName",
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      200: { description: "successful operation", schema: User },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/user/:username",
    operationId: "updateUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }), body: User },
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/user/:username",
    operationId: "deleteUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
",
}
`;
