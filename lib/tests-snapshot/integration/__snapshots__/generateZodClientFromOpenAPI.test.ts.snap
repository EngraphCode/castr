// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`generateZodClientFromOpenAPI - with baseUrl > should generate client with base URL 1`] = `
"import { z } from "zod";

export const Category = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Tag = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Pet = z
  .object({
    id: z.number().int().optional(),
    name: z.string(),
    category: Category.optional(),
    photoUrls: z.array(z.string()),
    tags: z.array(Tag).optional(),
    status: z.enum(["available", "pending", "sold"]).optional(),
  })
  .strict();
export const ApiResponse = z
  .object({ code: z.number().int(), type: z.string(), message: z.string() })
  .partial()
  .strict();
export const Order = z
  .object({
    id: z.number().int(),
    petId: z.number().int(),
    quantity: z.number().int(),
    shipDate: z.string().datetime({ offset: true }),
    status: z.enum(["placed", "approved", "delivered"]),
    complete: z.boolean(),
  })
  .partial()
  .strict();
export const User = z
  .object({
    id: z.number().int(),
    username: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    email: z.string(),
    password: z.string(),
    phone: z.string(),
    userStatus: z.number().int(),
  })
  .partial()
  .strict();
export const Address = z
  .object({
    street: z.string(),
    city: z.string(),
    state: z.string(),
    zip: z.string(),
  })
  .partial()
  .strict();
export const Customer = z
  .object({
    id: z.number().int(),
    username: z.string(),
    address: z.array(Address),
  })
  .partial()
  .strict();

export const endpoints = [
  {
    method: "post" as const,
    path: "/pet",
    operationId: "addPet",
    description: \`Add a new pet to the store\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/pet",
    operationId: "updatePet",
    description: \`Update an existing pet by Id\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/:petId",
    operationId: "getPetById",
    description: \`Returns a single pet\`,
    request: { pathParams: z.object({ petId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId",
    operationId: "updatePetWithForm",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
    },
    responses: {
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/pet/:petId",
    operationId: "deletePet",
    description: \`delete a pet\`,
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      headers: z.object({ api_key: z.string().optional() }).optional(),
    },
    responses: {
      400: { description: "Invalid pet value", schema: z.void() },
      400: { description: "Invalid pet value", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId/uploadImage",
    operationId: "uploadFile",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ additionalMetadata: z.string().optional() })
        .optional(),
      body: z.instanceof(File),
    },
    responses: {
      200: { description: "successful operation", schema: ApiResponse },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByStatus",
    operationId: "findPetsByStatus",
    description: \`Multiple status values can be provided with comma separated strings\`,
    request: {
      queryParams: z
        .object({
          status: z
            .enum(["available", "pending", "sold"])
            .optional()
            .default("available"),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid status value", schema: z.void() },
      400: { description: "Invalid status value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByTags",
    operationId: "findPetsByTags",
    description: \`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\`,
    request: {
      queryParams: z
        .object({ tags: z.array(z.string()).optional() })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid tag value", schema: z.void() },
      400: { description: "Invalid tag value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/inventory",
    operationId: "getInventory",
    description: \`Returns a map of status codes to quantities\`,
    request: {},
    responses: {
      200: {
        description: "successful operation",
        schema: z.record(z.number().int()),
      },
    },
  },
  {
    method: "post" as const,
    path: "/store/order",
    operationId: "placeOrder",
    description: \`Place a new order in the store\`,
    request: { body: Order },
    responses: {
      200: { description: "successful operation", schema: Order },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/order/:orderId",
    operationId: "getOrderById",
    description: \`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Order },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/store/order/:orderId",
    operationId: "deleteOrder",
    description: \`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user",
    operationId: "createUser",
    description: \`This can only be done by the logged in user.\`,
    request: { body: User },
    responses: {
      default: { description: "successful operation", schema: User },
    },
  },
  {
    method: "get" as const,
    path: "/user/:username",
    operationId: "getUserByName",
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      200: { description: "successful operation", schema: User },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/user/:username",
    operationId: "updateUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }), body: User },
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/user/:username",
    operationId: "deleteUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user/createWithList",
    operationId: "createUsersWithListInput",
    description: \`Creates list of users with given input array\`,
    request: { body: z.array(User) },
    responses: {
      200: { description: "Successful operation", schema: User },
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/user/login",
    operationId: "loginUser",
    request: {
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.string() },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
    },
  },
  {
    method: "get" as const,
    path: "/user/logout",
    operationId: "logoutUser",
    request: {},
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
"
`;

exports[`generateZodClientFromOpenAPI - with tag-file groupStrategy > should generate client with tag-file grouping 1`] = `
"import { z } from "zod";

export const Category = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Tag = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Pet = z
  .object({
    id: z.number().int().optional(),
    name: z.string(),
    category: Category.optional(),
    photoUrls: z.array(z.string()),
    tags: z.array(Tag).optional(),
    status: z.enum(["available", "pending", "sold"]).optional(),
  })
  .strict();
export const ApiResponse = z
  .object({ code: z.number().int(), type: z.string(), message: z.string() })
  .partial()
  .strict();

export const endpoints = [
  {
    method: "post" as const,
    path: "/pet",
    operationId: "addPet",
    description: \`Add a new pet to the store\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/pet",
    operationId: "updatePet",
    description: \`Update an existing pet by Id\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByStatus",
    operationId: "findPetsByStatus",
    description: \`Multiple status values can be provided with comma separated strings\`,
    request: {
      queryParams: z
        .object({
          status: z
            .enum(["available", "pending", "sold"])
            .optional()
            .default("available"),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid status value", schema: z.void() },
      400: { description: "Invalid status value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByTags",
    operationId: "findPetsByTags",
    description: \`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\`,
    request: {
      queryParams: z
        .object({ tags: z.array(z.string()).optional() })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid tag value", schema: z.void() },
      400: { description: "Invalid tag value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/:petId",
    operationId: "getPetById",
    description: \`Returns a single pet\`,
    request: { pathParams: z.object({ petId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId",
    operationId: "updatePetWithForm",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
    },
    responses: {
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/pet/:petId",
    operationId: "deletePet",
    description: \`delete a pet\`,
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      headers: z.object({ api_key: z.string().optional() }).optional(),
    },
    responses: {
      400: { description: "Invalid pet value", schema: z.void() },
      400: { description: "Invalid pet value", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId/uploadImage",
    operationId: "uploadFile",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ additionalMetadata: z.string().optional() })
        .optional(),
      body: z.instanceof(File),
    },
    responses: {
      200: { description: "successful operation", schema: ApiResponse },
    },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
"
`;

exports[`generateZodClientFromOpenAPI - withAlias as custom function > should generate client with custom alias function 1`] = `
"import { z } from "zod";

export const Category = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Tag = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Pet = z
  .object({
    id: z.number().int().optional(),
    name: z.string(),
    category: Category.optional(),
    photoUrls: z.array(z.string()),
    tags: z.array(Tag).optional(),
    status: z.enum(["available", "pending", "sold"]).optional(),
  })
  .strict();
export const ApiResponse = z
  .object({ code: z.number().int(), type: z.string(), message: z.string() })
  .partial()
  .strict();
export const Order = z
  .object({
    id: z.number().int(),
    petId: z.number().int(),
    quantity: z.number().int(),
    shipDate: z.string().datetime({ offset: true }),
    status: z.enum(["placed", "approved", "delivered"]),
    complete: z.boolean(),
  })
  .partial()
  .strict();
export const User = z
  .object({
    id: z.number().int(),
    username: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    email: z.string(),
    password: z.string(),
    phone: z.string(),
    userStatus: z.number().int(),
  })
  .partial()
  .strict();
export const Address = z
  .object({
    street: z.string(),
    city: z.string(),
    state: z.string(),
    zip: z.string(),
  })
  .partial()
  .strict();
export const Customer = z
  .object({
    id: z.number().int(),
    username: z.string(),
    address: z.array(Address),
  })
  .partial()
  .strict();

export const endpoints = [
  {
    method: "post" as const,
    path: "/pet",
    operationId: "addPet",
    description: \`Add a new pet to the store\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/pet",
    operationId: "updatePet",
    description: \`Update an existing pet by Id\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/:petId",
    operationId: "getPetById",
    description: \`Returns a single pet\`,
    request: { pathParams: z.object({ petId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId",
    operationId: "updatePetWithForm",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
    },
    responses: {
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/pet/:petId",
    operationId: "deletePet",
    description: \`delete a pet\`,
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      headers: z.object({ api_key: z.string().optional() }).optional(),
    },
    responses: {
      400: { description: "Invalid pet value", schema: z.void() },
      400: { description: "Invalid pet value", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId/uploadImage",
    operationId: "uploadFile",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ additionalMetadata: z.string().optional() })
        .optional(),
      body: z.instanceof(File),
    },
    responses: {
      200: { description: "successful operation", schema: ApiResponse },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByStatus",
    operationId: "findPetsByStatus",
    description: \`Multiple status values can be provided with comma separated strings\`,
    request: {
      queryParams: z
        .object({
          status: z
            .enum(["available", "pending", "sold"])
            .optional()
            .default("available"),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid status value", schema: z.void() },
      400: { description: "Invalid status value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByTags",
    operationId: "findPetsByTags",
    description: \`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\`,
    request: {
      queryParams: z
        .object({ tags: z.array(z.string()).optional() })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid tag value", schema: z.void() },
      400: { description: "Invalid tag value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/inventory",
    operationId: "getInventory",
    description: \`Returns a map of status codes to quantities\`,
    request: {},
    responses: {
      200: {
        description: "successful operation",
        schema: z.record(z.number().int()),
      },
    },
  },
  {
    method: "post" as const,
    path: "/store/order",
    operationId: "placeOrder",
    description: \`Place a new order in the store\`,
    request: { body: Order },
    responses: {
      200: { description: "successful operation", schema: Order },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/order/:orderId",
    operationId: "getOrderById",
    description: \`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Order },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/store/order/:orderId",
    operationId: "deleteOrder",
    description: \`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user",
    operationId: "createUser",
    description: \`This can only be done by the logged in user.\`,
    request: { body: User },
    responses: {
      default: { description: "successful operation", schema: User },
    },
  },
  {
    method: "get" as const,
    path: "/user/:username",
    operationId: "getUserByName",
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      200: { description: "successful operation", schema: User },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/user/:username",
    operationId: "updateUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }), body: User },
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/user/:username",
    operationId: "deleteUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user/createWithList",
    operationId: "createUsersWithListInput",
    description: \`Creates list of users with given input array\`,
    request: { body: z.array(User) },
    responses: {
      200: { description: "Successful operation", schema: User },
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/user/login",
    operationId: "loginUser",
    request: {
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.string() },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
    },
  },
  {
    method: "get" as const,
    path: "/user/logout",
    operationId: "logoutUser",
    request: {},
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
"
`;

exports[`generateZodClientFromOpenAPI - withAlias as false > should generate client with alias disabled 1`] = `
"import { z } from "zod";

export const Category = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Tag = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Pet = z
  .object({
    id: z.number().int().optional(),
    name: z.string(),
    category: Category.optional(),
    photoUrls: z.array(z.string()),
    tags: z.array(Tag).optional(),
    status: z.enum(["available", "pending", "sold"]).optional(),
  })
  .strict();
export const ApiResponse = z
  .object({ code: z.number().int(), type: z.string(), message: z.string() })
  .partial()
  .strict();
export const Order = z
  .object({
    id: z.number().int(),
    petId: z.number().int(),
    quantity: z.number().int(),
    shipDate: z.string().datetime({ offset: true }),
    status: z.enum(["placed", "approved", "delivered"]),
    complete: z.boolean(),
  })
  .partial()
  .strict();
export const User = z
  .object({
    id: z.number().int(),
    username: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    email: z.string(),
    password: z.string(),
    phone: z.string(),
    userStatus: z.number().int(),
  })
  .partial()
  .strict();
export const Address = z
  .object({
    street: z.string(),
    city: z.string(),
    state: z.string(),
    zip: z.string(),
  })
  .partial()
  .strict();
export const Customer = z
  .object({
    id: z.number().int(),
    username: z.string(),
    address: z.array(Address),
  })
  .partial()
  .strict();

export const endpoints = [
  {
    method: "post" as const,
    path: "/pet",
    operationId: "addPet",
    description: \`Add a new pet to the store\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/pet",
    operationId: "updatePet",
    description: \`Update an existing pet by Id\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/:petId",
    operationId: "getPetById",
    description: \`Returns a single pet\`,
    request: { pathParams: z.object({ petId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId",
    operationId: "updatePetWithForm",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
    },
    responses: {
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/pet/:petId",
    operationId: "deletePet",
    description: \`delete a pet\`,
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      headers: z.object({ api_key: z.string().optional() }).optional(),
    },
    responses: {
      400: { description: "Invalid pet value", schema: z.void() },
      400: { description: "Invalid pet value", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId/uploadImage",
    operationId: "uploadFile",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ additionalMetadata: z.string().optional() })
        .optional(),
      body: z.instanceof(File),
    },
    responses: {
      200: { description: "successful operation", schema: ApiResponse },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByStatus",
    operationId: "findPetsByStatus",
    description: \`Multiple status values can be provided with comma separated strings\`,
    request: {
      queryParams: z
        .object({
          status: z
            .enum(["available", "pending", "sold"])
            .optional()
            .default("available"),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid status value", schema: z.void() },
      400: { description: "Invalid status value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByTags",
    operationId: "findPetsByTags",
    description: \`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\`,
    request: {
      queryParams: z
        .object({ tags: z.array(z.string()).optional() })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid tag value", schema: z.void() },
      400: { description: "Invalid tag value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/inventory",
    operationId: "getInventory",
    description: \`Returns a map of status codes to quantities\`,
    request: {},
    responses: {
      200: {
        description: "successful operation",
        schema: z.record(z.number().int()),
      },
    },
  },
  {
    method: "post" as const,
    path: "/store/order",
    operationId: "placeOrder",
    description: \`Place a new order in the store\`,
    request: { body: Order },
    responses: {
      200: { description: "successful operation", schema: Order },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/order/:orderId",
    operationId: "getOrderById",
    description: \`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Order },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/store/order/:orderId",
    operationId: "deleteOrder",
    description: \`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user",
    operationId: "createUser",
    description: \`This can only be done by the logged in user.\`,
    request: { body: User },
    responses: {
      default: { description: "successful operation", schema: User },
    },
  },
  {
    method: "get" as const,
    path: "/user/:username",
    operationId: "getUserByName",
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      200: { description: "successful operation", schema: User },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/user/:username",
    operationId: "updateUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }), body: User },
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/user/:username",
    operationId: "deleteUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user/createWithList",
    operationId: "createUsersWithListInput",
    description: \`Creates list of users with given input array\`,
    request: { body: z.array(User) },
    responses: {
      200: { description: "Successful operation", schema: User },
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/user/login",
    operationId: "loginUser",
    request: {
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.string() },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
    },
  },
  {
    method: "get" as const,
    path: "/user/logout",
    operationId: "logoutUser",
    request: {},
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
"
`;

exports[`generateZodClientFromOpenAPI - withAlias as true > should generate client with alias enabled 1`] = `
"import { z } from "zod";

export const Category = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Tag = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Pet = z
  .object({
    id: z.number().int().optional(),
    name: z.string(),
    category: Category.optional(),
    photoUrls: z.array(z.string()),
    tags: z.array(Tag).optional(),
    status: z.enum(["available", "pending", "sold"]).optional(),
  })
  .strict();
export const ApiResponse = z
  .object({ code: z.number().int(), type: z.string(), message: z.string() })
  .partial()
  .strict();
export const Order = z
  .object({
    id: z.number().int(),
    petId: z.number().int(),
    quantity: z.number().int(),
    shipDate: z.string().datetime({ offset: true }),
    status: z.enum(["placed", "approved", "delivered"]),
    complete: z.boolean(),
  })
  .partial()
  .strict();
export const User = z
  .object({
    id: z.number().int(),
    username: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    email: z.string(),
    password: z.string(),
    phone: z.string(),
    userStatus: z.number().int(),
  })
  .partial()
  .strict();
export const Address = z
  .object({
    street: z.string(),
    city: z.string(),
    state: z.string(),
    zip: z.string(),
  })
  .partial()
  .strict();
export const Customer = z
  .object({
    id: z.number().int(),
    username: z.string(),
    address: z.array(Address),
  })
  .partial()
  .strict();

export const endpoints = [
  {
    method: "post" as const,
    path: "/pet",
    operationId: "addPet",
    description: \`Add a new pet to the store\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/pet",
    operationId: "updatePet",
    description: \`Update an existing pet by Id\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/:petId",
    operationId: "getPetById",
    description: \`Returns a single pet\`,
    request: { pathParams: z.object({ petId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId",
    operationId: "updatePetWithForm",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
    },
    responses: {
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/pet/:petId",
    operationId: "deletePet",
    description: \`delete a pet\`,
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      headers: z.object({ api_key: z.string().optional() }).optional(),
    },
    responses: {
      400: { description: "Invalid pet value", schema: z.void() },
      400: { description: "Invalid pet value", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId/uploadImage",
    operationId: "uploadFile",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ additionalMetadata: z.string().optional() })
        .optional(),
      body: z.instanceof(File),
    },
    responses: {
      200: { description: "successful operation", schema: ApiResponse },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByStatus",
    operationId: "findPetsByStatus",
    description: \`Multiple status values can be provided with comma separated strings\`,
    request: {
      queryParams: z
        .object({
          status: z
            .enum(["available", "pending", "sold"])
            .optional()
            .default("available"),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid status value", schema: z.void() },
      400: { description: "Invalid status value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByTags",
    operationId: "findPetsByTags",
    description: \`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\`,
    request: {
      queryParams: z
        .object({ tags: z.array(z.string()).optional() })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid tag value", schema: z.void() },
      400: { description: "Invalid tag value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/inventory",
    operationId: "getInventory",
    description: \`Returns a map of status codes to quantities\`,
    request: {},
    responses: {
      200: {
        description: "successful operation",
        schema: z.record(z.number().int()),
      },
    },
  },
  {
    method: "post" as const,
    path: "/store/order",
    operationId: "placeOrder",
    description: \`Place a new order in the store\`,
    request: { body: Order },
    responses: {
      200: { description: "successful operation", schema: Order },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/order/:orderId",
    operationId: "getOrderById",
    description: \`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Order },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/store/order/:orderId",
    operationId: "deleteOrder",
    description: \`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user",
    operationId: "createUser",
    description: \`This can only be done by the logged in user.\`,
    request: { body: User },
    responses: {
      default: { description: "successful operation", schema: User },
    },
  },
  {
    method: "get" as const,
    path: "/user/:username",
    operationId: "getUserByName",
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      200: { description: "successful operation", schema: User },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/user/:username",
    operationId: "updateUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }), body: User },
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/user/:username",
    operationId: "deleteUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user/createWithList",
    operationId: "createUsersWithListInput",
    description: \`Creates list of users with given input array\`,
    request: { body: z.array(User) },
    responses: {
      200: { description: "Successful operation", schema: User },
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/user/login",
    operationId: "loginUser",
    request: {
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.string() },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
    },
  },
  {
    method: "get" as const,
    path: "/user/logout",
    operationId: "logoutUser",
    request: {},
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
"
`;

exports[`generateZodClientFromOpenAPI - without default values > should generate client without default values 1`] = `
"import { z } from "zod";

export const Category = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Tag = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Pet = z
  .object({
    id: z.number().int().optional(),
    name: z.string(),
    category: Category.optional(),
    photoUrls: z.array(z.string()),
    tags: z.array(Tag).optional(),
    status: z.enum(["available", "pending", "sold"]).optional(),
  })
  .strict();
export const ApiResponse = z
  .object({ code: z.number().int(), type: z.string(), message: z.string() })
  .partial()
  .strict();
export const Order = z
  .object({
    id: z.number().int(),
    petId: z.number().int(),
    quantity: z.number().int(),
    shipDate: z.string().datetime({ offset: true }),
    status: z.enum(["placed", "approved", "delivered"]),
    complete: z.boolean(),
  })
  .partial()
  .strict();
export const User = z
  .object({
    id: z.number().int(),
    username: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    email: z.string(),
    password: z.string(),
    phone: z.string(),
    userStatus: z.number().int(),
  })
  .partial()
  .strict();
export const Address = z
  .object({
    street: z.string(),
    city: z.string(),
    state: z.string(),
    zip: z.string(),
  })
  .partial()
  .strict();
export const Customer = z
  .object({
    id: z.number().int(),
    username: z.string(),
    address: z.array(Address),
  })
  .partial()
  .strict();

export const endpoints = [
  {
    method: "post" as const,
    path: "/pet",
    operationId: "addPet",
    description: \`Add a new pet to the store\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/pet",
    operationId: "updatePet",
    description: \`Update an existing pet by Id\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/:petId",
    operationId: "getPetById",
    description: \`Returns a single pet\`,
    request: { pathParams: z.object({ petId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId",
    operationId: "updatePetWithForm",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
    },
    responses: {
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/pet/:petId",
    operationId: "deletePet",
    description: \`delete a pet\`,
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      headers: z.object({ api_key: z.string().optional() }).optional(),
    },
    responses: {
      400: { description: "Invalid pet value", schema: z.void() },
      400: { description: "Invalid pet value", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId/uploadImage",
    operationId: "uploadFile",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ additionalMetadata: z.string().optional() })
        .optional(),
      body: z.instanceof(File),
    },
    responses: {
      200: { description: "successful operation", schema: ApiResponse },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByStatus",
    operationId: "findPetsByStatus",
    description: \`Multiple status values can be provided with comma separated strings\`,
    request: {
      queryParams: z
        .object({ status: z.enum(["available", "pending", "sold"]).optional() })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid status value", schema: z.void() },
      400: { description: "Invalid status value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByTags",
    operationId: "findPetsByTags",
    description: \`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\`,
    request: {
      queryParams: z
        .object({ tags: z.array(z.string()).optional() })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid tag value", schema: z.void() },
      400: { description: "Invalid tag value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/inventory",
    operationId: "getInventory",
    description: \`Returns a map of status codes to quantities\`,
    request: {},
    responses: {
      200: {
        description: "successful operation",
        schema: z.record(z.number().int()),
      },
    },
  },
  {
    method: "post" as const,
    path: "/store/order",
    operationId: "placeOrder",
    description: \`Place a new order in the store\`,
    request: { body: Order },
    responses: {
      200: { description: "successful operation", schema: Order },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/order/:orderId",
    operationId: "getOrderById",
    description: \`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Order },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/store/order/:orderId",
    operationId: "deleteOrder",
    description: \`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user",
    operationId: "createUser",
    description: \`This can only be done by the logged in user.\`,
    request: { body: User },
    responses: {
      default: { description: "successful operation", schema: User },
    },
  },
  {
    method: "get" as const,
    path: "/user/:username",
    operationId: "getUserByName",
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      200: { description: "successful operation", schema: User },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/user/:username",
    operationId: "updateUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }), body: User },
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/user/:username",
    operationId: "deleteUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user/createWithList",
    operationId: "createUsersWithListInput",
    description: \`Creates list of users with given input array\`,
    request: { body: z.array(User) },
    responses: {
      200: { description: "Successful operation", schema: User },
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/user/login",
    operationId: "loginUser",
    request: {
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.string() },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
    },
  },
  {
    method: "get" as const,
    path: "/user/logout",
    operationId: "logoutUser",
    request: {},
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
"
`;

exports[`generateZodClientFromOpenAPI - without options > should generate client without options 1`] = `
"import { z } from "zod";

export const Category = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Tag = z
  .object({ id: z.number().int(), name: z.string() })
  .partial()
  .strict();
export const Pet = z
  .object({
    id: z.number().int().optional(),
    name: z.string(),
    category: Category.optional(),
    photoUrls: z.array(z.string()),
    tags: z.array(Tag).optional(),
    status: z.enum(["available", "pending", "sold"]).optional(),
  })
  .strict();
export const ApiResponse = z
  .object({ code: z.number().int(), type: z.string(), message: z.string() })
  .partial()
  .strict();
export const Order = z
  .object({
    id: z.number().int(),
    petId: z.number().int(),
    quantity: z.number().int(),
    shipDate: z.string().datetime({ offset: true }),
    status: z.enum(["placed", "approved", "delivered"]),
    complete: z.boolean(),
  })
  .partial()
  .strict();
export const User = z
  .object({
    id: z.number().int(),
    username: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    email: z.string(),
    password: z.string(),
    phone: z.string(),
    userStatus: z.number().int(),
  })
  .partial()
  .strict();
export const Address = z
  .object({
    street: z.string(),
    city: z.string(),
    state: z.string(),
    zip: z.string(),
  })
  .partial()
  .strict();
export const Customer = z
  .object({
    id: z.number().int(),
    username: z.string(),
    address: z.array(Address),
  })
  .partial()
  .strict();

export const endpoints = [
  {
    method: "post" as const,
    path: "/pet",
    operationId: "addPet",
    description: \`Add a new pet to the store\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/pet",
    operationId: "updatePet",
    description: \`Update an existing pet by Id\`,
    request: { body: Pet },
    responses: {
      200: { description: "Successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      405: { description: "Validation exception", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/:petId",
    operationId: "getPetById",
    description: \`Returns a single pet\`,
    request: { pathParams: z.object({ petId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Pet },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Pet not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId",
    operationId: "updatePetWithForm",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
      queryParams: z
        .object({ name: z.string().optional(), status: z.string().optional() })
        .optional(),
    },
    responses: {
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/pet/:petId",
    operationId: "deletePet",
    description: \`delete a pet\`,
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      headers: z.object({ api_key: z.string().optional() }).optional(),
    },
    responses: {
      400: { description: "Invalid pet value", schema: z.void() },
      400: { description: "Invalid pet value", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/pet/:petId/uploadImage",
    operationId: "uploadFile",
    request: {
      pathParams: z.object({ petId: z.number().int() }),
      queryParams: z
        .object({ additionalMetadata: z.string().optional() })
        .optional(),
      body: z.instanceof(File),
    },
    responses: {
      200: { description: "successful operation", schema: ApiResponse },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByStatus",
    operationId: "findPetsByStatus",
    description: \`Multiple status values can be provided with comma separated strings\`,
    request: {
      queryParams: z
        .object({
          status: z
            .enum(["available", "pending", "sold"])
            .optional()
            .default("available"),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid status value", schema: z.void() },
      400: { description: "Invalid status value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/pet/findByTags",
    operationId: "findPetsByTags",
    description: \`Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\`,
    request: {
      queryParams: z
        .object({ tags: z.array(z.string()).optional() })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.array(Pet) },
      400: { description: "Invalid tag value", schema: z.void() },
      400: { description: "Invalid tag value", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/inventory",
    operationId: "getInventory",
    description: \`Returns a map of status codes to quantities\`,
    request: {},
    responses: {
      200: {
        description: "successful operation",
        schema: z.record(z.number().int()),
      },
    },
  },
  {
    method: "post" as const,
    path: "/store/order",
    operationId: "placeOrder",
    description: \`Place a new order in the store\`,
    request: { body: Order },
    responses: {
      200: { description: "successful operation", schema: Order },
      405: { description: "Invalid input", schema: z.void() },
      405: { description: "Invalid input", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/store/order/:orderId",
    operationId: "getOrderById",
    description: \`For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generate exceptions.\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      200: { description: "successful operation", schema: Order },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/store/order/:orderId",
    operationId: "deleteOrder",
    description: \`For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\`,
    request: { pathParams: z.object({ orderId: z.number().int() }) },
    responses: {
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
      400: { description: "Invalid ID supplied", schema: z.void() },
      404: { description: "Order not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user",
    operationId: "createUser",
    description: \`This can only be done by the logged in user.\`,
    request: { body: User },
    responses: {
      default: { description: "successful operation", schema: User },
    },
  },
  {
    method: "get" as const,
    path: "/user/:username",
    operationId: "getUserByName",
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      200: { description: "successful operation", schema: User },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "put" as const,
    path: "/user/:username",
    operationId: "updateUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }), body: User },
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "delete" as const,
    path: "/user/:username",
    operationId: "deleteUser",
    description: \`This can only be done by the logged in user.\`,
    request: { pathParams: z.object({ username: z.string() }) },
    responses: {
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
      400: { description: "Invalid username supplied", schema: z.void() },
      404: { description: "User not found", schema: z.void() },
    },
  },
  {
    method: "post" as const,
    path: "/user/createWithList",
    operationId: "createUsersWithListInput",
    description: \`Creates list of users with given input array\`,
    request: { body: z.array(User) },
    responses: {
      200: { description: "Successful operation", schema: User },
      default: { description: "successful operation", schema: z.void() },
    },
  },
  {
    method: "get" as const,
    path: "/user/login",
    operationId: "loginUser",
    request: {
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
      queryParams: z
        .object({
          username: z.string().optional(),
          password: z.string().optional(),
        })
        .optional(),
    },
    responses: {
      200: { description: "successful operation", schema: z.string() },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
      400: {
        description: "Invalid username/password supplied",
        schema: z.void(),
      },
    },
  },
  {
    method: "get" as const,
    path: "/user/logout",
    operationId: "logoutUser",
    request: {},
    responses: {
      default: { description: "successful operation", schema: z.void() },
    },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
"
`;

exports[`getZodClientTemplateContext 1`] = `
{
    "circularTypeByName": {},
    "emittedType": {},
    "endpoints": [
        {
            "description": "Add a new pet to the store",
            "errors": [
                {
                    "description": "Invalid input",
                    "schema": "z.void()",
                    "status": 405,
                },
            ],
            "method": "post",
            "parameters": [
                {
                    "description": "Create a new pet in the store",
                    "name": "body",
                    "schema": "Pet",
                    "type": "Body",
                },
            ],
            "path": "/pet",
            "requestFormat": "json",
            "response": "Pet",
        },
        {
            "description": "Update an existing pet by Id",
            "errors": [
                {
                    "description": "Invalid ID supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "Pet not found",
                    "schema": "z.void()",
                    "status": 404,
                },
                {
                    "description": "Validation exception",
                    "schema": "z.void()",
                    "status": 405,
                },
            ],
            "method": "put",
            "parameters": [
                {
                    "description": "Update an existent pet in the store",
                    "name": "body",
                    "schema": "Pet",
                    "type": "Body",
                },
            ],
            "path": "/pet",
            "requestFormat": "json",
            "response": "Pet",
        },
        {
            "description": "Returns a single pet",
            "errors": [
                {
                    "description": "Invalid ID supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "Pet not found",
                    "schema": "z.void()",
                    "status": 404,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "petId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
            ],
            "path": "/pet/:petId",
            "requestFormat": "json",
            "response": "Pet",
        },
        {
            "errors": [
                {
                    "description": "Invalid input",
                    "schema": "z.void()",
                    "status": 405,
                },
            ],
            "method": "post",
            "parameters": [
                {
                    "name": "petId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
                {
                    "name": "name",
                    "schema": "z.string().optional()",
                    "type": "Query",
                },
                {
                    "name": "status",
                    "schema": "z.string().optional()",
                    "type": "Query",
                },
            ],
            "path": "/pet/:petId",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "description": "delete a pet",
            "errors": [
                {
                    "description": "Invalid pet value",
                    "schema": "z.void()",
                    "status": 400,
                },
            ],
            "method": "delete",
            "parameters": [
                {
                    "name": "api_key",
                    "schema": "z.string().optional()",
                    "type": "Header",
                },
                {
                    "name": "petId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
            ],
            "path": "/pet/:petId",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "errors": [],
            "method": "post",
            "parameters": [
                {
                    "description": "",
                    "name": "body",
                    "schema": "z.instanceof(File)",
                    "type": "Body",
                },
                {
                    "name": "petId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
                {
                    "name": "additionalMetadata",
                    "schema": "z.string().optional()",
                    "type": "Query",
                },
            ],
            "path": "/pet/:petId/uploadImage",
            "requestFormat": "binary",
            "response": "ApiResponse",
        },
        {
            "description": "Multiple status values can be provided with comma separated strings",
            "errors": [
                {
                    "description": "Invalid status value",
                    "schema": "z.void()",
                    "status": 400,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "status",
                    "schema": "z.enum(["available", "pending", "sold"]).optional().default("available")",
                    "type": "Query",
                },
            ],
            "path": "/pet/findByStatus",
            "requestFormat": "json",
            "response": "z.array(Pet)",
        },
        {
            "description": "Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.",
            "errors": [
                {
                    "description": "Invalid tag value",
                    "schema": "z.void()",
                    "status": 400,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "tags",
                    "schema": "z.array(z.string()).optional()",
                    "type": "Query",
                },
            ],
            "path": "/pet/findByTags",
            "requestFormat": "json",
            "response": "z.array(Pet)",
        },
        {
            "description": "Returns a map of status codes to quantities",
            "errors": [],
            "method": "get",
            "parameters": [],
            "path": "/store/inventory",
            "requestFormat": "json",
            "response": "z.record(z.number().int())",
        },
        {
            "description": "Place a new order in the store",
            "errors": [
                {
                    "description": "Invalid input",
                    "schema": "z.void()",
                    "status": 405,
                },
            ],
            "method": "post",
            "parameters": [
                {
                    "description": "",
                    "name": "body",
                    "schema": "Order",
                    "type": "Body",
                },
            ],
            "path": "/store/order",
            "requestFormat": "json",
            "response": "Order",
        },
        {
            "description": "For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.",
            "errors": [
                {
                    "description": "Invalid ID supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "Order not found",
                    "schema": "z.void()",
                    "status": 404,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "orderId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
            ],
            "path": "/store/order/:orderId",
            "requestFormat": "json",
            "response": "Order",
        },
        {
            "description": "For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors",
            "errors": [
                {
                    "description": "Invalid ID supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "Order not found",
                    "schema": "z.void()",
                    "status": 404,
                },
            ],
            "method": "delete",
            "parameters": [
                {
                    "name": "orderId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
            ],
            "path": "/store/order/:orderId",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "description": "This can only be done by the logged in user.",
            "errors": [],
            "method": "post",
            "parameters": [
                {
                    "description": "Created user object",
                    "name": "body",
                    "schema": "User",
                    "type": "Body",
                },
            ],
            "path": "/user",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "errors": [
                {
                    "description": "Invalid username supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "User not found",
                    "schema": "z.void()",
                    "status": 404,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "username",
                    "schema": "z.string()",
                    "type": "Path",
                },
            ],
            "path": "/user/:username",
            "requestFormat": "json",
            "response": "User",
        },
        {
            "description": "This can only be done by the logged in user.",
            "errors": [],
            "method": "put",
            "parameters": [
                {
                    "description": "Update an existent user in the store",
                    "name": "body",
                    "schema": "User",
                    "type": "Body",
                },
                {
                    "name": "username",
                    "schema": "z.string()",
                    "type": "Path",
                },
            ],
            "path": "/user/:username",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "description": "This can only be done by the logged in user.",
            "errors": [
                {
                    "description": "Invalid username supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "User not found",
                    "schema": "z.void()",
                    "status": 404,
                },
            ],
            "method": "delete",
            "parameters": [
                {
                    "name": "username",
                    "schema": "z.string()",
                    "type": "Path",
                },
            ],
            "path": "/user/:username",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "description": "Creates list of users with given input array",
            "errors": [],
            "method": "post",
            "parameters": [
                {
                    "description": "",
                    "name": "body",
                    "schema": "z.array(User)",
                    "type": "Body",
                },
            ],
            "path": "/user/createWithList",
            "requestFormat": "json",
            "response": "User",
        },
        {
            "errors": [
                {
                    "description": "Invalid username/password supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "username",
                    "schema": "z.string().optional()",
                    "type": "Query",
                },
                {
                    "name": "password",
                    "schema": "z.string().optional()",
                    "type": "Query",
                },
            ],
            "path": "/user/login",
            "requestFormat": "json",
            "response": "z.string()",
        },
        {
            "errors": [],
            "method": "get",
            "parameters": [],
            "path": "/user/logout",
            "requestFormat": "json",
            "response": "z.void()",
        },
    ],
    "endpointsGroups": {},
    "options": {
        "baseUrl": "",
        "withAlias": false,
    },
    "schemas": {
        "ApiResponse": "z.object({ code: z.number().int(), type: z.string(), message: z.string() }).partial().passthrough()",
        "Category": "z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()",
        "Order": "z.object({ id: z.number().int(), petId: z.number().int(), quantity: z.number().int(), shipDate: z.string().datetime({ offset: true }), status: z.enum(["placed", "approved", "delivered"]), complete: z.boolean() }).partial().passthrough()",
        "Pet": "z.object({ id: z.number().int().optional(), name: z.string(), category: Category.optional(), photoUrls: z.array(z.string()), tags: z.array(Tag).optional(), status: z.enum(["available", "pending", "sold"]).optional() }).passthrough()",
        "Tag": "z.object({ id: z.number().int(), name: z.string() }).partial().passthrough()",
        "User": "z.object({ id: z.number().int(), username: z.string(), firstName: z.string(), lastName: z.string(), email: z.string(), password: z.string(), phone: z.string(), userStatus: z.number().int() }).partial().passthrough()",
    },
    "types": {},
}
`;

exports[`getZodClientTemplateContext with allReadonly 1`] = `
{
    "circularTypeByName": {},
    "emittedType": {},
    "endpoints": [
        {
            "description": "Add a new pet to the store",
            "errors": [
                {
                    "description": "Invalid input",
                    "schema": "z.void()",
                    "status": 405,
                },
            ],
            "method": "post",
            "parameters": [
                {
                    "description": "Create a new pet in the store",
                    "name": "body",
                    "schema": "Pet",
                    "type": "Body",
                },
            ],
            "path": "/pet",
            "requestFormat": "json",
            "response": "Pet",
        },
        {
            "description": "Update an existing pet by Id",
            "errors": [
                {
                    "description": "Invalid ID supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "Pet not found",
                    "schema": "z.void()",
                    "status": 404,
                },
                {
                    "description": "Validation exception",
                    "schema": "z.void()",
                    "status": 405,
                },
            ],
            "method": "put",
            "parameters": [
                {
                    "description": "Update an existent pet in the store",
                    "name": "body",
                    "schema": "Pet",
                    "type": "Body",
                },
            ],
            "path": "/pet",
            "requestFormat": "json",
            "response": "Pet",
        },
        {
            "description": "Returns a single pet",
            "errors": [
                {
                    "description": "Invalid ID supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "Pet not found",
                    "schema": "z.void()",
                    "status": 404,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "petId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
            ],
            "path": "/pet/:petId",
            "requestFormat": "json",
            "response": "Pet",
        },
        {
            "errors": [
                {
                    "description": "Invalid input",
                    "schema": "z.void()",
                    "status": 405,
                },
            ],
            "method": "post",
            "parameters": [
                {
                    "name": "petId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
                {
                    "name": "name",
                    "schema": "z.string().optional()",
                    "type": "Query",
                },
                {
                    "name": "status",
                    "schema": "z.string().optional()",
                    "type": "Query",
                },
            ],
            "path": "/pet/:petId",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "description": "delete a pet",
            "errors": [
                {
                    "description": "Invalid pet value",
                    "schema": "z.void()",
                    "status": 400,
                },
            ],
            "method": "delete",
            "parameters": [
                {
                    "name": "api_key",
                    "schema": "z.string().optional()",
                    "type": "Header",
                },
                {
                    "name": "petId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
            ],
            "path": "/pet/:petId",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "errors": [],
            "method": "post",
            "parameters": [
                {
                    "description": "",
                    "name": "body",
                    "schema": "z.instanceof(File)",
                    "type": "Body",
                },
                {
                    "name": "petId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
                {
                    "name": "additionalMetadata",
                    "schema": "z.string().optional()",
                    "type": "Query",
                },
            ],
            "path": "/pet/:petId/uploadImage",
            "requestFormat": "binary",
            "response": "ApiResponse",
        },
        {
            "description": "Multiple status values can be provided with comma separated strings",
            "errors": [
                {
                    "description": "Invalid status value",
                    "schema": "z.void()",
                    "status": 400,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "status",
                    "schema": "z.enum(["available", "pending", "sold"]).optional().default("available")",
                    "type": "Query",
                },
            ],
            "path": "/pet/findByStatus",
            "requestFormat": "json",
            "response": "z.array(Pet).readonly()",
        },
        {
            "description": "Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.",
            "errors": [
                {
                    "description": "Invalid tag value",
                    "schema": "z.void()",
                    "status": 400,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "tags",
                    "schema": "z.array(z.string()).readonly().optional()",
                    "type": "Query",
                },
            ],
            "path": "/pet/findByTags",
            "requestFormat": "json",
            "response": "z.array(Pet).readonly()",
        },
        {
            "description": "Returns a map of status codes to quantities",
            "errors": [],
            "method": "get",
            "parameters": [],
            "path": "/store/inventory",
            "requestFormat": "json",
            "response": "z.record(z.number().int())",
        },
        {
            "description": "Place a new order in the store",
            "errors": [
                {
                    "description": "Invalid input",
                    "schema": "z.void()",
                    "status": 405,
                },
            ],
            "method": "post",
            "parameters": [
                {
                    "description": "",
                    "name": "body",
                    "schema": "Order",
                    "type": "Body",
                },
            ],
            "path": "/store/order",
            "requestFormat": "json",
            "response": "Order",
        },
        {
            "description": "For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.",
            "errors": [
                {
                    "description": "Invalid ID supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "Order not found",
                    "schema": "z.void()",
                    "status": 404,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "orderId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
            ],
            "path": "/store/order/:orderId",
            "requestFormat": "json",
            "response": "Order",
        },
        {
            "description": "For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors",
            "errors": [
                {
                    "description": "Invalid ID supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "Order not found",
                    "schema": "z.void()",
                    "status": 404,
                },
            ],
            "method": "delete",
            "parameters": [
                {
                    "name": "orderId",
                    "schema": "z.number().int()",
                    "type": "Path",
                },
            ],
            "path": "/store/order/:orderId",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "description": "This can only be done by the logged in user.",
            "errors": [],
            "method": "post",
            "parameters": [
                {
                    "description": "Created user object",
                    "name": "body",
                    "schema": "User",
                    "type": "Body",
                },
            ],
            "path": "/user",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "errors": [
                {
                    "description": "Invalid username supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "User not found",
                    "schema": "z.void()",
                    "status": 404,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "username",
                    "schema": "z.string()",
                    "type": "Path",
                },
            ],
            "path": "/user/:username",
            "requestFormat": "json",
            "response": "User",
        },
        {
            "description": "This can only be done by the logged in user.",
            "errors": [],
            "method": "put",
            "parameters": [
                {
                    "description": "Update an existent user in the store",
                    "name": "body",
                    "schema": "User",
                    "type": "Body",
                },
                {
                    "name": "username",
                    "schema": "z.string()",
                    "type": "Path",
                },
            ],
            "path": "/user/:username",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "description": "This can only be done by the logged in user.",
            "errors": [
                {
                    "description": "Invalid username supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
                {
                    "description": "User not found",
                    "schema": "z.void()",
                    "status": 404,
                },
            ],
            "method": "delete",
            "parameters": [
                {
                    "name": "username",
                    "schema": "z.string()",
                    "type": "Path",
                },
            ],
            "path": "/user/:username",
            "requestFormat": "json",
            "response": "z.void()",
        },
        {
            "description": "Creates list of users with given input array",
            "errors": [],
            "method": "post",
            "parameters": [
                {
                    "description": "",
                    "name": "body",
                    "schema": "z.array(User).readonly()",
                    "type": "Body",
                },
            ],
            "path": "/user/createWithList",
            "requestFormat": "json",
            "response": "User",
        },
        {
            "errors": [
                {
                    "description": "Invalid username/password supplied",
                    "schema": "z.void()",
                    "status": 400,
                },
            ],
            "method": "get",
            "parameters": [
                {
                    "name": "username",
                    "schema": "z.string().optional()",
                    "type": "Query",
                },
                {
                    "name": "password",
                    "schema": "z.string().optional()",
                    "type": "Query",
                },
            ],
            "path": "/user/login",
            "requestFormat": "json",
            "response": "z.string()",
        },
        {
            "errors": [],
            "method": "get",
            "parameters": [],
            "path": "/user/logout",
            "requestFormat": "json",
            "response": "z.void()",
        },
    ],
    "endpointsGroups": {},
    "options": {
        "baseUrl": "",
        "withAlias": false,
    },
    "schemas": {
        "ApiResponse": "z.object({ code: z.number().int(), type: z.string(), message: z.string() }).partial().passthrough().readonly()",
        "Category": "z.object({ id: z.number().int(), name: z.string() }).partial().passthrough().readonly()",
        "Order": "z.object({ id: z.number().int(), petId: z.number().int(), quantity: z.number().int(), shipDate: z.string().datetime({ offset: true }), status: z.enum(["placed", "approved", "delivered"]), complete: z.boolean() }).partial().passthrough().readonly()",
        "Pet": "z.object({ id: z.number().int().optional(), name: z.string(), category: Category.optional(), photoUrls: z.array(z.string()).readonly(), tags: z.array(Tag).readonly().optional(), status: z.enum(["available", "pending", "sold"]).optional() }).passthrough().readonly()",
        "Tag": "z.object({ id: z.number().int(), name: z.string() }).partial().passthrough().readonly()",
        "User": "z.object({ id: z.number().int(), username: z.string(), firstName: z.string(), lastName: z.string(), email: z.string(), password: z.string(), phone: z.string(), userStatus: z.number().int() }).partial().passthrough().readonly()",
    },
    "types": {},
}
`;

exports[`with optional, partial, all required objects 1`] = `
{
    "circularTypeByName": {
        "Nested2": true,
        "Root2": true,
    },
    "emittedType": {
        "Nested2": true,
        "Root2": true,
    },
    "endpoints": [
        {
            "errors": [],
            "method": "get",
            "parameters": [],
            "path": "/deeplyNested",
            "requestFormat": "json",
            "response": "z.array(VeryDeeplyNested)",
        },
        {
            "errors": [],
            "method": "get",
            "parameters": [],
            "path": "/nested",
            "requestFormat": "json",
            "response": "z.object({ nested_prop: z.boolean().optional(), deeplyNested: DeeplyNested.optional(), circularToRoot: Root2.optional(), requiredProp: z.string() }).passthrough()",
        },
        {
            "errors": [],
            "method": "get",
            "parameters": [],
            "path": "/root",
            "requestFormat": "json",
            "response": "z.object({ str: z.string(), nb: z.number(), nested: Nested2, partial: PartialObject.optional(), optionalProp: z.string().optional() }).passthrough()",
        },
        {
            "errors": [],
            "method": "get",
            "parameters": [],
            "path": "/veryDeeplyNested",
            "requestFormat": "json",
            "response": "z.enum(["aaa", "bbb", "ccc"])",
        },
    ],
    "endpointsGroups": {},
    "options": {
        "baseUrl": "",
        "withAlias": false,
    },
    "schemas": {
        "DeeplyNested": "z.array(VeryDeeplyNested)",
        "Nested2": "z.lazy(() => z.object({ nested_prop: z.boolean().optional(), deeplyNested: DeeplyNested.optional(), circularToRoot: Root2.optional(), requiredProp: z.string() }).passthrough())",
        "PartialObject": "z.object({ something: z.string(), another: z.number() }).partial().passthrough()",
        "Root2": "z.lazy(() => z.object({ str: z.string(), nb: z.number(), nested: Nested2, partial: PartialObject.optional(), optionalProp: z.string().optional() }).passthrough())",
        "VeryDeeplyNested": "z.enum(["aaa", "bbb", "ccc"])",
    },
    "types": {
        "DeeplyNested": "type DeeplyNested = Array<VeryDeeplyNested>;",
        "Nested2": "type Nested2 = { nested_prop: boolean?; deeplyNested: DeeplyNested?; circularToRoot: Root2?; requiredProp: string };",
        "PartialObject": "type PartialObject = Partial<{ something: string; another: number }>;",
        "Root2": "type Root2 = { str: string; nb: number; nested: Nested2; partial: PartialObject?; optionalProp: string? };",
        "VeryDeeplyNested": "type VeryDeeplyNested = "aaa" | "bbb" | "ccc";",
    },
}
`;

exports[`with optional, partial, all required objects 2`] = `
"import { z } from "zod";

type Root2 = {
  str: string;
  nb: number;
  nested: Nested2;
  partial: PartialObject?;
  optionalProp: string?;
};
type DeeplyNested = Array<VeryDeeplyNested>;
type VeryDeeplyNested = "aaa" | "bbb" | "ccc";
type PartialObject = Partial<{ something: string; another: number }>;
type Nested2 = {
  nested_prop: boolean?;
  deeplyNested: DeeplyNested?;
  circularToRoot: Root2?;
  requiredProp: string;
};

export const VeryDeeplyNested = z.enum(["aaa", "bbb", "ccc"]);
export const DeeplyNested = z.array(VeryDeeplyNested);
export const PartialObject = z
  .object({ something: z.string(), another: z.number() })
  .partial()
  .strict();
export const Root2: z.ZodType<Root2> = z.lazy(() =>
  z
    .object({
      str: z.string(),
      nb: z.number(),
      nested: Nested2,
      partial: PartialObject.optional(),
      optionalProp: z.string().optional(),
    })
    .strict(),
);
export const Nested2: z.ZodType<Nested2> = z.lazy(() =>
  z
    .object({
      nested_prop: z.boolean().optional(),
      deeplyNested: DeeplyNested.optional(),
      circularToRoot: Root2.optional(),
      requiredProp: z.string(),
    })
    .strict(),
);

export const endpoints = [
  {
    method: "get" as const,
    path: "/deeplyNested",
    operationId: "getDeeplyNested",
    request: {},
    responses: {
      200: { description: "OK", schema: z.array(VeryDeeplyNested) },
    },
  },
  {
    method: "get" as const,
    path: "/nested",
    operationId: "getNested",
    request: {},
    responses: {
      200: {
        description: "OK",
        schema: z
          .object({
            nested_prop: z.boolean().optional(),
            deeplyNested: DeeplyNested.optional(),
            circularToRoot: Root2.optional(),
            requiredProp: z.string(),
          })
          .strict(),
      },
    },
  },
  {
    method: "get" as const,
    path: "/root",
    operationId: "getRoot",
    request: {},
    responses: {
      200: {
        description: "OK",
        schema: z
          .object({
            str: z.string(),
            nb: z.number(),
            nested: Nested2,
            partial: PartialObject.optional(),
            optionalProp: z.string().optional(),
          })
          .strict(),
      },
    },
  },
  {
    method: "get" as const,
    path: "/veryDeeplyNested",
    operationId: "getVeryDeeplyNested",
    request: {},
    responses: {
      200: { description: "OK", schema: z.enum(["aaa", "bbb", "ccc"]) },
    },
  },
] as const;

/**
 * MCP (Model Context Protocol) compatible tool definitions.
 *
 * Each endpoint is transformed into an MCP tool with:
 * - \`name\`: Unique identifier (operationId or auto-generated from method + path)
 * - \`description\`: Human-readable description of the tool's purpose
 * - \`inputSchema\`: Consolidated Zod schema for all request parameters (path, query, headers, body)
 * - \`outputSchema\`: Zod schema for the primary success response (200/201) or z.unknown()
 *
 * MCP tools use a consolidated input structure (all params in one object) rather than
 * the separated structure in \`endpoints\`, making them optimized for AI tool integration.
 * The output schema focuses on the "happy path" (primary success response). Error handling
 * is typically done at the protocol level.
 *
 * @see https://anthropic.com/mcp - Model Context Protocol specification
 * @example
 * \`\`\`typescript
 * import { mcpTools } from "./api";
 *
 * // AI assistant discovers and validates tool usage
 * const tool = mcpTools.find(t => t.name === "getUserById");
 * const input = tool.inputSchema.parse({
 *   path: { userId: "123" },
 *   query: { include: "profile" }
 * });
 * \`\`\`
 */
export const mcpTools = endpoints.map((endpoint) => {
  // Build consolidated params object from all request parameter types
  // MCP requires a single inputSchema, not separated path/query/headers/body
  const params: Record<string, z.ZodTypeAny> = {};
  if (endpoint.request?.pathParams) params.path = endpoint.request.pathParams;
  if (endpoint.request?.queryParams)
    params.query = endpoint.request.queryParams;
  if (endpoint.request?.headers) params.headers = endpoint.request.headers;
  if (endpoint.request?.body) params.body = endpoint.request.body;

  return {
    // Use operationId for the canonical name, with fallback to generated name
    name:
      endpoint.operationId ||
      \`\${endpoint.method}_\${endpoint.path.replace(/[\\/{}]/g, "_")}\`,
    // Provide description for AI context
    description:
      endpoint.description ||
      \`\${endpoint.method.toUpperCase()} \${endpoint.path}\`,
    // Consolidated input schema (path, query, headers, body all nested)
    inputSchema:
      Object.keys(params).length > 0 ? z.object(params) : z.object({}),
    // Primary success response (200 or 201), fallback to z.unknown() for safety
    outputSchema:
      endpoint.responses[200]?.schema ||
      endpoint.responses[201]?.schema ||
      z.unknown(),
  };
}) as const;
"
`;
